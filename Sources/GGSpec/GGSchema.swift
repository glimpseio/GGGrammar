import BricBrac
import struct Foundation.UUID


public protocol GGType {
}

public enum GG {
public typealias ColorDef = MarkPropDefGradientStringNull

public typealias ConditionalAxisColor = ConditionalAxisPropertyColorNull

public typealias ConditionalAxisLabelAlign = ConditionalAxisPropertyAlignNull

public typealias ConditionalAxisLabelBaseline = ConditionalAxisPropertyTextBaselineNull

public typealias ConditionalAxisLabelFontStyle = ConditionalAxisPropertyFontStyleNull

public typealias ConditionalAxisLabelFontWeight = ConditionalAxisPropertyFontWeightNull

public typealias ConditionalAxisNumber = ConditionalAxisPropertyNumberNull

public typealias ConditionalAxisNumberArray = ConditionalAxisPropertyNumberArrayNull

public typealias ConditionalAxisString = ConditionalAxisPropertyStringNull

public typealias Datasets = DictInlineDataset

public typealias Dict = Dictionary<String, DictValue>
public typealias DictValue = Bric

public typealias DictInlineDataset = Dictionary<String, DictInlineDatasetValue>
public typealias DictInlineDatasetValue = InlineDataset

public typealias DictSelectionInit = Dictionary<String, DictSelectionInitValue>
public typealias DictSelectionInitValue = SelectionInit

public typealias DictSelectionInitInterval = Dictionary<String, DictSelectionInitIntervalValue>
public typealias DictSelectionInitIntervalValue = SelectionInitInterval

public typealias FieldDefWithoutScale = TypedFieldDef

/// Generated by Curio
public typealias FontWeight = OneOf<FontWeightString>.Or<FontWeightDouble>
/// Generated by Curio
public enum FontWeightString : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case normal
    case bold
    case lighter
    case bolder
}
/// Generated by Curio
public enum FontWeightDouble : Double, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case n100_0 = 100.0
    case n200_0 = 200.0
    case n300_0 = 300.0
    case n400_0 = 400.0
    case n500_0 = 500.0
    case n600_0 = 600.0
    case n700_0 = 700.0
    case n800_0 = 800.0
    case n900_0 = 900.0
}

public typealias GeoJsonFeature = Bric

public typealias GeoJsonFeatureCollection = Bric

public typealias NonNormalizedSpec = Spec

public typealias NumericArrayMarkPropDef = MarkPropDefNumberArray

public typealias NumericMarkPropDef = MarkPropDefNumber

public typealias Parse = Dictionary<String, ParseValueType>
public typealias ParseValueType = ParseValue

public typealias PositionValueDef = ValueDefNumberWidthHeightExprRef

public typealias ProjectionConfig = Projection

public typealias RangeRaw = [RangeRawItem]
public struct RangeRawItem : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: Nullable<OneOf<Bool>.Or<String>.Or<Double>.Or<RangeRawArray>>

    public init(rawValue: Nullable<OneOf<Bool>.Or<String>.Or<Double>.Or<RangeRawArray>>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: Nullable<OneOf<Bool>.Or<String>.Or<Double>.Or<RangeRawArray>>) {
        self.rawValue = rawValue 
    }
}

public typealias RangeRawArray = [Double]

public typealias SelectionInitIntervalMapping = DictSelectionInitInterval

public typealias SelectionInitMapping = DictSelectionInit

public typealias ShapeDef = MarkPropDefStringNullTypeForShape

public typealias StringFieldDefWithCondition = FieldOrDatumDefWithConditionStringFieldDefString

public typealias StringValueDefWithCondition = ValueDefWithConditionMarkPropFieldOrDatumDefStringNull

public typealias TitleConfig = BaseTitleNoValueRefs

public typealias URI = String

public typealias UnitSpec = GenericUnitSpecEncodingAnyMark

public typealias Vector10String = [String]

public typealias Vector12String = [String]

public typealias Vector2Boolean = [Bool]

public typealias Vector2DateTime = [DateTime]

public typealias Vector2Number = [Double]

public typealias Vector2String = [String]

public typealias Vector2Vector2Number = [Vector2Number]

public typealias Vector3Number = [Double]

public typealias Vector7String = [String]

/// Generated by Curio
public enum AggregateOp : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case argmax
    case argmin
    case average
    case count
    case distinct
    case max
    case mean
    case median
    case min
    case missing
    case product
    case q1
    case q3
    case ci0
    case ci1
    case stderr
    case stdev
    case stdevp
    case sum
    case valid
    case values
    case variance
    case variancep
}

/// Generated by Curio
public enum Align : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case left
    case center
    case right
}

/// Generated by Curio
public enum AutosizeType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case pad
    case none
    case fit
    case fitX = "fit-x"
    case fitY = "fit-y"
}

/// Generated by Curio
public enum AxisOrient : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case top
    case bottom
    case left
    case right
}

/// Generated by Curio
public enum Baseline : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case top
    case middle
    case bottom
}

/// Generated by Curio
public enum Blend : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case multiply
    case screen
    case overlay
    case darken
    case lighten
    case colorDodge = "color-dodge"
    case colorBurn = "color-burn"
    case hardLight = "hard-light"
    case softLight = "soft-light"
    case difference
    case exclusion
    case hue
    case saturation
    case color
    case luminosity
}

/// Generated by Curio
public enum BoxPlotLiteral : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case boxplot
}

/// Generated by Curio
public enum Categorical : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case accent
    case category10
    case category20
    case category20b
    case category20c
    case dark2
    case paired
    case pastel1
    case pastel2
    case set1
    case set2
    case set3
    case tableau10
    case tableau20
}

/// Generated by Curio
public enum ColorName : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case black
    case silver
    case gray
    case white
    case maroon
    case red
    case purple
    case fuchsia
    case green
    case lime
    case olive
    case yellow
    case navy
    case blue
    case teal
    case aqua
    case orange
    case aliceblue
    case antiquewhite
    case aquamarine
    case azure
    case beige
    case bisque
    case blanchedalmond
    case blueviolet
    case brown
    case burlywood
    case cadetblue
    case chartreuse
    case chocolate
    case coral
    case cornflowerblue
    case cornsilk
    case crimson
    case cyan
    case darkblue
    case darkcyan
    case darkgoldenrod
    case darkgray
    case darkgreen
    case darkgrey
    case darkkhaki
    case darkmagenta
    case darkolivegreen
    case darkorange
    case darkorchid
    case darkred
    case darksalmon
    case darkseagreen
    case darkslateblue
    case darkslategray
    case darkslategrey
    case darkturquoise
    case darkviolet
    case deeppink
    case deepskyblue
    case dimgray
    case dimgrey
    case dodgerblue
    case firebrick
    case floralwhite
    case forestgreen
    case gainsboro
    case ghostwhite
    case gold
    case goldenrod
    case greenyellow
    case grey
    case honeydew
    case hotpink
    case indianred
    case indigo
    case ivory
    case khaki
    case lavender
    case lavenderblush
    case lawngreen
    case lemonchiffon
    case lightblue
    case lightcoral
    case lightcyan
    case lightgoldenrodyellow
    case lightgray
    case lightgreen
    case lightgrey
    case lightpink
    case lightsalmon
    case lightseagreen
    case lightskyblue
    case lightslategray
    case lightslategrey
    case lightsteelblue
    case lightyellow
    case limegreen
    case linen
    case magenta
    case mediumaquamarine
    case mediumblue
    case mediumorchid
    case mediumpurple
    case mediumseagreen
    case mediumslateblue
    case mediumspringgreen
    case mediumturquoise
    case mediumvioletred
    case midnightblue
    case mintcream
    case mistyrose
    case moccasin
    case navajowhite
    case oldlace
    case olivedrab
    case orangered
    case orchid
    case palegoldenrod
    case palegreen
    case paleturquoise
    case palevioletred
    case papayawhip
    case peachpuff
    case peru
    case pink
    case plum
    case powderblue
    case rosybrown
    case royalblue
    case saddlebrown
    case salmon
    case sandybrown
    case seagreen
    case seashell
    case sienna
    case skyblue
    case slateblue
    case slategray
    case slategrey
    case snow
    case springgreen
    case steelblue
    case tan
    case thistle
    case tomato
    case turquoise
    case violet
    case wheat
    case whitesmoke
    case yellowgreen
    case rebeccapurple
}

/// Generated by Curio
public enum Cursor : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case auto
    case `default`
    case none
    case contextMenu = "context-menu"
    case help
    case pointer
    case progress
    case wait
    case cell
    case crosshair
    case text
    case verticalText = "vertical-text"
    case alias
    case copy
    case move
    case noDrop = "no-drop"
    case notAllowed = "not-allowed"
    case eResize = "e-resize"
    case nResize = "n-resize"
    case neResize = "ne-resize"
    case nwResize = "nw-resize"
    case sResize = "s-resize"
    case seResize = "se-resize"
    case swResize = "sw-resize"
    case wResize = "w-resize"
    case ewResize = "ew-resize"
    case nsResize = "ns-resize"
    case neswResize = "nesw-resize"
    case nwseResize = "nwse-resize"
    case colResize = "col-resize"
    case rowResize = "row-resize"
    case allScroll = "all-scroll"
    case zoomIn = "zoom-in"
    case zoomOut = "zoom-out"
    case grab
    case grabbing
}

/// Generated by Curio
public enum Cyclical : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case rainbow
    case sinebow
}

/// Generated by Curio
public enum DataTransformation : Pure, Equatable, Hashable, Codable, GGType {
    case aggregateTransformCase(AggregateTransform)
    case binTransformCase(BinTransform)
    case calculateTransformCase(CalculateTransform)
    case densityTransformCase(DensityTransform)
    case filterTransformCase(FilterTransform)
    case flattenTransformCase(FlattenTransform)
    case foldTransformCase(FoldTransform)
    case imputeTransformCase(ImputeTransform)
    case joinAggregateTransformCase(JoinAggregateTransform)
    case loessTransformCase(LoessTransform)
    case lookupTransformCase(LookupTransform)
    case quantileTransformCase(QuantileTransform)
    case regressionTransformCase(RegressionTransform)
    case timeUnitTransformCase(TimeUnitTransform)
    case sampleTransformCase(SampleTransform)
    case stackTransformCase(StackTransform)
    case windowTransformCase(WindowTransform)
    case pivotTransformCase(PivotTransform)

    public init(_ arg: AggregateTransform) {
        self = .aggregateTransformCase(arg) 
    }

    public init(_ arg: BinTransform) {
        self = .binTransformCase(arg) 
    }

    public init(_ arg: CalculateTransform) {
        self = .calculateTransformCase(arg) 
    }

    public init(_ arg: DensityTransform) {
        self = .densityTransformCase(arg) 
    }

    public init(_ arg: FilterTransform) {
        self = .filterTransformCase(arg) 
    }

    public init(_ arg: FlattenTransform) {
        self = .flattenTransformCase(arg) 
    }

    public init(_ arg: FoldTransform) {
        self = .foldTransformCase(arg) 
    }

    public init(_ arg: ImputeTransform) {
        self = .imputeTransformCase(arg) 
    }

    public init(_ arg: JoinAggregateTransform) {
        self = .joinAggregateTransformCase(arg) 
    }

    public init(_ arg: LoessTransform) {
        self = .loessTransformCase(arg) 
    }

    public init(_ arg: LookupTransform) {
        self = .lookupTransformCase(arg) 
    }

    public init(_ arg: QuantileTransform) {
        self = .quantileTransformCase(arg) 
    }

    public init(_ arg: RegressionTransform) {
        self = .regressionTransformCase(arg) 
    }

    public init(_ arg: TimeUnitTransform) {
        self = .timeUnitTransformCase(arg) 
    }

    public init(_ arg: SampleTransform) {
        self = .sampleTransformCase(arg) 
    }

    public init(_ arg: StackTransform) {
        self = .stackTransformCase(arg) 
    }

    public init(_ arg: WindowTransform) {
        self = .windowTransformCase(arg) 
    }

    public init(_ arg: PivotTransform) {
        self = .pivotTransformCase(arg) 
    }

    public func encode(to encoder: Encoder) throws -> () {
        switch self { 
        case .aggregateTransformCase(let x): try x.encode(to: encoder) 
        case .binTransformCase(let x): try x.encode(to: encoder) 
        case .calculateTransformCase(let x): try x.encode(to: encoder) 
        case .densityTransformCase(let x): try x.encode(to: encoder) 
        case .filterTransformCase(let x): try x.encode(to: encoder) 
        case .flattenTransformCase(let x): try x.encode(to: encoder) 
        case .foldTransformCase(let x): try x.encode(to: encoder) 
        case .imputeTransformCase(let x): try x.encode(to: encoder) 
        case .joinAggregateTransformCase(let x): try x.encode(to: encoder) 
        case .loessTransformCase(let x): try x.encode(to: encoder) 
        case .lookupTransformCase(let x): try x.encode(to: encoder) 
        case .quantileTransformCase(let x): try x.encode(to: encoder) 
        case .regressionTransformCase(let x): try x.encode(to: encoder) 
        case .timeUnitTransformCase(let x): try x.encode(to: encoder) 
        case .sampleTransformCase(let x): try x.encode(to: encoder) 
        case .stackTransformCase(let x): try x.encode(to: encoder) 
        case .windowTransformCase(let x): try x.encode(to: encoder) 
        case .pivotTransformCase(let x): try x.encode(to: encoder) 
        } 
    }

    public init(from decoder: Decoder) throws {
        var errors: [Error] = [] 
        do { self = try .aggregateTransformCase(AggregateTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .binTransformCase(BinTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .calculateTransformCase(CalculateTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .densityTransformCase(DensityTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .filterTransformCase(FilterTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .flattenTransformCase(FlattenTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .foldTransformCase(FoldTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .imputeTransformCase(ImputeTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .joinAggregateTransformCase(JoinAggregateTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .loessTransformCase(LoessTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .lookupTransformCase(LookupTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .quantileTransformCase(QuantileTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .regressionTransformCase(RegressionTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .timeUnitTransformCase(TimeUnitTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .sampleTransformCase(SampleTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .stackTransformCase(StackTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .windowTransformCase(WindowTransform(from: decoder)); return } catch { errors.append(error) } 
        do { self = try .pivotTransformCase(PivotTransform(from: decoder)); return } catch { errors.append(error) } 
        throw OneOfDecodingError(errors: errors) 
    }
}

/// Generated by Curio
public enum Diverging : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case blueorange
    case blueorange3 = "blueorange-3"
    case blueorange4 = "blueorange-4"
    case blueorange5 = "blueorange-5"
    case blueorange6 = "blueorange-6"
    case blueorange7 = "blueorange-7"
    case blueorange8 = "blueorange-8"
    case blueorange9 = "blueorange-9"
    case blueorange10 = "blueorange-10"
    case blueorange11 = "blueorange-11"
    case brownbluegreen
    case brownbluegreen3 = "brownbluegreen-3"
    case brownbluegreen4 = "brownbluegreen-4"
    case brownbluegreen5 = "brownbluegreen-5"
    case brownbluegreen6 = "brownbluegreen-6"
    case brownbluegreen7 = "brownbluegreen-7"
    case brownbluegreen8 = "brownbluegreen-8"
    case brownbluegreen9 = "brownbluegreen-9"
    case brownbluegreen10 = "brownbluegreen-10"
    case brownbluegreen11 = "brownbluegreen-11"
    case purplegreen
    case purplegreen3 = "purplegreen-3"
    case purplegreen4 = "purplegreen-4"
    case purplegreen5 = "purplegreen-5"
    case purplegreen6 = "purplegreen-6"
    case purplegreen7 = "purplegreen-7"
    case purplegreen8 = "purplegreen-8"
    case purplegreen9 = "purplegreen-9"
    case purplegreen10 = "purplegreen-10"
    case purplegreen11 = "purplegreen-11"
    case pinkyellowgreen
    case pinkyellowgreen3 = "pinkyellowgreen-3"
    case pinkyellowgreen4 = "pinkyellowgreen-4"
    case pinkyellowgreen5 = "pinkyellowgreen-5"
    case pinkyellowgreen6 = "pinkyellowgreen-6"
    case pinkyellowgreen7 = "pinkyellowgreen-7"
    case pinkyellowgreen8 = "pinkyellowgreen-8"
    case pinkyellowgreen9 = "pinkyellowgreen-9"
    case pinkyellowgreen10 = "pinkyellowgreen-10"
    case pinkyellowgreen11 = "pinkyellowgreen-11"
    case purpleorange
    case purpleorange3 = "purpleorange-3"
    case purpleorange4 = "purpleorange-4"
    case purpleorange5 = "purpleorange-5"
    case purpleorange6 = "purpleorange-6"
    case purpleorange7 = "purpleorange-7"
    case purpleorange8 = "purpleorange-8"
    case purpleorange9 = "purpleorange-9"
    case purpleorange10 = "purpleorange-10"
    case purpleorange11 = "purpleorange-11"
    case redblue
    case redblue3 = "redblue-3"
    case redblue4 = "redblue-4"
    case redblue5 = "redblue-5"
    case redblue6 = "redblue-6"
    case redblue7 = "redblue-7"
    case redblue8 = "redblue-8"
    case redblue9 = "redblue-9"
    case redblue10 = "redblue-10"
    case redblue11 = "redblue-11"
    case redgrey
    case redgrey3 = "redgrey-3"
    case redgrey4 = "redgrey-4"
    case redgrey5 = "redgrey-5"
    case redgrey6 = "redgrey-6"
    case redgrey7 = "redgrey-7"
    case redgrey8 = "redgrey-8"
    case redgrey9 = "redgrey-9"
    case redgrey10 = "redgrey-10"
    case redgrey11 = "redgrey-11"
    case redyellowblue
    case redyellowblue3 = "redyellowblue-3"
    case redyellowblue4 = "redyellowblue-4"
    case redyellowblue5 = "redyellowblue-5"
    case redyellowblue6 = "redyellowblue-6"
    case redyellowblue7 = "redyellowblue-7"
    case redyellowblue8 = "redyellowblue-8"
    case redyellowblue9 = "redyellowblue-9"
    case redyellowblue10 = "redyellowblue-10"
    case redyellowblue11 = "redyellowblue-11"
    case redyellowgreen
    case redyellowgreen3 = "redyellowgreen-3"
    case redyellowgreen4 = "redyellowgreen-4"
    case redyellowgreen5 = "redyellowgreen-5"
    case redyellowgreen6 = "redyellowgreen-6"
    case redyellowgreen7 = "redyellowgreen-7"
    case redyellowgreen8 = "redyellowgreen-8"
    case redyellowgreen9 = "redyellowgreen-9"
    case redyellowgreen10 = "redyellowgreen-10"
    case redyellowgreen11 = "redyellowgreen-11"
    case spectral
    case spectral3 = "spectral-3"
    case spectral4 = "spectral-4"
    case spectral5 = "spectral-5"
    case spectral6 = "spectral-6"
    case spectral7 = "spectral-7"
    case spectral8 = "spectral-8"
    case spectral9 = "spectral-9"
    case spectral10 = "spectral-10"
    case spectral11 = "spectral-11"
}

/// Generated by Curio
public enum ErrorBandLiteral : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case errorband
}

/// Generated by Curio
public enum ErrorBarExtent : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case ci
    case iqr
    case stderr
    case stdev
}

/// Generated by Curio
public enum ErrorBarLiteral : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case errorbar
}

/// Generated by Curio
public enum EventType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case click
    case dblclick
    case dragenter
    case dragleave
    case dragover
    case keydown
    case keypress
    case keyup
    case mousedown
    case mousemove
    case mouseout
    case mouseover
    case mouseup
    case mousewheel
    case timer
    case touchend
    case touchmove
    case touchstart
    case wheel
}

public enum GGSchema {

    public enum Aliases : String, CaseIterable, Hashable {
        case ColorDef
        case ConditionalAxisColor
        case ConditionalAxisLabelAlign
        case ConditionalAxisLabelBaseline
        case ConditionalAxisLabelFontStyle
        case ConditionalAxisLabelFontWeight
        case ConditionalAxisNumber
        case ConditionalAxisNumberArray
        case ConditionalAxisString
        case Datasets
        case Dict
        case DictInlineDataset
        case DictSelectionInit
        case DictSelectionInitInterval
        case FieldDefWithoutScale
        case FontWeight
        case GeoJsonFeature
        case GeoJsonFeatureCollection
        case NonNormalizedSpec
        case NumericArrayMarkPropDef
        case NumericMarkPropDef
        case Parse
        case PositionValueDef
        case ProjectionConfig
        case RangeRaw
        case RangeRawArray
        case SelectionInitIntervalMapping
        case SelectionInitMapping
        case ShapeDef
        case StringFieldDefWithCondition
        case StringValueDefWithCondition
        case TitleConfig
        case URI
        case UnitSpec
        case Vector10String
        case Vector12String
        case Vector2Boolean
        case Vector2DateTime
        case Vector2Number
        case Vector2String
        case Vector2Vector2Number
        case Vector3Number
        case Vector7String
    }

    public enum Enums : String, CaseIterable, Hashable {
        case AggregateOp
        case Align
        case AutosizeType
        case AxisOrient
        case Baseline
        case Blend
        case BoxPlotLiteral
        case Categorical
        case ColorName
        case Cursor
        case Cyclical
        case Diverging
        case ErrorBandLiteral
        case ErrorBarExtent
        case ErrorBarLiteral
        case EventType
        case ImputeMethod
        case Interpolate
        case LayoutAlign
        case LegendOrient
        case LiteralBinned
        case LiteralCenterOrExtent
        case LiteralContainer
        case LiteralFullOrFlush
        case LiteralHeight
        case LiteralMinMax
        case LiteralQuantitative
        case LiteralTransparent
        case LiteralWidth
        case LocalMultiTimeUnit
        case LocalSingleTimeUnit
        case MeasureType
        case NonArgAggregateOp
        case Orient
        case Orientation
        case PrimitiveMarkType
        case ProjectionType
        case RangeEnum
        case ResolveMode
        case ScaleInterpolateEnum
        case ScaleType
        case SelectionResolution
        case SelectionType
        case SequentialMultiHue
        case SequentialSingleHue
        case SingleDefUnitChannel
        case SortByChannel
        case SortByChannelDesc
        case SortOrder
        case StackOffset
        case StandardMeasureType
        case StrokeCap
        case StrokeJoin
        case TemporalUnit
        case TextDirection
        case TitleAnchor
        case TitleFrame
        case TitleOrient
        case TypeForShape
        case UtcMultiTimeUnit
        case UtcSingleTimeUnit
        case VgMarkType
        case WindowOnlyOp
    }

    public enum Structs : String, CaseIterable, Hashable {
        case AggregateTransform
        case AggregatedFieldDef
        case AreaConfig
        case ArgmaxDef
        case ArgminDef
        case AutoSizeParams
        case AxisConfig
        case AxisDef
        case AxisResolveMap
        case BarConfig
        case BaseTitleNoValueRefs
        case BinParams
        case BinTransform
        case BindCheckbox
        case BindDirect
        case BindInput
        case BindRadioSelect
        case BindRange
        case BoxPlotConfig
        case BoxPlotDef
        case BrushConfig
        case CalculateTransform
        case ColorGradientLinear
        case ColorGradientRadial
        case CompositionConfig
        case ConcatSpecGenericSpec
        case ConditionalParameterStringFieldDef
        case ConditionalParameterValueDefGradientStringNullExprRef
        case ConditionalParameterValueDefNumber
        case ConditionalParameterValueDefNumberArrayExprRef
        case ConditionalParameterValueDefNumberExprRef
        case ConditionalParameterValueDefStringExprRef
        case ConditionalParameterValueDefStringNullExprRef
        case ConditionalParameterValueDefTextExprRef
        case ConditionalPredicateStringFieldDef
        case ConditionalPredicateValueDefGradientStringNullExprRef
        case ConditionalPredicateValueDefNumber
        case ConditionalPredicateValueDefNumberArrayExprRef
        case ConditionalPredicateValueDefNumberExprRef
        case ConditionalPredicateValueDefStringExprRef
        case ConditionalPredicateValueDefStringNullExprReference
        case ConditionalPredicateValueDefTextExprRef
        case ConfigTheme
        case CsvDataFormat
        case DateTime
        case DatumDef
        case DensityTransform
        case DerivedStream
        case DomainUnionWith
        case DsvDataFormat
        case Encoding
        case EncodingChannelMap
        case EncodingSortField
        case ErrorBandConfig
        case ErrorBandDef
        case ErrorBarConfig
        case ErrorBarDef
        case ExprRef
        case FacetEncodingFieldDef
        case FacetFieldDef
        case FacetMapping
        case FacetSpec
        case FacetedUnitSpec
        case FieldEqualPredicate
        case FieldGTEPredicate
        case FieldGTPredicate
        case FieldLTEPredicate
        case FieldLTPredicate
        case FieldOneOfPredicate
        case FieldOrDatumDefWithConditionDatumDefGradientStringNull
        case FieldOrDatumDefWithConditionDatumDefNumber
        case FieldOrDatumDefWithConditionDatumDefNumberArray
        case FieldOrDatumDefWithConditionDatumDefStringNull
        case FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull
        case FieldOrDatumDefWithConditionMarkPropFieldDefNumber
        case FieldOrDatumDefWithConditionMarkPropFieldDefNumberArray
        case FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull
        case FieldOrDatumDefWithConditionStringDatumDefText
        case FieldOrDatumDefWithConditionStringFieldDefString
        case FieldOrDatumDefWithConditionStringFieldDefText
        case FieldRangePredicate
        case FieldValidPredicate
        case FilterTransform
        case FlattenTransform
        case FoldTransform
        case GenericUnitSpecEncodingAnyMark
        case GradientStop
        case GraticuleGenerator
        case GraticuleParams
        case HConcatSpecGenericSpec
        case HeaderConfig
        case HeaderDef
        case ImputeParams
        case ImputeSequence
        case ImputeTransform
        case InlineData
        case IntervalSelectionConfig
        case IntervalSelectionConfigWithoutType
        case JoinAggregateFieldDef
        case JoinAggregateTransform
        case JsonDataFormat
        case LatLongFieldDef
        case LayerRepeatMapping
        case LayerRepeatSpec
        case LayerSpec
        case LegendConfig
        case LegendDef
        case LegendResolveMap
        case LegendStreamBinding
        case LineConfig
        case Locale
        case LoessTransform
        case LogicalAndPredicate
        case LogicalNotPredicate
        case LogicalOrPredicate
        case LookupData
        case LookupSelection
        case LookupTransform
        case MarkConfig
        case MarkDef
        case MergedStream
        case NamedData
        case NonLayerRepeatSpec
        case NumberLocale
        case OrderFieldDef
        case OrderValueDef
        case OverlayMarkDef
        case ParameterPredicate
        case PivotTransform
        case PointSelectionConfig
        case PointSelectionConfigWithoutType
        case PositionDatumDef
        case PositionDatumDefBase
        case PositionFieldDef
        case PositionFieldDefBase
        case Projection
        case QuantileTransform
        case RangeConfig
        case RectConfig
        case RegressionTransform
        case RelativeBandSize
        case RepeatMapping
        case RepeatRef
        case Resolve
        case RowColBoolean
        case RowColLayoutAlign
        case RowColNumber
        case RowColumnEncodingFieldDef
        case SampleTransform
        case ScaleBinParams
        case ScaleConfig
        case ScaleDef
        case ScaleInterpolateParams
        case ScaleResolveMap
        case SchemeParams
        case SecondaryFieldDef
        case SelectionConfig
        case SelectionParameter
        case SequenceGenerator
        case SequenceParams
        case SharedEncoding
        case SortByEncoding
        case SortField
        case SphereGenerator
        case StackTransform
        case Step
        case StringFieldDef
        case StyleConfigIndex
        case TickConfig
        case TimeIntervalStep
        case TimeLocale
        case TimeUnitParams
        case TimeUnitTransform
        case TitleParams
        case TooltipContent
        case TopLevelConcatSpec
        case TopLevelFacetSpec
        case TopLevelHConcatSpec
        case TopLevelLayerSpec
        case TopLevelSelectionParameter
        case TopLevelUnitSpec
        case TopLevelVConcatSpec
        case TopoDataFormat
        case TypedFieldDef
        case UnitSpecWithFrame
        case UrlData
        case VConcatSpecGenericSpec
        case ValueDefNumber
        case ValueDefNumberWidthHeightExprRef
        case ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull
        case ValueDefWithConditionMarkPropFieldOrDatumDefNumber
        case ValueDefWithConditionMarkPropFieldOrDatumDefNumberArray
        case ValueDefWithConditionMarkPropFieldOrDatumDefStringNull
        case ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull
        case ValueDefWithConditionStringFieldDefText
        case VariableParameter
        case ViewBackground
        case ViewConfig
        case WindowFieldDef
        case WindowTransform
    }

    public enum Wrappers : String, CaseIterable, Hashable {
        case Aggregate
        case AllSortString
        case AnyMark
        case AnyMarkConfig
        case BinExtent
        case BindControl
        case ColorGradient
        case ColorLiteral
        case ColorScheme
        case CompositeMark
        case CompositeMarkDef
        case ConditionalAxisPropertyAlignNull
        case ConditionalAxisPropertyColorNull
        case ConditionalAxisPropertyFontStyleNull
        case ConditionalAxisPropertyFontWeightNull
        case ConditionalAxisPropertyNumberArrayNull
        case ConditionalAxisPropertyNumberNull
        case ConditionalAxisPropertyStringNull
        case ConditionalAxisPropertyTextBaselineNull
        case ConditionalMarkPropFieldOrDatumDef
        case ConditionalMarkPropFieldOrDatumDefTypeForShape
        case ConditionalParameterMarkPropFieldOrDatumDef
        case ConditionalParameterMarkPropFieldOrDatumDefTypeForShape
        case ConditionalPredicateMarkPropFieldOrDatumDef
        case ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape
        case ConditionalPredicateValueDefAlignNullExprRef
        case ConditionalPredicateValueDefColorNullExprRef
        case ConditionalPredicateValueDefFontStyleNullExprRef
        case ConditionalPredicateValueDefFontWeightNullExprRef
        case ConditionalPredicateValueDefNumberArrayNullExprRef
        case ConditionalPredicateValueDefNumberNullExprRef
        case ConditionalPredicateValueDefStringNullExprRef
        case ConditionalPredicateValueDefTextBaselineNullExprRef
        case ConditionalStringFieldDef
        case ConditionalValueDefGradientStringNullExprRef
        case ConditionalValueDefNumber
        case ConditionalValueDefNumberArrayExprRef
        case ConditionalValueDefNumberExprRef
        case ConditionalValueDefStringExprRef
        case ConditionalValueDefStringNullExprRef
        case ConditionalValueDefTextExprRef
        case DataFormat
        case DataProvider
        case DataSource
        case Day
        case Element
        case EventStream
        case Expr
        case FieldName
        case Fit
        case FontName
        case FontStyle
        case Generator
        case HexColor
        case InlineDataset
        case LabelOverlap
        case LatLongDef
        case LayerId
        case LegendBinding
        case MarkPropDefGradientStringNull
        case MarkPropDefNumber
        case MarkPropDefNumberArray
        case MarkPropDefStringNullTypeForShape
        case Month
        case MultiTimeUnit
        case Padding
        case ParameterExtent
        case ParameterId
        case ParameterName
        case ParseValue
        case PolarDef
        case Position2Def
        case PositionDef
        case Predicate
        case PredicateComposition
        case PrimitiveValue
        case RangeScheme
        case RepeatSpec
        case ScaleBins
        case SelectionInit
        case SelectionInitInterval
        case SingleTimeUnit
        case Sort
        case SortArray
        case SourceColumnRef
        case Spec
        case Stream
        case StringList
        case SymbolItem
        case SymbolShape
        case TextBaseline
        case TextDef
        case TickCount
        case TimeUnit
        case TopLevelRepeatSpec
        case TopLevelSpec
        case TransformId
        case WindowEventType
    }
}

/// Generated by Curio
public enum ImputeMethod : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case value
    case median
    case max
    case min
    case mean
}

/// Generated by Curio
public enum Interpolate : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case basis
    case basisOpen = "basis-open"
    case basisClosed = "basis-closed"
    case bundle
    case cardinal
    case cardinalOpen = "cardinal-open"
    case cardinalClosed = "cardinal-closed"
    case catmullRom = "catmull-rom"
    case linear
    case linearClosed = "linear-closed"
    case monotone
    case natural
    case step
    case stepBefore = "step-before"
    case stepAfter = "step-after"
}

/// Generated by Curio
public enum LayoutAlign : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case all
    case each
    case none
}

/// Generated by Curio
public enum LegendOrient : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case none
    case left
    case right
    case top
    case bottom
    case topLeft = "top-left"
    case topRight = "top-right"
    case bottomLeft = "bottom-left"
    case bottomRight = "bottom-right"
}

/// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
/// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
/// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
/// __Default value:__ `false`
/// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
/// Generated by Curio
public enum LiteralBinned : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case binned
}

/// Generated by Curio
public enum LiteralCenterOrExtent : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case center
    case extent
}

/// The height of a visualization.
/// - For a plot with a continuous y-field, height should be a number.
/// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
/// - To enable responsive sizing on height, it should be set to `"container"`.
/// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
/// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
/// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
/// Generated by Curio
public enum LiteralContainer : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case container
}

/// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
/// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
/// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
/// __Default value:__ `"full"`
/// Generated by Curio
public enum LiteralFullOrFlush : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case full
    case flush
}

/// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
/// Generated by Curio
public enum LiteralHeight : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case height
}

/// The extent of the whiskers. Available options include:
/// - `"min-max"`: min and max are the lower and upper whiskers respectively.
/// - A number representing multiple of the interquartile range. This number will be multiplied by the IQR to determine whisker boundary, which spans from the smallest data to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_ are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).
/// __Default value:__ `1.5`.
/// Generated by Curio
public enum LiteralMinMax : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case minMax = "min-max"
}

/// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
/// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
/// __Default value:__
/// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
/// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
/// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
/// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
/// 2) For a constant value in data domain (`datum`):
/// - `"quantitative"` if the datum is a number
/// - `"nominal"` if the datum is a string
/// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
/// __Note:__
/// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
/// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
/// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
/// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
/// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
/// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
/// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
/// Generated by Curio
public enum LiteralQuantitative : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case quantitative
}

/// A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.
/// - If this property is `"transparent"`, transparent points will be used (for enhancing tooltips and selections).
/// - If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.
/// - If this property is `false`, no points would be automatically added to line or area marks.
/// __Default value:__ `false`.
/// Generated by Curio
public enum LiteralTransparent : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case transparent
}

/// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
/// Generated by Curio
public enum LiteralWidth : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case width
}

/// Generated by Curio
public enum LocalMultiTimeUnit : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case yearquarter
    case yearquartermonth
    case yearmonth
    case yearmonthdate
    case yearmonthdatehours
    case yearmonthdatehoursminutes
    case yearmonthdatehoursminutesseconds
    case yearweek
    case yearweekday
    case yearweekdayhours
    case yearweekdayhoursminutes
    case yearweekdayhoursminutesseconds
    case yeardayofyear
    case quartermonth
    case monthdate
    case monthdatehours
    case monthdatehoursminutes
    case monthdatehoursminutesseconds
    case weekday
    case weeksdayhours
    case weekdayhoursminutes
    case weekdayhoursminutesseconds
    case dayhours
    case dayhoursminutes
    case dayhoursminutesseconds
    case hoursminutes
    case hoursminutesseconds
    case minutesseconds
    case secondsmilliseconds
}

/// Generated by Curio
public enum LocalSingleTimeUnit : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case year
    case quarter
    case month
    case week
    case day
    case dayofyear
    case date
    case hours
    case minutes
    case seconds
    case milliseconds
}

/// Data type based on level of measurement
/// Generated by Curio
public enum MeasureType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case quantitative
    case ordinal
    case temporal
    case nominal
    case geojson
}

/// Generated by Curio
public enum NonArgAggregateOp : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case average
    case count
    case distinct
    case max
    case mean
    case median
    case min
    case missing
    case product
    case q1
    case q3
    case ci0
    case ci1
    case stderr
    case stdev
    case stdevp
    case sum
    case valid
    case values
    case variance
    case variancep
}

/// Generated by Curio
public enum Orient : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case left
    case right
    case top
    case bottom
}

/// Generated by Curio
public enum Orientation : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case horizontal
    case vertical
}

/// All types of primitive marks.
/// Generated by Curio
public enum PrimitiveMarkType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case arc
    case area
    case bar
    case image
    case line
    case point
    case rect
    case rule
    case text
    case tick
    case trail
    case circle
    case square
    case geoshape
}

/// Generated by Curio
public enum ProjectionType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case albers
    case albersUsa
    case azimuthalEqualArea
    case azimuthalEquidistant
    case conicConformal
    case conicEqualArea
    case conicEquidistant
    case equalEarth
    case equirectangular
    case gnomonic
    case identity
    case mercator
    case naturalEarth1
    case orthographic
    case stereographic
    case transverseMercator
}

/// Generated by Curio
public enum RangeEnum : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case width
    case height
    case symbol
    case category
    case ordinal
    case ramp
    case diverging
    case heatmap
}

/// Generated by Curio
public enum ResolveMode : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case independent
    case shared
}

/// Generated by Curio
public enum ScaleInterpolateEnum : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case rgb
    case lab
    case hcl
    case hsl
    case hslLong = "hsl-long"
    case hclLong = "hcl-long"
    case cubehelix
    case cubehelixLong = "cubehelix-long"
}

/// Generated by Curio
public enum ScaleType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case linear
    case log
    case pow
    case sqrt
    case symlog
    case identity
    case sequential
    case time
    case utc
    case quantile
    case quantize
    case threshold
    case binOrdinal = "bin-ordinal"
    case ordinal
    case point
    case band
}

/// Generated by Curio
public enum SelectionResolution : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case global
    case union
    case intersect
}

/// Generated by Curio
public enum SelectionType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case point
    case interval
}

/// Generated by Curio
public enum SequentialMultiHue : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case turbo
    case viridis
    case inferno
    case magma
    case plasma
    case cividis
    case bluegreen
    case bluegreen3 = "bluegreen-3"
    case bluegreen4 = "bluegreen-4"
    case bluegreen5 = "bluegreen-5"
    case bluegreen6 = "bluegreen-6"
    case bluegreen7 = "bluegreen-7"
    case bluegreen8 = "bluegreen-8"
    case bluegreen9 = "bluegreen-9"
    case bluepurple
    case bluepurple3 = "bluepurple-3"
    case bluepurple4 = "bluepurple-4"
    case bluepurple5 = "bluepurple-5"
    case bluepurple6 = "bluepurple-6"
    case bluepurple7 = "bluepurple-7"
    case bluepurple8 = "bluepurple-8"
    case bluepurple9 = "bluepurple-9"
    case goldgreen
    case goldgreen3 = "goldgreen-3"
    case goldgreen4 = "goldgreen-4"
    case goldgreen5 = "goldgreen-5"
    case goldgreen6 = "goldgreen-6"
    case goldgreen7 = "goldgreen-7"
    case goldgreen8 = "goldgreen-8"
    case goldgreen9 = "goldgreen-9"
    case goldorange
    case goldorange3 = "goldorange-3"
    case goldorange4 = "goldorange-4"
    case goldorange5 = "goldorange-5"
    case goldorange6 = "goldorange-6"
    case goldorange7 = "goldorange-7"
    case goldorange8 = "goldorange-8"
    case goldorange9 = "goldorange-9"
    case goldred
    case goldred3 = "goldred-3"
    case goldred4 = "goldred-4"
    case goldred5 = "goldred-5"
    case goldred6 = "goldred-6"
    case goldred7 = "goldred-7"
    case goldred8 = "goldred-8"
    case goldred9 = "goldred-9"
    case greenblue
    case greenblue3 = "greenblue-3"
    case greenblue4 = "greenblue-4"
    case greenblue5 = "greenblue-5"
    case greenblue6 = "greenblue-6"
    case greenblue7 = "greenblue-7"
    case greenblue8 = "greenblue-8"
    case greenblue9 = "greenblue-9"
    case orangered
    case orangered3 = "orangered-3"
    case orangered4 = "orangered-4"
    case orangered5 = "orangered-5"
    case orangered6 = "orangered-6"
    case orangered7 = "orangered-7"
    case orangered8 = "orangered-8"
    case orangered9 = "orangered-9"
    case purplebluegreen
    case purplebluegreen3 = "purplebluegreen-3"
    case purplebluegreen4 = "purplebluegreen-4"
    case purplebluegreen5 = "purplebluegreen-5"
    case purplebluegreen6 = "purplebluegreen-6"
    case purplebluegreen7 = "purplebluegreen-7"
    case purplebluegreen8 = "purplebluegreen-8"
    case purplebluegreen9 = "purplebluegreen-9"
    case purpleblue
    case purpleblue3 = "purpleblue-3"
    case purpleblue4 = "purpleblue-4"
    case purpleblue5 = "purpleblue-5"
    case purpleblue6 = "purpleblue-6"
    case purpleblue7 = "purpleblue-7"
    case purpleblue8 = "purpleblue-8"
    case purpleblue9 = "purpleblue-9"
    case purplered
    case purplered3 = "purplered-3"
    case purplered4 = "purplered-4"
    case purplered5 = "purplered-5"
    case purplered6 = "purplered-6"
    case purplered7 = "purplered-7"
    case purplered8 = "purplered-8"
    case purplered9 = "purplered-9"
    case redpurple
    case redpurple3 = "redpurple-3"
    case redpurple4 = "redpurple-4"
    case redpurple5 = "redpurple-5"
    case redpurple6 = "redpurple-6"
    case redpurple7 = "redpurple-7"
    case redpurple8 = "redpurple-8"
    case redpurple9 = "redpurple-9"
    case yellowgreenblue
    case yellowgreenblue3 = "yellowgreenblue-3"
    case yellowgreenblue4 = "yellowgreenblue-4"
    case yellowgreenblue5 = "yellowgreenblue-5"
    case yellowgreenblue6 = "yellowgreenblue-6"
    case yellowgreenblue7 = "yellowgreenblue-7"
    case yellowgreenblue8 = "yellowgreenblue-8"
    case yellowgreenblue9 = "yellowgreenblue-9"
    case yellowgreen
    case yellowgreen3 = "yellowgreen-3"
    case yellowgreen4 = "yellowgreen-4"
    case yellowgreen5 = "yellowgreen-5"
    case yellowgreen6 = "yellowgreen-6"
    case yellowgreen7 = "yellowgreen-7"
    case yellowgreen8 = "yellowgreen-8"
    case yellowgreen9 = "yellowgreen-9"
    case yelloworangebrown
    case yelloworangebrown3 = "yelloworangebrown-3"
    case yelloworangebrown4 = "yelloworangebrown-4"
    case yelloworangebrown5 = "yelloworangebrown-5"
    case yelloworangebrown6 = "yelloworangebrown-6"
    case yelloworangebrown7 = "yelloworangebrown-7"
    case yelloworangebrown8 = "yelloworangebrown-8"
    case yelloworangebrown9 = "yelloworangebrown-9"
    case yelloworangered
    case yelloworangered3 = "yelloworangered-3"
    case yelloworangered4 = "yelloworangered-4"
    case yelloworangered5 = "yelloworangered-5"
    case yelloworangered6 = "yelloworangered-6"
    case yelloworangered7 = "yelloworangered-7"
    case yelloworangered8 = "yelloworangered-8"
    case yelloworangered9 = "yelloworangered-9"
    case darkblue
    case darkblue3 = "darkblue-3"
    case darkblue4 = "darkblue-4"
    case darkblue5 = "darkblue-5"
    case darkblue6 = "darkblue-6"
    case darkblue7 = "darkblue-7"
    case darkblue8 = "darkblue-8"
    case darkblue9 = "darkblue-9"
    case darkgold
    case darkgold3 = "darkgold-3"
    case darkgold4 = "darkgold-4"
    case darkgold5 = "darkgold-5"
    case darkgold6 = "darkgold-6"
    case darkgold7 = "darkgold-7"
    case darkgold8 = "darkgold-8"
    case darkgold9 = "darkgold-9"
    case darkgreen
    case darkgreen3 = "darkgreen-3"
    case darkgreen4 = "darkgreen-4"
    case darkgreen5 = "darkgreen-5"
    case darkgreen6 = "darkgreen-6"
    case darkgreen7 = "darkgreen-7"
    case darkgreen8 = "darkgreen-8"
    case darkgreen9 = "darkgreen-9"
    case darkmulti
    case darkmulti3 = "darkmulti-3"
    case darkmulti4 = "darkmulti-4"
    case darkmulti5 = "darkmulti-5"
    case darkmulti6 = "darkmulti-6"
    case darkmulti7 = "darkmulti-7"
    case darkmulti8 = "darkmulti-8"
    case darkmulti9 = "darkmulti-9"
    case darkred
    case darkred3 = "darkred-3"
    case darkred4 = "darkred-4"
    case darkred5 = "darkred-5"
    case darkred6 = "darkred-6"
    case darkred7 = "darkred-7"
    case darkred8 = "darkred-8"
    case darkred9 = "darkred-9"
    case lightgreyred
    case lightgreyred3 = "lightgreyred-3"
    case lightgreyred4 = "lightgreyred-4"
    case lightgreyred5 = "lightgreyred-5"
    case lightgreyred6 = "lightgreyred-6"
    case lightgreyred7 = "lightgreyred-7"
    case lightgreyred8 = "lightgreyred-8"
    case lightgreyred9 = "lightgreyred-9"
    case lightgreyteal
    case lightgreyteal3 = "lightgreyteal-3"
    case lightgreyteal4 = "lightgreyteal-4"
    case lightgreyteal5 = "lightgreyteal-5"
    case lightgreyteal6 = "lightgreyteal-6"
    case lightgreyteal7 = "lightgreyteal-7"
    case lightgreyteal8 = "lightgreyteal-8"
    case lightgreyteal9 = "lightgreyteal-9"
    case lightmulti
    case lightmulti3 = "lightmulti-3"
    case lightmulti4 = "lightmulti-4"
    case lightmulti5 = "lightmulti-5"
    case lightmulti6 = "lightmulti-6"
    case lightmulti7 = "lightmulti-7"
    case lightmulti8 = "lightmulti-8"
    case lightmulti9 = "lightmulti-9"
    case lightorange
    case lightorange3 = "lightorange-3"
    case lightorange4 = "lightorange-4"
    case lightorange5 = "lightorange-5"
    case lightorange6 = "lightorange-6"
    case lightorange7 = "lightorange-7"
    case lightorange8 = "lightorange-8"
    case lightorange9 = "lightorange-9"
    case lighttealblue
    case lighttealblue3 = "lighttealblue-3"
    case lighttealblue4 = "lighttealblue-4"
    case lighttealblue5 = "lighttealblue-5"
    case lighttealblue6 = "lighttealblue-6"
    case lighttealblue7 = "lighttealblue-7"
    case lighttealblue8 = "lighttealblue-8"
    case lighttealblue9 = "lighttealblue-9"
}

/// Generated by Curio
public enum SequentialSingleHue : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case blues
    case tealblues
    case teals
    case greens
    case browns
    case greys
    case purples
    case warmgreys
    case reds
    case oranges
}

/// Generated by Curio
public enum SingleDefUnitChannel : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case x
    case y
    case x2
    case y2
    case longitude
    case latitude
    case longitude2
    case latitude2
    case theta
    case theta2
    case radius
    case radius2
    case color
    case fill
    case stroke
    case opacity
    case fillOpacity
    case strokeOpacity
    case strokeWidth
    case strokeDash
    case size
    case angle
    case shape
    case key
    case text
    case href
    case url
    case description
}

/// Generated by Curio
public enum SortByChannel : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case x
    case y
    case color
    case fill
    case stroke
    case strokeWidth
    case size
    case shape
    case fillOpacity
    case strokeOpacity
    case opacity
    case text
}

/// Generated by Curio
public enum SortByChannelDesc : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case x = "-x"
    case y = "-y"
    case color = "-color"
    case fill = "-fill"
    case stroke = "-stroke"
    case strokeWidth = "-strokeWidth"
    case size = "-size"
    case shape = "-shape"
    case fillOpacity = "-fillOpacity"
    case strokeOpacity = "-strokeOpacity"
    case opacity = "-opacity"
    case text = "-text"
}

/// Generated by Curio
public enum SortOrder : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case ascending
    case descending
}

/// Generated by Curio
public enum StackOffset : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case zero
    case center
    case normalize
}

/// Generated by Curio
public enum StandardMeasureType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case quantitative
    case ordinal
    case temporal
    case nominal
}

/// Generated by Curio
public enum StrokeCap : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case butt
    case round
    case square
}

/// Generated by Curio
public enum StrokeJoin : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case miter
    case round
    case bevel
}

/// Generated by Curio
public enum TemporalUnit : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case millisecond
    case second
    case minute
    case hour
    case day
    case week
    case month
    case year
}

/// Generated by Curio
public enum TextDirection : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case ltr
    case rtl
}

/// Generated by Curio
public enum TitleAnchor : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case start
    case middle
    case end
}

/// Generated by Curio
public enum TitleFrame : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case bounds
    case group
}

/// Generated by Curio
public enum TitleOrient : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case none
    case left
    case right
    case top
    case bottom
}

/// Generated by Curio
public enum TypeForShape : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case nominal
    case ordinal
    case geojson
}

/// Generated by Curio
public enum UtcMultiTimeUnit : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case utcyearquarter
    case utcyearquartermonth
    case utcyearmonth
    case utcyearmonthdate
    case utcyearmonthdatehours
    case utcyearmonthdatehoursminutes
    case utcyearmonthdatehoursminutesseconds
    case utcyearweek
    case utcyearweekday
    case utcyearweekdayhours
    case utcyearweekdayhoursminutes
    case utcyearweekdayhoursminutesseconds
    case utcyeardayofyear
    case utcquartermonth
    case utcmonthdate
    case utcmonthdatehours
    case utcmonthdatehoursminutes
    case utcmonthdatehoursminutesseconds
    case utcweekday
    case utcweeksdayhours
    case utcweekdayhoursminutes
    case utcweekdayhoursminutesseconds
    case utcdayhours
    case utcdayhoursminutes
    case utcdayhoursminutesseconds
    case utchoursminutes
    case utchoursminutesseconds
    case utcminutesseconds
    case utcsecondsmilliseconds
}

/// Generated by Curio
public enum UtcSingleTimeUnit : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case utcyear
    case utcquarter
    case utcmonth
    case utcweek
    case utcday
    case utcdayofyear
    case utcdate
    case utchours
    case utcminutes
    case utcseconds
    case utcmilliseconds
}

/// Generated by Curio
public enum VgMarkType : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case arc
    case area
    case image
    case group
    case line
    case path
    case rect
    case rule
    case shape
    case symbol
    case text
    case trail
}

/// Generated by Curio
public enum WindowOnlyOp : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
    case row_number
    case rank
    case dense_rank
    case percent_rank
    case cume_dist
    case ntile
    case lag
    case lead
    case first_value
    case last_value
    case nth_value
}

public struct Aggregate : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<NonArgAggregateOp>.Or<ArgmaxDef>.Or<ArgminDef>

    public init(rawValue: OneOf<NonArgAggregateOp>.Or<ArgmaxDef>.Or<ArgminDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<NonArgAggregateOp>.Or<ArgmaxDef>.Or<ArgminDef>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct AggregateTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// Array of objects that define fields to aggregate.
    public var aggregate: [AggregatedFieldDef]
    /// The data fields to group by. If not specified, a single group containing all data objects will be used.
    public var groupby: [FieldName]?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.aggregate as KeyPath, \Self.groupby as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.groupby as KeyPath : CodingKeys.groupby]

    public init(id: TransformId? = nil, aggregate: [AggregatedFieldDef] = [], groupby: [FieldName]? = nil) {
        self.id = id 
        self.aggregate = aggregate 
        self.groupby = groupby 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.aggregate = try values.decode([AggregatedFieldDef].self, forKey: .aggregate) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case aggregate
        case groupby
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .aggregate: return "Array of objects that define fields to aggregate."
            case .groupby: return "The data fields to group by. If not specified, a single group containing all data objects will be used."
             } 
        }

        public typealias CodingOwner = AggregateTransform
    }
}

/// Generated by Curio
public struct AggregatedFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The output field names to use for each aggregated field.
    public var `as`: FieldName
    /// The data field for which to compute aggregate function. This is required for all aggregation operations except `"count"`.
    public var field: FieldName?
    /// The aggregation operation to apply to the fields (e.g., `"sum"`, `"average"`, or `"count"`). See the [full list of supported aggregation operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops) for more information.
    public var op: AggregateOp
    public static let codingKeyPaths = (\Self.`as` as KeyPath, \Self.field as KeyPath, \Self.op as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.`as` as KeyPath : CodingKeys.`as`, \Self.field as KeyPath : CodingKeys.field, \Self.op as KeyPath : CodingKeys.op]

    public init(`as`: FieldName, field: FieldName? = nil, op: AggregateOp) {
        self.`as` = `as` 
        self.field = field 
        self.op = op 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.`as` = try values.decode(FieldName.self, forKey: .`as`) 
        self.field = try values.decodeOptional(FieldName.self, forKey: .field) 
        self.op = try values.decode(AggregateOp.self, forKey: .op) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case `as`
        case field
        case op
        public var keyDescription: String? {
            switch self {
            case .`as`: return "The output field names to use for each aggregated field."
            case .field: return "The data field for which to compute aggregate function. This is required for all aggregation operations except `\"count\"`."
            case .op: return "The aggregation operation to apply to the fields (e.g., `\"sum\"`, `\"average\"`, or `\"count\"`). See the [full list of supported aggregation operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops) for more information."
             } 
        }

        public typealias CodingOwner = AggregatedFieldDef
    }
}

public struct AllSortString : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<SortOrder>.Or<SortByChannel>.Or<SortByChannelDesc>

    public init(rawValue: OneOf<SortOrder>.Or<SortByChannel>.Or<SortByChannelDesc>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<SortOrder>.Or<SortByChannel>.Or<SortByChannelDesc>) {
        self.rawValue = rawValue 
    }
}

public struct AnyMark : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<CompositeMark>.Or<CompositeMarkDef>.Or<PrimitiveMarkType>.Or<MarkDef>

    public init(rawValue: OneOf<CompositeMark>.Or<CompositeMarkDef>.Or<PrimitiveMarkType>.Or<MarkDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<CompositeMark>.Or<CompositeMarkDef>.Or<PrimitiveMarkType>.Or<MarkDef>) {
        self.rawValue = rawValue 
    }
}

public struct AnyMarkConfig : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<MarkConfig>.Or<AreaConfig>.Or<BarConfig>.Or<RectConfig>.Or<LineConfig>.Or<TickConfig>

    public init(rawValue: OneOf<MarkConfig>.Or<AreaConfig>.Or<BarConfig>.Or<RectConfig>.Or<LineConfig>.Or<TickConfig>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<MarkConfig>.Or<AreaConfig>.Or<BarConfig>.Or<RectConfig>.Or<LineConfig>.Or<TickConfig>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct AreaConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var align: AlignChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    public var ariaRole: AriaRoleChoice?
    public var ariaRoleDescription: AriaRoleDescriptionChoice?
    public var aspect: AspectChoice?
    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var baseline: BaselineChoice?
    public var blend: BlendChoice?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    public var cornerRadius: CornerRadiusChoice?
    public var cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice?
    public var cornerRadiusBottomRight: CornerRadiusBottomRightChoice?
    public var cornerRadiusTopLeft: CornerRadiusTopLeftChoice?
    public var cornerRadiusTopRight: CornerRadiusTopRightChoice?
    public var cursor: CursorChoice?
    public var description: DescriptionChoice?
    public var dir: DirChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var ellipsis: EllipsisChoice?
    public var endAngle: EndAngleChoice?
    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// Whether the mark's color should be used as fill color instead of stroke color.
    /// __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.
    /// __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    public var filled: Bool?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var height: HeightChoice?
    public var href: HrefChoice?
    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    public var innerRadius: InnerRadiusChoice?
    public var interpolate: InterpolateChoice?
    /// Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
    /// - If set to `"filter"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).
    /// - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
    public var invalid: Invalid?
    public var limit: LimitChoice?
    /// A flag for overlaying line on top of area marks, or an object defining the properties of the overlayed lines.
    /// - If this value is an empty object (`{}`) or `true`, lines with default properties will be used.
    /// - If this value is `false`, no lines would be automatically added to area marks.
    /// __Default value:__ `false`.
    public var line: LineChoice?
    public var lineBreak: LineBreakChoice?
    public var lineHeight: LineHeightChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources.
    public var order: Order?
    /// The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored.
    public var orient: Orientation?
    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    public var outerRadius: OuterRadiusChoice?
    public var padAngle: PadAngleChoice?
    /// A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.
    /// - If this property is `"transparent"`, transparent points will be used (for enhancing tooltips and selections).
    /// - If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.
    /// - If this property is `false`, no points would be automatically added to line or area marks.
    /// __Default value:__ `false`.
    public var point: PointChoice?
    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    public var radius: RadiusChoice?
    /// The secondary (inner) radius in pixels of arc marks.
    public var radius2: Radius2Choice?
    public var shape: SymbolShape?
    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    public var size: SizeChoice?
    public var smooth: SmoothChoice?
    public var startAngle: StartAngleChoice?
    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOffset: StrokeOffsetChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    public var tension: TensionChoice?
    public var text: TextChoice?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaChoice?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Choice?
    /// Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step.
    public var timeUnitBandPosition: Double?
    /// Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step.
    public var timeUnitBandSize: Double?
    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    public var tooltip: TooltipChoice?
    public var url: UrlChoice?
    public var width: WidthChoice?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XChoice?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Choice?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YChoice?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Choice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.aspect as KeyPath, \Self.baseline as KeyPath, \Self.blend as KeyPath, \Self.color as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cursor as KeyPath, \Self.description as KeyPath, \Self.dir as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.ellipsis as KeyPath, \Self.endAngle as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.filled as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.height as KeyPath, \Self.href as KeyPath, \Self.innerRadius as KeyPath, \Self.interpolate as KeyPath, \Self.invalid as KeyPath, \Self.limit as KeyPath, \Self.line as KeyPath, \Self.lineBreak as KeyPath, \Self.lineHeight as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.orient as KeyPath, \Self.outerRadius as KeyPath, \Self.padAngle as KeyPath, \Self.point as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.smooth as KeyPath, \Self.startAngle as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.tension as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.timeUnitBandPosition as KeyPath, \Self.timeUnitBandSize as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.width as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.blend as KeyPath : CodingKeys.blend, \Self.color as KeyPath : CodingKeys.color, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.description as KeyPath : CodingKeys.description, \Self.dir as KeyPath : CodingKeys.dir, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.endAngle as KeyPath : CodingKeys.endAngle, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.filled as KeyPath : CodingKeys.filled, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.height as KeyPath : CodingKeys.height, \Self.href as KeyPath : CodingKeys.href, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.invalid as KeyPath : CodingKeys.invalid, \Self.limit as KeyPath : CodingKeys.limit, \Self.line as KeyPath : CodingKeys.line, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.orient as KeyPath : CodingKeys.orient, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.point as KeyPath : CodingKeys.point, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.startAngle as KeyPath : CodingKeys.startAngle, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.tension as KeyPath : CodingKeys.tension, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.timeUnitBandPosition as KeyPath : CodingKeys.timeUnitBandPosition, \Self.timeUnitBandSize as KeyPath : CodingKeys.timeUnitBandSize, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.width as KeyPath : CodingKeys.width, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2]

    public init(align: AlignChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, ariaRole: AriaRoleChoice? = nil, ariaRoleDescription: AriaRoleDescriptionChoice? = nil, aspect: AspectChoice? = nil, baseline: BaselineChoice? = nil, blend: BlendChoice? = nil, color: ColorChoice? = nil, cornerRadius: CornerRadiusChoice? = nil, cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice? = nil, cornerRadiusBottomRight: CornerRadiusBottomRightChoice? = nil, cornerRadiusTopLeft: CornerRadiusTopLeftChoice? = nil, cornerRadiusTopRight: CornerRadiusTopRightChoice? = nil, cursor: CursorChoice? = nil, description: DescriptionChoice? = nil, dir: DirChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, ellipsis: EllipsisChoice? = nil, endAngle: EndAngleChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, filled: Bool? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, height: HeightChoice? = nil, href: HrefChoice? = nil, innerRadius: InnerRadiusChoice? = nil, interpolate: InterpolateChoice? = nil, invalid: Invalid? = nil, limit: LimitChoice? = nil, line: LineChoice? = nil, lineBreak: LineBreakChoice? = nil, lineHeight: LineHeightChoice? = nil, opacity: OpacityChoice? = nil, order: Order? = nil, orient: Orientation? = nil, outerRadius: OuterRadiusChoice? = nil, padAngle: PadAngleChoice? = nil, point: PointChoice? = nil, radius: RadiusChoice? = nil, radius2: Radius2Choice? = nil, shape: SymbolShape? = nil, size: SizeChoice? = nil, smooth: SmoothChoice? = nil, startAngle: StartAngleChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOffset: StrokeOffsetChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, tension: TensionChoice? = nil, text: TextChoice? = nil, theta: ThetaChoice? = nil, theta2: Theta2Choice? = nil, timeUnitBandPosition: Double? = nil, timeUnitBandSize: Double? = nil, tooltip: TooltipChoice? = nil, url: UrlChoice? = nil, width: WidthChoice? = nil, x: XChoice? = nil, x2: X2Choice? = nil, y: YChoice? = nil, y2: Y2Choice? = nil) {
        self.align = align 
        self.angle = angle 
        self.aria = aria 
        self.ariaRole = ariaRole 
        self.ariaRoleDescription = ariaRoleDescription 
        self.aspect = aspect 
        self.baseline = baseline 
        self.blend = blend 
        self.color = color 
        self.cornerRadius = cornerRadius 
        self.cornerRadiusBottomLeft = cornerRadiusBottomLeft 
        self.cornerRadiusBottomRight = cornerRadiusBottomRight 
        self.cornerRadiusTopLeft = cornerRadiusTopLeft 
        self.cornerRadiusTopRight = cornerRadiusTopRight 
        self.cursor = cursor 
        self.description = description 
        self.dir = dir 
        self.dx = dx 
        self.dy = dy 
        self.ellipsis = ellipsis 
        self.endAngle = endAngle 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.filled = filled 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.height = height 
        self.href = href 
        self.innerRadius = innerRadius 
        self.interpolate = interpolate 
        self.invalid = invalid 
        self.limit = limit 
        self.line = line 
        self.lineBreak = lineBreak 
        self.lineHeight = lineHeight 
        self.opacity = opacity 
        self.order = order 
        self.orient = orient 
        self.outerRadius = outerRadius 
        self.padAngle = padAngle 
        self.point = point 
        self.radius = radius 
        self.radius2 = radius2 
        self.shape = shape 
        self.size = size 
        self.smooth = smooth 
        self.startAngle = startAngle 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOffset = strokeOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.tension = tension 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.timeUnitBandPosition = timeUnitBandPosition 
        self.timeUnitBandSize = timeUnitBandSize 
        self.tooltip = tooltip 
        self.url = url 
        self.width = width 
        self.x = x 
        self.x2 = x2 
        self.y = y 
        self.y2 = y2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.ariaRole = try values.decodeOptional(AriaRoleChoice.self, forKey: .ariaRole) 
        self.ariaRoleDescription = try values.decodeOptional(AriaRoleDescriptionChoice.self, forKey: .ariaRoleDescription) 
        self.aspect = try values.decodeOptional(AspectChoice.self, forKey: .aspect) 
        self.baseline = try values.decodeOptional(BaselineChoice.self, forKey: .baseline) 
        self.blend = try values.decodeOptional(BlendChoice.self, forKey: .blend) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cornerRadiusBottomLeft = try values.decodeOptional(CornerRadiusBottomLeftChoice.self, forKey: .cornerRadiusBottomLeft) 
        self.cornerRadiusBottomRight = try values.decodeOptional(CornerRadiusBottomRightChoice.self, forKey: .cornerRadiusBottomRight) 
        self.cornerRadiusTopLeft = try values.decodeOptional(CornerRadiusTopLeftChoice.self, forKey: .cornerRadiusTopLeft) 
        self.cornerRadiusTopRight = try values.decodeOptional(CornerRadiusTopRightChoice.self, forKey: .cornerRadiusTopRight) 
        self.cursor = try values.decodeOptional(CursorChoice.self, forKey: .cursor) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.dir = try values.decodeOptional(DirChoice.self, forKey: .dir) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.ellipsis = try values.decodeOptional(EllipsisChoice.self, forKey: .ellipsis) 
        self.endAngle = try values.decodeOptional(EndAngleChoice.self, forKey: .endAngle) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.filled = try values.decodeOptional(Bool.self, forKey: .filled) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.href = try values.decodeOptional(HrefChoice.self, forKey: .href) 
        self.innerRadius = try values.decodeOptional(InnerRadiusChoice.self, forKey: .innerRadius) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.invalid = try values.decodeOptional(Invalid.self, forKey: .invalid) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.line = try values.decodeOptional(LineChoice.self, forKey: .line) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.order = try values.decodeOptional(Order.self, forKey: .order) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outerRadius = try values.decodeOptional(OuterRadiusChoice.self, forKey: .outerRadius) 
        self.padAngle = try values.decodeOptional(PadAngleChoice.self, forKey: .padAngle) 
        self.point = try values.decodeOptional(PointChoice.self, forKey: .point) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Choice.self, forKey: .radius2) 
        self.shape = try values.decodeOptional(SymbolShape.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.smooth = try values.decodeOptional(SmoothChoice.self, forKey: .smooth) 
        self.startAngle = try values.decodeOptional(StartAngleChoice.self, forKey: .startAngle) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOffset = try values.decodeOptional(StrokeOffsetChoice.self, forKey: .strokeOffset) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.tension = try values.decodeOptional(TensionChoice.self, forKey: .tension) 
        self.text = try values.decodeOptional(TextChoice.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaChoice.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Choice.self, forKey: .theta2) 
        self.timeUnitBandPosition = try values.decodeOptional(Double.self, forKey: .timeUnitBandPosition) 
        self.timeUnitBandSize = try values.decodeOptional(Double.self, forKey: .timeUnitBandSize) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlChoice.self, forKey: .url) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
        self.x = try values.decodeOptional(XChoice.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Choice.self, forKey: .x2) 
        self.y = try values.decodeOptional(YChoice.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Choice.self, forKey: .y2) 
    }

    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleDescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AspectChoice = OneOf<Bool>.Or<ExprRef>

    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias BaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias BlendChoice = OneOf<Blend>.Or<ExprRef>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CursorChoice = OneOf<Cursor>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DirChoice = OneOf<TextDirection>.Or<ExprRef>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias EllipsisChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias EndAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias HrefChoice = OneOf<URI>.Or<ExprRef>

    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    /// Generated by Curio
    public typealias InnerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<Interpolate>.Or<ExprRef>

    /// Generated by Curio
    public typealias Invalid = Nullable<String>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// A flag for overlaying line on top of area marks, or an object defining the properties of the overlayed lines.
    /// - If this value is an empty object (`{}`) or `true`, lines with default properties will be used.
    /// - If this value is `false`, no lines would be automatically added to area marks.
    /// __Default value:__ `false`.
    /// Generated by Curio
    public typealias LineChoice = OneOf<Bool>.Or<OverlayMarkDef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias Order = Nullable<Bool>

    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    /// Generated by Curio
    public typealias OuterRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PadAngleChoice = OneOf<Double>.Or<ExprRef>

    /// A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.
    /// - If this property is `"transparent"`, transparent points will be used (for enhancing tooltips and selections).
    /// - If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.
    /// - If this property is `false`, no points would be automatically added to line or area marks.
    /// __Default value:__ `false`.
    /// Generated by Curio
    public typealias PointChoice = OneOf<Bool>.Or<OverlayMarkDef>.Or<LiteralTransparent>

    /// The secondary (inner) radius in pixels of arc marks.
    /// Generated by Curio
    public typealias Radius2Choice = OneOf<Double>.Or<ExprRef>

    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    /// Generated by Curio
    public typealias SizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SmoothChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias StartAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TensionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    /// Generated by Curio
    public typealias Theta2Choice = OneOf<Double>.Or<ExprRef>

    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    /// Generated by Curio
    public typealias ThetaChoice = OneOf<Double>.Or<ExprRef>

    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<Double>.Or<String>.Or<Bool>.Or<TooltipContent>.Or<ExprRef>>

    /// Generated by Curio
    public typealias UrlChoice = OneOf<URI>.Or<ExprRef>

    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<ExprRef>

    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias X2Choice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias XChoice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias Y2Choice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias YChoice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case angle
        case aria
        case ariaRole
        case ariaRoleDescription
        case aspect
        case baseline
        case blend
        case color
        case cornerRadius
        case cornerRadiusBottomLeft
        case cornerRadiusBottomRight
        case cornerRadiusTopLeft
        case cornerRadiusTopRight
        case cursor
        case description
        case dir
        case dx
        case dy
        case ellipsis
        case endAngle
        case fill
        case fillOpacity
        case filled
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case height
        case href
        case innerRadius
        case interpolate
        case invalid
        case limit
        case line
        case lineBreak
        case lineHeight
        case opacity
        case order
        case orient
        case outerRadius
        case padAngle
        case point
        case radius
        case radius2
        case shape
        case size
        case smooth
        case startAngle
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOffset
        case strokeOpacity
        case strokeWidth
        case tension
        case text
        case theta
        case theta2
        case timeUnitBandPosition
        case timeUnitBandSize
        case tooltip
        case url
        case width
        case x
        case x2
        case y
        case y2
        public var keyDescription: String? {
            switch self {
            case .align: return "The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `\"left\"`, `\"right\"`, `\"center\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .angle: return nil
            case .aria: return nil
            case .ariaRole: return nil
            case .ariaRoleDescription: return nil
            case .aspect: return nil
            case .baseline: return "For text marks, the vertical text baseline. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, `\"line-bottom\"`, or an expression reference that provides one of the valid values. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.\n\nFor range marks, the vertical alignment of the marks. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .blend: return nil
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .cornerRadius: return nil
            case .cornerRadiusBottomLeft: return nil
            case .cornerRadiusBottomRight: return nil
            case .cornerRadiusTopLeft: return nil
            case .cornerRadiusTopRight: return nil
            case .cursor: return nil
            case .description: return nil
            case .dir: return nil
            case .dx: return nil
            case .dy: return nil
            case .ellipsis: return nil
            case .endAngle: return nil
            case .fill: return "Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.\n\n__Default value:__ (None)"
            case .fillOpacity: return nil
            case .filled: return "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.\n\n__Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config)."
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .height: return nil
            case .href: return nil
            case .innerRadius: return "The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`."
            case .interpolate: return nil
            case .invalid: return "Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes."
            case .limit: return nil
            case .line: return "A flag for overlaying line on top of area marks, or an object defining the properties of the overlayed lines.\n\n- If this value is an empty object (`{}`) or `true`, lines with default properties will be used.\n\n- If this value is `false`, no lines would be automatically added to area marks.\n\n__Default value:__ `false`."
            case .lineBreak: return nil
            case .lineHeight: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .order: return "For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources."
            case .orient: return "The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored."
            case .outerRadius: return "The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`."
            case .padAngle: return nil
            case .point: return "A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.\n\n- If this property is `\"transparent\"`, transparent points will be used (for enhancing tooltips and selections).\n\n- If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.\n\n- If this property is `false`, no points would be automatically added to line or area marks.\n\n__Default value:__ `false`."
            case .radius: return "For arc mark, the primary (outer) radius in pixels.\n\nFor text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties."
            case .radius2: return "The secondary (inner) radius in pixels of arc marks."
            case .shape: return nil
            case .size: return "Default size for marks.\n- For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.\n- For `bar`, this represents the band size of the bar, in pixels.\n- For `text`, this represents the font size, in pixels.\n\n__Default value:__\n- `30` for point, circle, square marks; width/height's `step`\n- `2` for bar marks with discrete dimensions;\n- `5` for bar marks with continuous dimensions;\n- `11` for text marks."
            case .smooth: return nil
            case .startAngle: return nil
            case .stroke: return "Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.\n\n__Default value:__ (None)"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOffset: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .tension: return nil
            case .text: return nil
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .timeUnitBandPosition: return "Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step."
            case .timeUnitBandSize: return "Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step."
            case .tooltip: return "The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n\n- If `tooltip` is `true` or `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n- If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n- If set to `null` or `false`, then no tooltip will be used.\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.\n\n__Default value:__ `null`"
            case .url: return nil
            case .width: return nil
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
             } 
        }

        public typealias CodingOwner = AreaConfig
    }
}

/// Generated by Curio
public struct ArgmaxDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var argmax: FieldName
    public static let codingKeyPaths = (\Self.argmax as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.argmax as KeyPath : CodingKeys.argmax]

    public init(argmax: FieldName) {
        self.argmax = argmax 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.argmax = try values.decode(FieldName.self, forKey: .argmax) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case argmax
        public var keyDescription: String? {
            switch self {
            case .argmax: return nil
             } 
        }

        public typealias CodingOwner = ArgmaxDef
    }
}

/// Generated by Curio
public struct ArgminDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var argmin: FieldName
    public static let codingKeyPaths = (\Self.argmin as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.argmin as KeyPath : CodingKeys.argmin]

    public init(argmin: FieldName) {
        self.argmin = argmin 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.argmin = try values.decode(FieldName.self, forKey: .argmin) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case argmin
        public var keyDescription: String? {
            switch self {
            case .argmin: return nil
             } 
        }

        public typealias CodingOwner = ArgminDef
    }
}

/// Generated by Curio
public struct AutoSizeParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Determines how size calculation should be performed, one of `"content"` or `"padding"`. The default setting (`"content"`) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the `"padding"` setting includes the padding within the view size calculations, such that the width and height settings indicate the **total** intended size of the view.
    /// __Default value__: `"content"`
    public var contains: LiteralContentOrPadding?
    /// A boolean flag indicating if autosize layout should be re-calculated on every view update.
    /// __Default value__: `false`
    public var resize: Bool?
    /// The sizing format type. One of `"pad"`, `"fit"`, `"fit-x"`, `"fit-y"`,  or `"none"`. See the [autosize type](https://vega.github.io/vega-lite/docs/size.html#autosize) documentation for descriptions of each.
    /// __Default value__: `"pad"`
    public var type: AutosizeType?
    public static let codingKeyPaths = (\Self.contains as KeyPath, \Self.resize as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.contains as KeyPath : CodingKeys.contains, \Self.resize as KeyPath : CodingKeys.resize, \Self.type as KeyPath : CodingKeys.type]

    public init(contains: LiteralContentOrPadding? = nil, resize: Bool? = nil, type: AutosizeType? = nil) {
        self.contains = contains 
        self.resize = resize 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.contains = try values.decodeOptional(LiteralContentOrPadding.self, forKey: .contains) 
        self.resize = try values.decodeOptional(Bool.self, forKey: .resize) 
        self.type = try values.decodeOptional(AutosizeType.self, forKey: .type) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case contains
        case resize
        case type
        public var keyDescription: String? {
            switch self {
            case .contains: return "Determines how size calculation should be performed, one of `\"content\"` or `\"padding\"`. The default setting (`\"content\"`) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the `\"padding\"` setting includes the padding within the view size calculations, such that the width and height settings indicate the **total** intended size of the view.\n\n__Default value__: `\"content\"`"
            case .resize: return "A boolean flag indicating if autosize layout should be re-calculated on every view update.\n\n__Default value__: `false`"
            case .type: return "The sizing format type. One of `\"pad\"`, `\"fit\"`, `\"fit-x\"`, `\"fit-y\"`,  or `\"none\"`. See the [autosize type](https://vega.github.io/vega-lite/docs/size.html#autosize) documentation for descriptions of each.\n\n__Default value__: `\"pad\"`"
             } 
        }

        public typealias CodingOwner = AutoSizeParams
    }

    /// Determines how size calculation should be performed, one of `"content"` or `"padding"`. The default setting (`"content"`) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the `"padding"` setting includes the padding within the view size calculations, such that the width and height settings indicate the **total** intended size of the view.
    /// __Default value__: `"content"`
    /// Generated by Curio
    public enum LiteralContentOrPadding : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case content
        case padding
    }
}

/// Generated by Curio
public struct AxisConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var aria: AriaChoice?
    public var bandPosition: BandPositionChoice?
    public var description: DescriptionChoice?
    /// Disable axis by default.
    public var disable: Bool?
    /// A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.
    /// __Default value:__ `true`
    public var domain: Bool?
    public var domainCap: DomainCapChoice?
    public var domainColor: DomainColorChoice?
    public var domainDash: DomainDashChoice?
    public var domainDashOffset: DomainDashOffsetChoice?
    public var domainOpacity: DomainOpacityChoice?
    public var domainWidth: DomainWidthChoice?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// A boolean flag indicating if grid lines should be included as part of the axis
    /// __Default value:__ `true` for [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned; otherwise, `false`.
    public var grid: Bool?
    public var gridCap: GridCapChoice?
    public var gridColor: GridColorChoice?
    public var gridDash: GridDashChoice?
    public var gridDashOffset: GridDashOffsetChoice?
    public var gridOpacity: GridOpacityChoice?
    public var gridWidth: GridWidthChoice?
    public var labelAlign: LabelAlignChoice?
    public var labelAngle: LabelAngleChoice?
    public var labelBaseline: LabelBaselineChoice?
    public var labelBound: LabelBoundChoice?
    public var labelColor: LabelColorChoice?
    /// [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
    /// __Note:__ The label text and value can be assessed via the `label` and `value` properties of the axis's backing `datum` object.
    public var labelExpr: Expr?
    /// Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.
    /// __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
    public var labelFlush: LabelFlush?
    public var labelFlushOffset: LabelFlushOffsetChoice?
    public var labelFont: FontName?
    public var labelFontSize: LabelFontSizeChoice?
    public var labelFontStyle: LabelFontStyleChoice?
    public var labelFontWeight: LabelFontWeightChoice?
    public var labelLimit: LabelLimitChoice?
    public var labelLineHeight: LabelLineHeightChoice?
    public var labelOffset: LabelOffsetChoice?
    public var labelOpacity: LabelOpacityChoice?
    /// The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
    /// __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log scales; otherwise `false`.
    public var labelOverlap: LabelOverlapChoice?
    public var labelPadding: LabelPaddingChoice?
    public var labelSeparation: LabelSeparationChoice?
    /// A boolean flag indicating if labels should be included as part of the axis.
    /// __Default value:__ `true`.
    public var labels: Bool?
    public var maxExtent: MaxExtentChoice?
    public var minExtent: MinExtentChoice?
    /// The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.
    /// __Default value:__ derived from the [axis config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset` (`0` by default)
    public var offset: OffsetChoice?
    /// The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The orientation can be used to further specialize the axis type (e.g., a y-axis oriented towards the right edge of the chart).
    /// __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
    public var orient: OrientChoice?
    /// The anchor position of the axis in pixels. For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.
    /// __Default value__: `0`
    public var position: PositionChoice?
    /// A string or array of strings indicating the name of custom styles to apply to the axis. A style is a named collection of axis property defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.
    /// __Default value:__ (none) __Note:__ Any specified style will augment the default style. For example, an x-axis mark with `"style": "foo"` will use `config.axisX` and `config.style.foo` (the specified style `"foo"` has higher precedence).
    public var style: StyleChoice?
    public var tickBand: TickBandChoice?
    public var tickCap: TickCapChoice?
    public var tickColor: TickColorChoice?
    /// A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the underlying scale's range.
    /// For scales of type `"time"` or `"utc"`, the tick count can instead be a time interval specifier. Legal string values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, an object-valued interval specifier of the form `{"interval": "month", "step": 3}` includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.
    /// __Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)` for y.
    public var tickCount: TickCountChoice?
    public var tickDash: TickDashChoice?
    public var tickDashOffset: TickDashOffsetChoice?
    /// Boolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for `band` scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with `"bandPosition": 1` and an axis `"padding"` value of `0`.
    public var tickExtra: Bool?
    /// The minimum desired step between axis ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value.
    public var tickMinStep: TickMinStepChoice?
    public var tickOffset: TickOffsetChoice?
    public var tickOpacity: TickOpacityChoice?
    /// Boolean flag indicating if pixel position values should be rounded to the nearest integer.
    /// __Default value:__ `true`
    public var tickRound: Bool?
    public var tickSize: TickSizeChoice?
    public var tickWidth: TickWidthChoice?
    /// Boolean value that determines whether the axis should include ticks.
    /// __Default value:__ `true`
    public var ticks: Bool?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    public var titleAlign: TitleAlignChoice?
    public var titleAnchor: TitleAnchorChoice?
    public var titleAngle: TitleAngleChoice?
    public var titleBaseline: TitleBaselineChoice?
    public var titleColor: TitleColorChoice?
    public var titleFont: FontName?
    public var titleFontSize: TitleFontSizeChoice?
    public var titleFontStyle: TitleFontStyleChoice?
    public var titleFontWeight: TitleFontWeightChoice?
    public var titleLimit: TitleLimitChoice?
    public var titleLineHeight: TitleLineHeightChoice?
    public var titleOpacity: TitleOpacityChoice?
    public var titlePadding: TitlePaddingChoice?
    public var titleX: TitleXChoice?
    public var titleY: TitleYChoice?
    public var translate: TranslateChoice?
    /// Explicitly set the visible axis tick values.
    public var values: ValuesChoice?
    /// A non-negative integer indicating the z-index of the axis. If zindex is 0, axes should be drawn behind all chart elements. To put them in front, set `zindex` to `1` or more.
    /// __Default value:__ `0` (behind the marks).
    public var zindex: Double?
    public static let codingKeyPaths = (\Self.aria as KeyPath, \Self.bandPosition as KeyPath, \Self.description as KeyPath, \Self.disable as KeyPath, \Self.domain as KeyPath, \Self.domainCap as KeyPath, \Self.domainColor as KeyPath, \Self.domainDash as KeyPath, \Self.domainDashOffset as KeyPath, \Self.domainOpacity as KeyPath, \Self.domainWidth as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.grid as KeyPath, \Self.gridCap as KeyPath, \Self.gridColor as KeyPath, \Self.gridDash as KeyPath, \Self.gridDashOffset as KeyPath, \Self.gridOpacity as KeyPath, \Self.gridWidth as KeyPath, \Self.labelAlign as KeyPath, \Self.labelAngle as KeyPath, \Self.labelBaseline as KeyPath, \Self.labelBound as KeyPath, \Self.labelColor as KeyPath, \Self.labelExpr as KeyPath, \Self.labelFlush as KeyPath, \Self.labelFlushOffset as KeyPath, \Self.labelFont as KeyPath, \Self.labelFontSize as KeyPath, \Self.labelFontStyle as KeyPath, \Self.labelFontWeight as KeyPath, \Self.labelLimit as KeyPath, \Self.labelLineHeight as KeyPath, \Self.labelOffset as KeyPath, \Self.labelOpacity as KeyPath, \Self.labelOverlap as KeyPath, \Self.labelPadding as KeyPath, \Self.labelSeparation as KeyPath, \Self.labels as KeyPath, \Self.maxExtent as KeyPath, \Self.minExtent as KeyPath, \Self.offset as KeyPath, \Self.orient as KeyPath, \Self.position as KeyPath, \Self.style as KeyPath, \Self.tickBand as KeyPath, \Self.tickCap as KeyPath, \Self.tickColor as KeyPath, \Self.tickCount as KeyPath, \Self.tickDash as KeyPath, \Self.tickDashOffset as KeyPath, \Self.tickExtra as KeyPath, \Self.tickMinStep as KeyPath, \Self.tickOffset as KeyPath, \Self.tickOpacity as KeyPath, \Self.tickRound as KeyPath, \Self.tickSize as KeyPath, \Self.tickWidth as KeyPath, \Self.ticks as KeyPath, \Self.title as KeyPath, \Self.titleAlign as KeyPath, \Self.titleAnchor as KeyPath, \Self.titleAngle as KeyPath, \Self.titleBaseline as KeyPath, \Self.titleColor as KeyPath, \Self.titleFont as KeyPath, \Self.titleFontSize as KeyPath, \Self.titleFontStyle as KeyPath, \Self.titleFontWeight as KeyPath, \Self.titleLimit as KeyPath, \Self.titleLineHeight as KeyPath, \Self.titleOpacity as KeyPath, \Self.titlePadding as KeyPath, \Self.titleX as KeyPath, \Self.titleY as KeyPath, \Self.translate as KeyPath, \Self.values as KeyPath, \Self.zindex as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aria as KeyPath : CodingKeys.aria, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.description as KeyPath : CodingKeys.description, \Self.disable as KeyPath : CodingKeys.disable, \Self.domain as KeyPath : CodingKeys.domain, \Self.domainCap as KeyPath : CodingKeys.domainCap, \Self.domainColor as KeyPath : CodingKeys.domainColor, \Self.domainDash as KeyPath : CodingKeys.domainDash, \Self.domainDashOffset as KeyPath : CodingKeys.domainDashOffset, \Self.domainOpacity as KeyPath : CodingKeys.domainOpacity, \Self.domainWidth as KeyPath : CodingKeys.domainWidth, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.grid as KeyPath : CodingKeys.grid, \Self.gridCap as KeyPath : CodingKeys.gridCap, \Self.gridColor as KeyPath : CodingKeys.gridColor, \Self.gridDash as KeyPath : CodingKeys.gridDash, \Self.gridDashOffset as KeyPath : CodingKeys.gridDashOffset, \Self.gridOpacity as KeyPath : CodingKeys.gridOpacity, \Self.gridWidth as KeyPath : CodingKeys.gridWidth, \Self.labelAlign as KeyPath : CodingKeys.labelAlign, \Self.labelAngle as KeyPath : CodingKeys.labelAngle, \Self.labelBaseline as KeyPath : CodingKeys.labelBaseline, \Self.labelBound as KeyPath : CodingKeys.labelBound, \Self.labelColor as KeyPath : CodingKeys.labelColor, \Self.labelExpr as KeyPath : CodingKeys.labelExpr, \Self.labelFlush as KeyPath : CodingKeys.labelFlush, \Self.labelFlushOffset as KeyPath : CodingKeys.labelFlushOffset, \Self.labelFont as KeyPath : CodingKeys.labelFont, \Self.labelFontSize as KeyPath : CodingKeys.labelFontSize, \Self.labelFontStyle as KeyPath : CodingKeys.labelFontStyle, \Self.labelFontWeight as KeyPath : CodingKeys.labelFontWeight, \Self.labelLimit as KeyPath : CodingKeys.labelLimit, \Self.labelLineHeight as KeyPath : CodingKeys.labelLineHeight, \Self.labelOffset as KeyPath : CodingKeys.labelOffset, \Self.labelOpacity as KeyPath : CodingKeys.labelOpacity, \Self.labelOverlap as KeyPath : CodingKeys.labelOverlap, \Self.labelPadding as KeyPath : CodingKeys.labelPadding, \Self.labelSeparation as KeyPath : CodingKeys.labelSeparation, \Self.labels as KeyPath : CodingKeys.labels, \Self.maxExtent as KeyPath : CodingKeys.maxExtent, \Self.minExtent as KeyPath : CodingKeys.minExtent, \Self.offset as KeyPath : CodingKeys.offset, \Self.orient as KeyPath : CodingKeys.orient, \Self.position as KeyPath : CodingKeys.position, \Self.style as KeyPath : CodingKeys.style, \Self.tickBand as KeyPath : CodingKeys.tickBand, \Self.tickCap as KeyPath : CodingKeys.tickCap, \Self.tickColor as KeyPath : CodingKeys.tickColor, \Self.tickCount as KeyPath : CodingKeys.tickCount, \Self.tickDash as KeyPath : CodingKeys.tickDash, \Self.tickDashOffset as KeyPath : CodingKeys.tickDashOffset, \Self.tickExtra as KeyPath : CodingKeys.tickExtra, \Self.tickMinStep as KeyPath : CodingKeys.tickMinStep, \Self.tickOffset as KeyPath : CodingKeys.tickOffset, \Self.tickOpacity as KeyPath : CodingKeys.tickOpacity, \Self.tickRound as KeyPath : CodingKeys.tickRound, \Self.tickSize as KeyPath : CodingKeys.tickSize, \Self.tickWidth as KeyPath : CodingKeys.tickWidth, \Self.ticks as KeyPath : CodingKeys.ticks, \Self.title as KeyPath : CodingKeys.title, \Self.titleAlign as KeyPath : CodingKeys.titleAlign, \Self.titleAnchor as KeyPath : CodingKeys.titleAnchor, \Self.titleAngle as KeyPath : CodingKeys.titleAngle, \Self.titleBaseline as KeyPath : CodingKeys.titleBaseline, \Self.titleColor as KeyPath : CodingKeys.titleColor, \Self.titleFont as KeyPath : CodingKeys.titleFont, \Self.titleFontSize as KeyPath : CodingKeys.titleFontSize, \Self.titleFontStyle as KeyPath : CodingKeys.titleFontStyle, \Self.titleFontWeight as KeyPath : CodingKeys.titleFontWeight, \Self.titleLimit as KeyPath : CodingKeys.titleLimit, \Self.titleLineHeight as KeyPath : CodingKeys.titleLineHeight, \Self.titleOpacity as KeyPath : CodingKeys.titleOpacity, \Self.titlePadding as KeyPath : CodingKeys.titlePadding, \Self.titleX as KeyPath : CodingKeys.titleX, \Self.titleY as KeyPath : CodingKeys.titleY, \Self.translate as KeyPath : CodingKeys.translate, \Self.values as KeyPath : CodingKeys.values, \Self.zindex as KeyPath : CodingKeys.zindex]

    public init(aria: AriaChoice? = nil, bandPosition: BandPositionChoice? = nil, description: DescriptionChoice? = nil, disable: Bool? = nil, domain: Bool? = nil, domainCap: DomainCapChoice? = nil, domainColor: DomainColorChoice? = nil, domainDash: DomainDashChoice? = nil, domainDashOffset: DomainDashOffsetChoice? = nil, domainOpacity: DomainOpacityChoice? = nil, domainWidth: DomainWidthChoice? = nil, format: FormatChoice? = nil, formatType: String? = nil, grid: Bool? = nil, gridCap: GridCapChoice? = nil, gridColor: GridColorChoice? = nil, gridDash: GridDashChoice? = nil, gridDashOffset: GridDashOffsetChoice? = nil, gridOpacity: GridOpacityChoice? = nil, gridWidth: GridWidthChoice? = nil, labelAlign: LabelAlignChoice? = nil, labelAngle: LabelAngleChoice? = nil, labelBaseline: LabelBaselineChoice? = nil, labelBound: LabelBoundChoice? = nil, labelColor: LabelColorChoice? = nil, labelExpr: Expr? = nil, labelFlush: LabelFlush? = nil, labelFlushOffset: LabelFlushOffsetChoice? = nil, labelFont: FontName? = nil, labelFontSize: LabelFontSizeChoice? = nil, labelFontStyle: LabelFontStyleChoice? = nil, labelFontWeight: LabelFontWeightChoice? = nil, labelLimit: LabelLimitChoice? = nil, labelLineHeight: LabelLineHeightChoice? = nil, labelOffset: LabelOffsetChoice? = nil, labelOpacity: LabelOpacityChoice? = nil, labelOverlap: LabelOverlapChoice? = nil, labelPadding: LabelPaddingChoice? = nil, labelSeparation: LabelSeparationChoice? = nil, labels: Bool? = nil, maxExtent: MaxExtentChoice? = nil, minExtent: MinExtentChoice? = nil, offset: OffsetChoice? = nil, orient: OrientChoice? = nil, position: PositionChoice? = nil, style: StyleChoice? = nil, tickBand: TickBandChoice? = nil, tickCap: TickCapChoice? = nil, tickColor: TickColorChoice? = nil, tickCount: TickCountChoice? = nil, tickDash: TickDashChoice? = nil, tickDashOffset: TickDashOffsetChoice? = nil, tickExtra: Bool? = nil, tickMinStep: TickMinStepChoice? = nil, tickOffset: TickOffsetChoice? = nil, tickOpacity: TickOpacityChoice? = nil, tickRound: Bool? = nil, tickSize: TickSizeChoice? = nil, tickWidth: TickWidthChoice? = nil, ticks: Bool? = nil, title: TitleChoice? = nil, titleAlign: TitleAlignChoice? = nil, titleAnchor: TitleAnchorChoice? = nil, titleAngle: TitleAngleChoice? = nil, titleBaseline: TitleBaselineChoice? = nil, titleColor: TitleColorChoice? = nil, titleFont: FontName? = nil, titleFontSize: TitleFontSizeChoice? = nil, titleFontStyle: TitleFontStyleChoice? = nil, titleFontWeight: TitleFontWeightChoice? = nil, titleLimit: TitleLimitChoice? = nil, titleLineHeight: TitleLineHeightChoice? = nil, titleOpacity: TitleOpacityChoice? = nil, titlePadding: TitlePaddingChoice? = nil, titleX: TitleXChoice? = nil, titleY: TitleYChoice? = nil, translate: TranslateChoice? = nil, values: ValuesChoice? = nil, zindex: Double? = nil) {
        self.aria = aria 
        self.bandPosition = bandPosition 
        self.description = description 
        self.disable = disable 
        self.domain = domain 
        self.domainCap = domainCap 
        self.domainColor = domainColor 
        self.domainDash = domainDash 
        self.domainDashOffset = domainDashOffset 
        self.domainOpacity = domainOpacity 
        self.domainWidth = domainWidth 
        self.format = format 
        self.formatType = formatType 
        self.grid = grid 
        self.gridCap = gridCap 
        self.gridColor = gridColor 
        self.gridDash = gridDash 
        self.gridDashOffset = gridDashOffset 
        self.gridOpacity = gridOpacity 
        self.gridWidth = gridWidth 
        self.labelAlign = labelAlign 
        self.labelAngle = labelAngle 
        self.labelBaseline = labelBaseline 
        self.labelBound = labelBound 
        self.labelColor = labelColor 
        self.labelExpr = labelExpr 
        self.labelFlush = labelFlush 
        self.labelFlushOffset = labelFlushOffset 
        self.labelFont = labelFont 
        self.labelFontSize = labelFontSize 
        self.labelFontStyle = labelFontStyle 
        self.labelFontWeight = labelFontWeight 
        self.labelLimit = labelLimit 
        self.labelLineHeight = labelLineHeight 
        self.labelOffset = labelOffset 
        self.labelOpacity = labelOpacity 
        self.labelOverlap = labelOverlap 
        self.labelPadding = labelPadding 
        self.labelSeparation = labelSeparation 
        self.labels = labels 
        self.maxExtent = maxExtent 
        self.minExtent = minExtent 
        self.offset = offset 
        self.orient = orient 
        self.position = position 
        self.style = style 
        self.tickBand = tickBand 
        self.tickCap = tickCap 
        self.tickColor = tickColor 
        self.tickCount = tickCount 
        self.tickDash = tickDash 
        self.tickDashOffset = tickDashOffset 
        self.tickExtra = tickExtra 
        self.tickMinStep = tickMinStep 
        self.tickOffset = tickOffset 
        self.tickOpacity = tickOpacity 
        self.tickRound = tickRound 
        self.tickSize = tickSize 
        self.tickWidth = tickWidth 
        self.ticks = ticks 
        self.title = title 
        self.titleAlign = titleAlign 
        self.titleAnchor = titleAnchor 
        self.titleAngle = titleAngle 
        self.titleBaseline = titleBaseline 
        self.titleColor = titleColor 
        self.titleFont = titleFont 
        self.titleFontSize = titleFontSize 
        self.titleFontStyle = titleFontStyle 
        self.titleFontWeight = titleFontWeight 
        self.titleLimit = titleLimit 
        self.titleLineHeight = titleLineHeight 
        self.titleOpacity = titleOpacity 
        self.titlePadding = titlePadding 
        self.titleX = titleX 
        self.titleY = titleY 
        self.translate = translate 
        self.values = values 
        self.zindex = zindex 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.bandPosition = try values.decodeOptional(BandPositionChoice.self, forKey: .bandPosition) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.disable = try values.decodeOptional(Bool.self, forKey: .disable) 
        self.domain = try values.decodeOptional(Bool.self, forKey: .domain) 
        self.domainCap = try values.decodeOptional(DomainCapChoice.self, forKey: .domainCap) 
        self.domainColor = try values.decodeOptional(DomainColorChoice.self, forKey: .domainColor) 
        self.domainDash = try values.decodeOptional(DomainDashChoice.self, forKey: .domainDash) 
        self.domainDashOffset = try values.decodeOptional(DomainDashOffsetChoice.self, forKey: .domainDashOffset) 
        self.domainOpacity = try values.decodeOptional(DomainOpacityChoice.self, forKey: .domainOpacity) 
        self.domainWidth = try values.decodeOptional(DomainWidthChoice.self, forKey: .domainWidth) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.grid = try values.decodeOptional(Bool.self, forKey: .grid) 
        self.gridCap = try values.decodeOptional(GridCapChoice.self, forKey: .gridCap) 
        self.gridColor = try values.decodeOptional(GridColorChoice.self, forKey: .gridColor) 
        self.gridDash = try values.decodeOptional(GridDashChoice.self, forKey: .gridDash) 
        self.gridDashOffset = try values.decodeOptional(GridDashOffsetChoice.self, forKey: .gridDashOffset) 
        self.gridOpacity = try values.decodeOptional(GridOpacityChoice.self, forKey: .gridOpacity) 
        self.gridWidth = try values.decodeOptional(GridWidthChoice.self, forKey: .gridWidth) 
        self.labelAlign = try values.decodeOptional(LabelAlignChoice.self, forKey: .labelAlign) 
        self.labelAngle = try values.decodeOptional(LabelAngleChoice.self, forKey: .labelAngle) 
        self.labelBaseline = try values.decodeOptional(LabelBaselineChoice.self, forKey: .labelBaseline) 
        self.labelBound = try values.decodeOptional(LabelBoundChoice.self, forKey: .labelBound) 
        self.labelColor = try values.decodeOptional(LabelColorChoice.self, forKey: .labelColor) 
        self.labelExpr = try values.decodeOptional(Expr.self, forKey: .labelExpr) 
        self.labelFlush = try values.decodeOptional(LabelFlush.self, forKey: .labelFlush) 
        self.labelFlushOffset = try values.decodeOptional(LabelFlushOffsetChoice.self, forKey: .labelFlushOffset) 
        self.labelFont = try values.decodeOptional(FontName.self, forKey: .labelFont) 
        self.labelFontSize = try values.decodeOptional(LabelFontSizeChoice.self, forKey: .labelFontSize) 
        self.labelFontStyle = try values.decodeOptional(LabelFontStyleChoice.self, forKey: .labelFontStyle) 
        self.labelFontWeight = try values.decodeOptional(LabelFontWeightChoice.self, forKey: .labelFontWeight) 
        self.labelLimit = try values.decodeOptional(LabelLimitChoice.self, forKey: .labelLimit) 
        self.labelLineHeight = try values.decodeOptional(LabelLineHeightChoice.self, forKey: .labelLineHeight) 
        self.labelOffset = try values.decodeOptional(LabelOffsetChoice.self, forKey: .labelOffset) 
        self.labelOpacity = try values.decodeOptional(LabelOpacityChoice.self, forKey: .labelOpacity) 
        self.labelOverlap = try values.decodeOptional(LabelOverlapChoice.self, forKey: .labelOverlap) 
        self.labelPadding = try values.decodeOptional(LabelPaddingChoice.self, forKey: .labelPadding) 
        self.labelSeparation = try values.decodeOptional(LabelSeparationChoice.self, forKey: .labelSeparation) 
        self.labels = try values.decodeOptional(Bool.self, forKey: .labels) 
        self.maxExtent = try values.decodeOptional(MaxExtentChoice.self, forKey: .maxExtent) 
        self.minExtent = try values.decodeOptional(MinExtentChoice.self, forKey: .minExtent) 
        self.offset = try values.decodeOptional(OffsetChoice.self, forKey: .offset) 
        self.orient = try values.decodeOptional(OrientChoice.self, forKey: .orient) 
        self.position = try values.decodeOptional(PositionChoice.self, forKey: .position) 
        self.style = try values.decodeOptional(StyleChoice.self, forKey: .style) 
        self.tickBand = try values.decodeOptional(TickBandChoice.self, forKey: .tickBand) 
        self.tickCap = try values.decodeOptional(TickCapChoice.self, forKey: .tickCap) 
        self.tickColor = try values.decodeOptional(TickColorChoice.self, forKey: .tickColor) 
        self.tickCount = try values.decodeOptional(TickCountChoice.self, forKey: .tickCount) 
        self.tickDash = try values.decodeOptional(TickDashChoice.self, forKey: .tickDash) 
        self.tickDashOffset = try values.decodeOptional(TickDashOffsetChoice.self, forKey: .tickDashOffset) 
        self.tickExtra = try values.decodeOptional(Bool.self, forKey: .tickExtra) 
        self.tickMinStep = try values.decodeOptional(TickMinStepChoice.self, forKey: .tickMinStep) 
        self.tickOffset = try values.decodeOptional(TickOffsetChoice.self, forKey: .tickOffset) 
        self.tickOpacity = try values.decodeOptional(TickOpacityChoice.self, forKey: .tickOpacity) 
        self.tickRound = try values.decodeOptional(Bool.self, forKey: .tickRound) 
        self.tickSize = try values.decodeOptional(TickSizeChoice.self, forKey: .tickSize) 
        self.tickWidth = try values.decodeOptional(TickWidthChoice.self, forKey: .tickWidth) 
        self.ticks = try values.decodeOptional(Bool.self, forKey: .ticks) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.titleAlign = try values.decodeOptional(TitleAlignChoice.self, forKey: .titleAlign) 
        self.titleAnchor = try values.decodeOptional(TitleAnchorChoice.self, forKey: .titleAnchor) 
        self.titleAngle = try values.decodeOptional(TitleAngleChoice.self, forKey: .titleAngle) 
        self.titleBaseline = try values.decodeOptional(TitleBaselineChoice.self, forKey: .titleBaseline) 
        self.titleColor = try values.decodeOptional(TitleColorChoice.self, forKey: .titleColor) 
        self.titleFont = try values.decodeOptional(FontName.self, forKey: .titleFont) 
        self.titleFontSize = try values.decodeOptional(TitleFontSizeChoice.self, forKey: .titleFontSize) 
        self.titleFontStyle = try values.decodeOptional(TitleFontStyleChoice.self, forKey: .titleFontStyle) 
        self.titleFontWeight = try values.decodeOptional(TitleFontWeightChoice.self, forKey: .titleFontWeight) 
        self.titleLimit = try values.decodeOptional(TitleLimitChoice.self, forKey: .titleLimit) 
        self.titleLineHeight = try values.decodeOptional(TitleLineHeightChoice.self, forKey: .titleLineHeight) 
        self.titleOpacity = try values.decodeOptional(TitleOpacityChoice.self, forKey: .titleOpacity) 
        self.titlePadding = try values.decodeOptional(TitlePaddingChoice.self, forKey: .titlePadding) 
        self.titleX = try values.decodeOptional(TitleXChoice.self, forKey: .titleX) 
        self.titleY = try values.decodeOptional(TitleYChoice.self, forKey: .titleY) 
        self.translate = try values.decodeOptional(TranslateChoice.self, forKey: .translate) 
        self.values = try values.decodeOptional(ValuesChoice.self, forKey: .values) 
        self.zindex = try values.decodeOptional(Double.self, forKey: .zindex) 
    }

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias BandPositionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainWidthChoice = OneOf<Double>.Or<ExprRef>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Generated by Curio
    public typealias GridCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Generated by Curio
    public typealias GridColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>.Or<ConditionalAxisColor>

    /// Generated by Curio
    public typealias GridDashChoice = OneOf<[Double]>.Or<ExprRef>.Or<ConditionalAxisNumberArray>

    /// Generated by Curio
    public typealias GridDashOffsetChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias GridOpacityChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias GridWidthChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias LabelAlignChoice = OneOf<Align>.Or<ExprRef>.Or<ConditionalAxisLabelAlign>

    /// Generated by Curio
    public typealias LabelAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>.Or<ConditionalAxisLabelBaseline>

    /// Generated by Curio
    public typealias LabelBoundChoice = OneOf<OneOf<Double>.Or<Bool>>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>.Or<ConditionalAxisColor>

    /// Generated by Curio
    public typealias LabelFlush = OneOf<Bool>.Or<Double>

    /// Generated by Curio
    public typealias LabelFlushOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelFontSizeChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias LabelFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>.Or<ConditionalAxisLabelFontStyle>

    /// Generated by Curio
    public typealias LabelFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>.Or<ConditionalAxisLabelFontWeight>

    /// Generated by Curio
    public typealias LabelLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelOffsetChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias LabelOpacityChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
    /// __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log scales; otherwise `false`.
    /// Generated by Curio
    public typealias LabelOverlapChoice = OneOf<LabelOverlap>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelPaddingChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias LabelSeparationChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias MaxExtentChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias MinExtentChoice = OneOf<Double>.Or<ExprRef>

    /// The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.
    /// __Default value:__ derived from the [axis config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset` (`0` by default)
    /// Generated by Curio
    public typealias OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The orientation can be used to further specialize the axis type (e.g., a y-axis oriented towards the right edge of the chart).
    /// __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
    /// Generated by Curio
    public typealias OrientChoice = OneOf<AxisOrient>.Or<ExprRef>

    /// The anchor position of the axis in pixels. For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.
    /// __Default value__: `0`
    /// Generated by Curio
    public typealias PositionChoice = OneOf<Double>.Or<ExprRef>

    /// A string or array of strings indicating the name of custom styles to apply to the axis. A style is a named collection of axis property defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.
    /// __Default value:__ (none) __Note:__ Any specified style will augment the default style. For example, an x-axis mark with `"style": "foo"` will use `config.axisX` and `config.style.foo` (the specified style `"foo"` has higher precedence).
    /// Generated by Curio
    public typealias StyleChoice = OneOrMany<String>

    /// Generated by Curio
    public typealias TickBandChoice = OneOf<LiteralCenterOrExtent>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>.Or<ConditionalAxisColor>

    /// A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the underlying scale's range.
    /// For scales of type `"time"` or `"utc"`, the tick count can instead be a time interval specifier. Legal string values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, an object-valued interval specifier of the form `{"interval": "month", "step": 3}` includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.
    /// __Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)` for y.
    /// Generated by Curio
    public typealias TickCountChoice = OneOf<Double>.Or<TemporalUnit>.Or<TimeIntervalStep>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickDashChoice = OneOf<[Double]>.Or<ExprRef>.Or<ConditionalAxisNumberArray>

    /// Generated by Curio
    public typealias TickDashOffsetChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// The minimum desired step between axis ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value.
    /// Generated by Curio
    public typealias TickMinStepChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickOpacityChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias TickSizeChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias TickWidthChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias TitleAlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleAnchorChoice = OneOf<TitleAnchor>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    /// Generated by Curio
    public typealias TitleColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitlePaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleXChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleYChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TranslateChoice = OneOf<Double>.Or<ExprRef>

    /// Explicitly set the visible axis tick values.
    /// Generated by Curio
    public typealias ValuesChoice = OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[DateTime]>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aria
        case bandPosition
        case description
        case disable
        case domain
        case domainCap
        case domainColor
        case domainDash
        case domainDashOffset
        case domainOpacity
        case domainWidth
        case format
        case formatType
        case grid
        case gridCap
        case gridColor
        case gridDash
        case gridDashOffset
        case gridOpacity
        case gridWidth
        case labelAlign
        case labelAngle
        case labelBaseline
        case labelBound
        case labelColor
        case labelExpr
        case labelFlush
        case labelFlushOffset
        case labelFont
        case labelFontSize
        case labelFontStyle
        case labelFontWeight
        case labelLimit
        case labelLineHeight
        case labelOffset
        case labelOpacity
        case labelOverlap
        case labelPadding
        case labelSeparation
        case labels
        case maxExtent
        case minExtent
        case offset
        case orient
        case position
        case style
        case tickBand
        case tickCap
        case tickColor
        case tickCount
        case tickDash
        case tickDashOffset
        case tickExtra
        case tickMinStep
        case tickOffset
        case tickOpacity
        case tickRound
        case tickSize
        case tickWidth
        case ticks
        case title
        case titleAlign
        case titleAnchor
        case titleAngle
        case titleBaseline
        case titleColor
        case titleFont
        case titleFontSize
        case titleFontStyle
        case titleFontWeight
        case titleLimit
        case titleLineHeight
        case titleOpacity
        case titlePadding
        case titleX
        case titleY
        case translate
        case values
        case zindex
        public var keyDescription: String? {
            switch self {
            case .aria: return nil
            case .bandPosition: return nil
            case .description: return nil
            case .disable: return "Disable axis by default."
            case .domain: return "A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.\n\n__Default value:__ `true`"
            case .domainCap: return nil
            case .domainColor: return nil
            case .domainDash: return nil
            case .domainDashOffset: return nil
            case .domainOpacity: return nil
            case .domainWidth: return nil
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .grid: return "A boolean flag indicating if grid lines should be included as part of the axis\n\n__Default value:__ `true` for [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned; otherwise, `false`."
            case .gridCap: return nil
            case .gridColor: return nil
            case .gridDash: return nil
            case .gridDashOffset: return nil
            case .gridOpacity: return nil
            case .gridWidth: return nil
            case .labelAlign: return nil
            case .labelAngle: return nil
            case .labelBaseline: return nil
            case .labelBound: return nil
            case .labelColor: return nil
            case .labelExpr: return "[Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.\n\n__Note:__ The label text and value can be assessed via the `label` and `value` properties of the axis's backing `datum` object."
            case .labelFlush: return "Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.\n\n__Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`."
            case .labelFlushOffset: return nil
            case .labelFont: return nil
            case .labelFontSize: return nil
            case .labelFontStyle: return nil
            case .labelFontWeight: return nil
            case .labelLimit: return nil
            case .labelLineHeight: return nil
            case .labelOffset: return nil
            case .labelOpacity: return nil
            case .labelOverlap: return "The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `\"parity\"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `\"greedy\"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).\n\n__Default value:__ `true` for non-nominal fields with non-log scales; `\"greedy\"` for log scales; otherwise `false`."
            case .labelPadding: return nil
            case .labelSeparation: return nil
            case .labels: return "A boolean flag indicating if labels should be included as part of the axis.\n\n__Default value:__ `true`."
            case .maxExtent: return nil
            case .minExtent: return nil
            case .offset: return "The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n\n__Default value:__ derived from the [axis config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset` (`0` by default)"
            case .orient: return "The orientation of the axis. One of `\"top\"`, `\"bottom\"`, `\"left\"` or `\"right\"`. The orientation can be used to further specialize the axis type (e.g., a y-axis oriented towards the right edge of the chart).\n\n__Default value:__ `\"bottom\"` for x-axes and `\"left\"` for y-axes."
            case .position: return "The anchor position of the axis in pixels. For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.\n\n__Default value__: `0`"
            case .style: return "A string or array of strings indicating the name of custom styles to apply to the axis. A style is a named collection of axis property defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.\n\n__Default value:__ (none) __Note:__ Any specified style will augment the default style. For example, an x-axis mark with `\"style\": \"foo\"` will use `config.axisX` and `config.style.foo` (the specified style `\"foo\"` has higher precedence)."
            case .tickBand: return nil
            case .tickCap: return nil
            case .tickColor: return nil
            case .tickCount: return "A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.\n\nFor scales of type `\"time\"` or `\"utc\"`, the tick count can instead be a time interval specifier. Legal string values are `\"millisecond\"`, `\"second\"`, `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`. Alternatively, an object-valued interval specifier of the form `{\"interval\": \"month\", \"step\": 3}` includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.\n\n__Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)` for y."
            case .tickDash: return nil
            case .tickDashOffset: return nil
            case .tickExtra: return "Boolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for `band` scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with `\"bandPosition\": 1` and an axis `\"padding\"` value of `0`."
            case .tickMinStep: return "The minimum desired step between axis ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value."
            case .tickOffset: return nil
            case .tickOpacity: return nil
            case .tickRound: return "Boolean flag indicating if pixel position values should be rounded to the nearest integer.\n\n__Default value:__ `true`"
            case .tickSize: return nil
            case .tickWidth: return nil
            case .ticks: return "Boolean value that determines whether the axis should include ticks.\n\n__Default value:__ `true`"
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .titleAlign: return nil
            case .titleAnchor: return nil
            case .titleAngle: return nil
            case .titleBaseline: return nil
            case .titleColor: return nil
            case .titleFont: return nil
            case .titleFontSize: return nil
            case .titleFontStyle: return nil
            case .titleFontWeight: return nil
            case .titleLimit: return nil
            case .titleLineHeight: return nil
            case .titleOpacity: return nil
            case .titlePadding: return nil
            case .titleX: return nil
            case .titleY: return nil
            case .translate: return nil
            case .values: return "Explicitly set the visible axis tick values."
            case .zindex: return "A non-negative integer indicating the z-index of the axis. If zindex is 0, axes should be drawn behind all chart elements. To put them in front, set `zindex` to `1` or more.\n\n__Default value:__ `0` (behind the marks)."
             } 
        }

        public typealias CodingOwner = AxisConfig
    }
}

/// Generated by Curio
public struct AxisDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var aria: AriaChoice?
    public var bandPosition: BandPositionChoice?
    public var description: DescriptionChoice?
    /// A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.
    /// __Default value:__ `true`
    public var domain: Bool?
    public var domainCap: DomainCapChoice?
    public var domainColor: DomainColorChoice?
    public var domainDash: DomainDashChoice?
    public var domainDashOffset: DomainDashOffsetChoice?
    public var domainOpacity: DomainOpacityChoice?
    public var domainWidth: DomainWidthChoice?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// A boolean flag indicating if grid lines should be included as part of the axis
    /// __Default value:__ `true` for [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned; otherwise, `false`.
    public var grid: Bool?
    public var gridCap: GridCapChoice?
    public var gridColor: GridColorChoice?
    public var gridDash: GridDashChoice?
    public var gridDashOffset: GridDashOffsetChoice?
    public var gridOpacity: GridOpacityChoice?
    public var gridWidth: GridWidthChoice?
    public var labelAlign: LabelAlignChoice?
    public var labelAngle: LabelAngleChoice?
    public var labelBaseline: LabelBaselineChoice?
    public var labelBound: LabelBoundChoice?
    public var labelColor: LabelColorChoice?
    /// [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
    /// __Note:__ The label text and value can be assessed via the `label` and `value` properties of the axis's backing `datum` object.
    public var labelExpr: Expr?
    /// Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.
    /// __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
    public var labelFlush: LabelFlush?
    public var labelFlushOffset: LabelFlushOffsetChoice?
    public var labelFont: FontName?
    public var labelFontSize: LabelFontSizeChoice?
    public var labelFontStyle: LabelFontStyleChoice?
    public var labelFontWeight: LabelFontWeightChoice?
    public var labelLimit: LabelLimitChoice?
    public var labelLineHeight: LabelLineHeightChoice?
    public var labelOffset: LabelOffsetChoice?
    public var labelOpacity: LabelOpacityChoice?
    /// The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
    /// __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log scales; otherwise `false`.
    public var labelOverlap: LabelOverlapChoice?
    public var labelPadding: LabelPaddingChoice?
    public var labelSeparation: LabelSeparationChoice?
    /// A boolean flag indicating if labels should be included as part of the axis.
    /// __Default value:__ `true`.
    public var labels: Bool?
    public var maxExtent: MaxExtentChoice?
    public var minExtent: MinExtentChoice?
    /// The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.
    /// __Default value:__ derived from the [axis config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset` (`0` by default)
    public var offset: OffsetChoice?
    /// The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The orientation can be used to further specialize the axis type (e.g., a y-axis oriented towards the right edge of the chart).
    /// __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
    public var orient: OrientChoice?
    /// The anchor position of the axis in pixels. For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.
    /// __Default value__: `0`
    public var position: PositionChoice?
    /// A string or array of strings indicating the name of custom styles to apply to the axis. A style is a named collection of axis property defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.
    /// __Default value:__ (none) __Note:__ Any specified style will augment the default style. For example, an x-axis mark with `"style": "foo"` will use `config.axisX` and `config.style.foo` (the specified style `"foo"` has higher precedence).
    public var style: StyleChoice?
    public var tickBand: TickBandChoice?
    public var tickCap: TickCapChoice?
    public var tickColor: TickColorChoice?
    /// A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the underlying scale's range.
    /// For scales of type `"time"` or `"utc"`, the tick count can instead be a time interval specifier. Legal string values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, an object-valued interval specifier of the form `{"interval": "month", "step": 3}` includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.
    /// __Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)` for y.
    public var tickCount: TickCountChoice?
    public var tickDash: TickDashChoice?
    public var tickDashOffset: TickDashOffsetChoice?
    /// Boolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for `band` scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with `"bandPosition": 1` and an axis `"padding"` value of `0`.
    public var tickExtra: Bool?
    /// The minimum desired step between axis ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value.
    public var tickMinStep: TickMinStepChoice?
    public var tickOffset: TickOffsetChoice?
    public var tickOpacity: TickOpacityChoice?
    /// Boolean flag indicating if pixel position values should be rounded to the nearest integer.
    /// __Default value:__ `true`
    public var tickRound: Bool?
    public var tickSize: TickSizeChoice?
    public var tickWidth: TickWidthChoice?
    /// Boolean value that determines whether the axis should include ticks.
    /// __Default value:__ `true`
    public var ticks: Bool?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    public var titleAlign: TitleAlignChoice?
    public var titleAnchor: TitleAnchorChoice?
    public var titleAngle: TitleAngleChoice?
    public var titleBaseline: TitleBaselineChoice?
    public var titleColor: TitleColorChoice?
    public var titleFont: FontName?
    public var titleFontSize: TitleFontSizeChoice?
    public var titleFontStyle: TitleFontStyleChoice?
    public var titleFontWeight: TitleFontWeightChoice?
    public var titleLimit: TitleLimitChoice?
    public var titleLineHeight: TitleLineHeightChoice?
    public var titleOpacity: TitleOpacityChoice?
    public var titlePadding: TitlePaddingChoice?
    public var titleX: TitleXChoice?
    public var titleY: TitleYChoice?
    public var translate: TranslateChoice?
    /// Explicitly set the visible axis tick values.
    public var values: ValuesChoice?
    /// A non-negative integer indicating the z-index of the axis. If zindex is 0, axes should be drawn behind all chart elements. To put them in front, set `zindex` to `1` or more.
    /// __Default value:__ `0` (behind the marks).
    public var zindex: Double?
    public static let codingKeyPaths = (\Self.aria as KeyPath, \Self.bandPosition as KeyPath, \Self.description as KeyPath, \Self.domain as KeyPath, \Self.domainCap as KeyPath, \Self.domainColor as KeyPath, \Self.domainDash as KeyPath, \Self.domainDashOffset as KeyPath, \Self.domainOpacity as KeyPath, \Self.domainWidth as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.grid as KeyPath, \Self.gridCap as KeyPath, \Self.gridColor as KeyPath, \Self.gridDash as KeyPath, \Self.gridDashOffset as KeyPath, \Self.gridOpacity as KeyPath, \Self.gridWidth as KeyPath, \Self.labelAlign as KeyPath, \Self.labelAngle as KeyPath, \Self.labelBaseline as KeyPath, \Self.labelBound as KeyPath, \Self.labelColor as KeyPath, \Self.labelExpr as KeyPath, \Self.labelFlush as KeyPath, \Self.labelFlushOffset as KeyPath, \Self.labelFont as KeyPath, \Self.labelFontSize as KeyPath, \Self.labelFontStyle as KeyPath, \Self.labelFontWeight as KeyPath, \Self.labelLimit as KeyPath, \Self.labelLineHeight as KeyPath, \Self.labelOffset as KeyPath, \Self.labelOpacity as KeyPath, \Self.labelOverlap as KeyPath, \Self.labelPadding as KeyPath, \Self.labelSeparation as KeyPath, \Self.labels as KeyPath, \Self.maxExtent as KeyPath, \Self.minExtent as KeyPath, \Self.offset as KeyPath, \Self.orient as KeyPath, \Self.position as KeyPath, \Self.style as KeyPath, \Self.tickBand as KeyPath, \Self.tickCap as KeyPath, \Self.tickColor as KeyPath, \Self.tickCount as KeyPath, \Self.tickDash as KeyPath, \Self.tickDashOffset as KeyPath, \Self.tickExtra as KeyPath, \Self.tickMinStep as KeyPath, \Self.tickOffset as KeyPath, \Self.tickOpacity as KeyPath, \Self.tickRound as KeyPath, \Self.tickSize as KeyPath, \Self.tickWidth as KeyPath, \Self.ticks as KeyPath, \Self.title as KeyPath, \Self.titleAlign as KeyPath, \Self.titleAnchor as KeyPath, \Self.titleAngle as KeyPath, \Self.titleBaseline as KeyPath, \Self.titleColor as KeyPath, \Self.titleFont as KeyPath, \Self.titleFontSize as KeyPath, \Self.titleFontStyle as KeyPath, \Self.titleFontWeight as KeyPath, \Self.titleLimit as KeyPath, \Self.titleLineHeight as KeyPath, \Self.titleOpacity as KeyPath, \Self.titlePadding as KeyPath, \Self.titleX as KeyPath, \Self.titleY as KeyPath, \Self.translate as KeyPath, \Self.values as KeyPath, \Self.zindex as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aria as KeyPath : CodingKeys.aria, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.description as KeyPath : CodingKeys.description, \Self.domain as KeyPath : CodingKeys.domain, \Self.domainCap as KeyPath : CodingKeys.domainCap, \Self.domainColor as KeyPath : CodingKeys.domainColor, \Self.domainDash as KeyPath : CodingKeys.domainDash, \Self.domainDashOffset as KeyPath : CodingKeys.domainDashOffset, \Self.domainOpacity as KeyPath : CodingKeys.domainOpacity, \Self.domainWidth as KeyPath : CodingKeys.domainWidth, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.grid as KeyPath : CodingKeys.grid, \Self.gridCap as KeyPath : CodingKeys.gridCap, \Self.gridColor as KeyPath : CodingKeys.gridColor, \Self.gridDash as KeyPath : CodingKeys.gridDash, \Self.gridDashOffset as KeyPath : CodingKeys.gridDashOffset, \Self.gridOpacity as KeyPath : CodingKeys.gridOpacity, \Self.gridWidth as KeyPath : CodingKeys.gridWidth, \Self.labelAlign as KeyPath : CodingKeys.labelAlign, \Self.labelAngle as KeyPath : CodingKeys.labelAngle, \Self.labelBaseline as KeyPath : CodingKeys.labelBaseline, \Self.labelBound as KeyPath : CodingKeys.labelBound, \Self.labelColor as KeyPath : CodingKeys.labelColor, \Self.labelExpr as KeyPath : CodingKeys.labelExpr, \Self.labelFlush as KeyPath : CodingKeys.labelFlush, \Self.labelFlushOffset as KeyPath : CodingKeys.labelFlushOffset, \Self.labelFont as KeyPath : CodingKeys.labelFont, \Self.labelFontSize as KeyPath : CodingKeys.labelFontSize, \Self.labelFontStyle as KeyPath : CodingKeys.labelFontStyle, \Self.labelFontWeight as KeyPath : CodingKeys.labelFontWeight, \Self.labelLimit as KeyPath : CodingKeys.labelLimit, \Self.labelLineHeight as KeyPath : CodingKeys.labelLineHeight, \Self.labelOffset as KeyPath : CodingKeys.labelOffset, \Self.labelOpacity as KeyPath : CodingKeys.labelOpacity, \Self.labelOverlap as KeyPath : CodingKeys.labelOverlap, \Self.labelPadding as KeyPath : CodingKeys.labelPadding, \Self.labelSeparation as KeyPath : CodingKeys.labelSeparation, \Self.labels as KeyPath : CodingKeys.labels, \Self.maxExtent as KeyPath : CodingKeys.maxExtent, \Self.minExtent as KeyPath : CodingKeys.minExtent, \Self.offset as KeyPath : CodingKeys.offset, \Self.orient as KeyPath : CodingKeys.orient, \Self.position as KeyPath : CodingKeys.position, \Self.style as KeyPath : CodingKeys.style, \Self.tickBand as KeyPath : CodingKeys.tickBand, \Self.tickCap as KeyPath : CodingKeys.tickCap, \Self.tickColor as KeyPath : CodingKeys.tickColor, \Self.tickCount as KeyPath : CodingKeys.tickCount, \Self.tickDash as KeyPath : CodingKeys.tickDash, \Self.tickDashOffset as KeyPath : CodingKeys.tickDashOffset, \Self.tickExtra as KeyPath : CodingKeys.tickExtra, \Self.tickMinStep as KeyPath : CodingKeys.tickMinStep, \Self.tickOffset as KeyPath : CodingKeys.tickOffset, \Self.tickOpacity as KeyPath : CodingKeys.tickOpacity, \Self.tickRound as KeyPath : CodingKeys.tickRound, \Self.tickSize as KeyPath : CodingKeys.tickSize, \Self.tickWidth as KeyPath : CodingKeys.tickWidth, \Self.ticks as KeyPath : CodingKeys.ticks, \Self.title as KeyPath : CodingKeys.title, \Self.titleAlign as KeyPath : CodingKeys.titleAlign, \Self.titleAnchor as KeyPath : CodingKeys.titleAnchor, \Self.titleAngle as KeyPath : CodingKeys.titleAngle, \Self.titleBaseline as KeyPath : CodingKeys.titleBaseline, \Self.titleColor as KeyPath : CodingKeys.titleColor, \Self.titleFont as KeyPath : CodingKeys.titleFont, \Self.titleFontSize as KeyPath : CodingKeys.titleFontSize, \Self.titleFontStyle as KeyPath : CodingKeys.titleFontStyle, \Self.titleFontWeight as KeyPath : CodingKeys.titleFontWeight, \Self.titleLimit as KeyPath : CodingKeys.titleLimit, \Self.titleLineHeight as KeyPath : CodingKeys.titleLineHeight, \Self.titleOpacity as KeyPath : CodingKeys.titleOpacity, \Self.titlePadding as KeyPath : CodingKeys.titlePadding, \Self.titleX as KeyPath : CodingKeys.titleX, \Self.titleY as KeyPath : CodingKeys.titleY, \Self.translate as KeyPath : CodingKeys.translate, \Self.values as KeyPath : CodingKeys.values, \Self.zindex as KeyPath : CodingKeys.zindex]

    public init(aria: AriaChoice? = nil, bandPosition: BandPositionChoice? = nil, description: DescriptionChoice? = nil, domain: Bool? = nil, domainCap: DomainCapChoice? = nil, domainColor: DomainColorChoice? = nil, domainDash: DomainDashChoice? = nil, domainDashOffset: DomainDashOffsetChoice? = nil, domainOpacity: DomainOpacityChoice? = nil, domainWidth: DomainWidthChoice? = nil, format: FormatChoice? = nil, formatType: String? = nil, grid: Bool? = nil, gridCap: GridCapChoice? = nil, gridColor: GridColorChoice? = nil, gridDash: GridDashChoice? = nil, gridDashOffset: GridDashOffsetChoice? = nil, gridOpacity: GridOpacityChoice? = nil, gridWidth: GridWidthChoice? = nil, labelAlign: LabelAlignChoice? = nil, labelAngle: LabelAngleChoice? = nil, labelBaseline: LabelBaselineChoice? = nil, labelBound: LabelBoundChoice? = nil, labelColor: LabelColorChoice? = nil, labelExpr: Expr? = nil, labelFlush: LabelFlush? = nil, labelFlushOffset: LabelFlushOffsetChoice? = nil, labelFont: FontName? = nil, labelFontSize: LabelFontSizeChoice? = nil, labelFontStyle: LabelFontStyleChoice? = nil, labelFontWeight: LabelFontWeightChoice? = nil, labelLimit: LabelLimitChoice? = nil, labelLineHeight: LabelLineHeightChoice? = nil, labelOffset: LabelOffsetChoice? = nil, labelOpacity: LabelOpacityChoice? = nil, labelOverlap: LabelOverlapChoice? = nil, labelPadding: LabelPaddingChoice? = nil, labelSeparation: LabelSeparationChoice? = nil, labels: Bool? = nil, maxExtent: MaxExtentChoice? = nil, minExtent: MinExtentChoice? = nil, offset: OffsetChoice? = nil, orient: OrientChoice? = nil, position: PositionChoice? = nil, style: StyleChoice? = nil, tickBand: TickBandChoice? = nil, tickCap: TickCapChoice? = nil, tickColor: TickColorChoice? = nil, tickCount: TickCountChoice? = nil, tickDash: TickDashChoice? = nil, tickDashOffset: TickDashOffsetChoice? = nil, tickExtra: Bool? = nil, tickMinStep: TickMinStepChoice? = nil, tickOffset: TickOffsetChoice? = nil, tickOpacity: TickOpacityChoice? = nil, tickRound: Bool? = nil, tickSize: TickSizeChoice? = nil, tickWidth: TickWidthChoice? = nil, ticks: Bool? = nil, title: TitleChoice? = nil, titleAlign: TitleAlignChoice? = nil, titleAnchor: TitleAnchorChoice? = nil, titleAngle: TitleAngleChoice? = nil, titleBaseline: TitleBaselineChoice? = nil, titleColor: TitleColorChoice? = nil, titleFont: FontName? = nil, titleFontSize: TitleFontSizeChoice? = nil, titleFontStyle: TitleFontStyleChoice? = nil, titleFontWeight: TitleFontWeightChoice? = nil, titleLimit: TitleLimitChoice? = nil, titleLineHeight: TitleLineHeightChoice? = nil, titleOpacity: TitleOpacityChoice? = nil, titlePadding: TitlePaddingChoice? = nil, titleX: TitleXChoice? = nil, titleY: TitleYChoice? = nil, translate: TranslateChoice? = nil, values: ValuesChoice? = nil, zindex: Double? = nil) {
        self.aria = aria 
        self.bandPosition = bandPosition 
        self.description = description 
        self.domain = domain 
        self.domainCap = domainCap 
        self.domainColor = domainColor 
        self.domainDash = domainDash 
        self.domainDashOffset = domainDashOffset 
        self.domainOpacity = domainOpacity 
        self.domainWidth = domainWidth 
        self.format = format 
        self.formatType = formatType 
        self.grid = grid 
        self.gridCap = gridCap 
        self.gridColor = gridColor 
        self.gridDash = gridDash 
        self.gridDashOffset = gridDashOffset 
        self.gridOpacity = gridOpacity 
        self.gridWidth = gridWidth 
        self.labelAlign = labelAlign 
        self.labelAngle = labelAngle 
        self.labelBaseline = labelBaseline 
        self.labelBound = labelBound 
        self.labelColor = labelColor 
        self.labelExpr = labelExpr 
        self.labelFlush = labelFlush 
        self.labelFlushOffset = labelFlushOffset 
        self.labelFont = labelFont 
        self.labelFontSize = labelFontSize 
        self.labelFontStyle = labelFontStyle 
        self.labelFontWeight = labelFontWeight 
        self.labelLimit = labelLimit 
        self.labelLineHeight = labelLineHeight 
        self.labelOffset = labelOffset 
        self.labelOpacity = labelOpacity 
        self.labelOverlap = labelOverlap 
        self.labelPadding = labelPadding 
        self.labelSeparation = labelSeparation 
        self.labels = labels 
        self.maxExtent = maxExtent 
        self.minExtent = minExtent 
        self.offset = offset 
        self.orient = orient 
        self.position = position 
        self.style = style 
        self.tickBand = tickBand 
        self.tickCap = tickCap 
        self.tickColor = tickColor 
        self.tickCount = tickCount 
        self.tickDash = tickDash 
        self.tickDashOffset = tickDashOffset 
        self.tickExtra = tickExtra 
        self.tickMinStep = tickMinStep 
        self.tickOffset = tickOffset 
        self.tickOpacity = tickOpacity 
        self.tickRound = tickRound 
        self.tickSize = tickSize 
        self.tickWidth = tickWidth 
        self.ticks = ticks 
        self.title = title 
        self.titleAlign = titleAlign 
        self.titleAnchor = titleAnchor 
        self.titleAngle = titleAngle 
        self.titleBaseline = titleBaseline 
        self.titleColor = titleColor 
        self.titleFont = titleFont 
        self.titleFontSize = titleFontSize 
        self.titleFontStyle = titleFontStyle 
        self.titleFontWeight = titleFontWeight 
        self.titleLimit = titleLimit 
        self.titleLineHeight = titleLineHeight 
        self.titleOpacity = titleOpacity 
        self.titlePadding = titlePadding 
        self.titleX = titleX 
        self.titleY = titleY 
        self.translate = translate 
        self.values = values 
        self.zindex = zindex 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.bandPosition = try values.decodeOptional(BandPositionChoice.self, forKey: .bandPosition) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.domain = try values.decodeOptional(Bool.self, forKey: .domain) 
        self.domainCap = try values.decodeOptional(DomainCapChoice.self, forKey: .domainCap) 
        self.domainColor = try values.decodeOptional(DomainColorChoice.self, forKey: .domainColor) 
        self.domainDash = try values.decodeOptional(DomainDashChoice.self, forKey: .domainDash) 
        self.domainDashOffset = try values.decodeOptional(DomainDashOffsetChoice.self, forKey: .domainDashOffset) 
        self.domainOpacity = try values.decodeOptional(DomainOpacityChoice.self, forKey: .domainOpacity) 
        self.domainWidth = try values.decodeOptional(DomainWidthChoice.self, forKey: .domainWidth) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.grid = try values.decodeOptional(Bool.self, forKey: .grid) 
        self.gridCap = try values.decodeOptional(GridCapChoice.self, forKey: .gridCap) 
        self.gridColor = try values.decodeOptional(GridColorChoice.self, forKey: .gridColor) 
        self.gridDash = try values.decodeOptional(GridDashChoice.self, forKey: .gridDash) 
        self.gridDashOffset = try values.decodeOptional(GridDashOffsetChoice.self, forKey: .gridDashOffset) 
        self.gridOpacity = try values.decodeOptional(GridOpacityChoice.self, forKey: .gridOpacity) 
        self.gridWidth = try values.decodeOptional(GridWidthChoice.self, forKey: .gridWidth) 
        self.labelAlign = try values.decodeOptional(LabelAlignChoice.self, forKey: .labelAlign) 
        self.labelAngle = try values.decodeOptional(LabelAngleChoice.self, forKey: .labelAngle) 
        self.labelBaseline = try values.decodeOptional(LabelBaselineChoice.self, forKey: .labelBaseline) 
        self.labelBound = try values.decodeOptional(LabelBoundChoice.self, forKey: .labelBound) 
        self.labelColor = try values.decodeOptional(LabelColorChoice.self, forKey: .labelColor) 
        self.labelExpr = try values.decodeOptional(Expr.self, forKey: .labelExpr) 
        self.labelFlush = try values.decodeOptional(LabelFlush.self, forKey: .labelFlush) 
        self.labelFlushOffset = try values.decodeOptional(LabelFlushOffsetChoice.self, forKey: .labelFlushOffset) 
        self.labelFont = try values.decodeOptional(FontName.self, forKey: .labelFont) 
        self.labelFontSize = try values.decodeOptional(LabelFontSizeChoice.self, forKey: .labelFontSize) 
        self.labelFontStyle = try values.decodeOptional(LabelFontStyleChoice.self, forKey: .labelFontStyle) 
        self.labelFontWeight = try values.decodeOptional(LabelFontWeightChoice.self, forKey: .labelFontWeight) 
        self.labelLimit = try values.decodeOptional(LabelLimitChoice.self, forKey: .labelLimit) 
        self.labelLineHeight = try values.decodeOptional(LabelLineHeightChoice.self, forKey: .labelLineHeight) 
        self.labelOffset = try values.decodeOptional(LabelOffsetChoice.self, forKey: .labelOffset) 
        self.labelOpacity = try values.decodeOptional(LabelOpacityChoice.self, forKey: .labelOpacity) 
        self.labelOverlap = try values.decodeOptional(LabelOverlapChoice.self, forKey: .labelOverlap) 
        self.labelPadding = try values.decodeOptional(LabelPaddingChoice.self, forKey: .labelPadding) 
        self.labelSeparation = try values.decodeOptional(LabelSeparationChoice.self, forKey: .labelSeparation) 
        self.labels = try values.decodeOptional(Bool.self, forKey: .labels) 
        self.maxExtent = try values.decodeOptional(MaxExtentChoice.self, forKey: .maxExtent) 
        self.minExtent = try values.decodeOptional(MinExtentChoice.self, forKey: .minExtent) 
        self.offset = try values.decodeOptional(OffsetChoice.self, forKey: .offset) 
        self.orient = try values.decodeOptional(OrientChoice.self, forKey: .orient) 
        self.position = try values.decodeOptional(PositionChoice.self, forKey: .position) 
        self.style = try values.decodeOptional(StyleChoice.self, forKey: .style) 
        self.tickBand = try values.decodeOptional(TickBandChoice.self, forKey: .tickBand) 
        self.tickCap = try values.decodeOptional(TickCapChoice.self, forKey: .tickCap) 
        self.tickColor = try values.decodeOptional(TickColorChoice.self, forKey: .tickColor) 
        self.tickCount = try values.decodeOptional(TickCountChoice.self, forKey: .tickCount) 
        self.tickDash = try values.decodeOptional(TickDashChoice.self, forKey: .tickDash) 
        self.tickDashOffset = try values.decodeOptional(TickDashOffsetChoice.self, forKey: .tickDashOffset) 
        self.tickExtra = try values.decodeOptional(Bool.self, forKey: .tickExtra) 
        self.tickMinStep = try values.decodeOptional(TickMinStepChoice.self, forKey: .tickMinStep) 
        self.tickOffset = try values.decodeOptional(TickOffsetChoice.self, forKey: .tickOffset) 
        self.tickOpacity = try values.decodeOptional(TickOpacityChoice.self, forKey: .tickOpacity) 
        self.tickRound = try values.decodeOptional(Bool.self, forKey: .tickRound) 
        self.tickSize = try values.decodeOptional(TickSizeChoice.self, forKey: .tickSize) 
        self.tickWidth = try values.decodeOptional(TickWidthChoice.self, forKey: .tickWidth) 
        self.ticks = try values.decodeOptional(Bool.self, forKey: .ticks) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.titleAlign = try values.decodeOptional(TitleAlignChoice.self, forKey: .titleAlign) 
        self.titleAnchor = try values.decodeOptional(TitleAnchorChoice.self, forKey: .titleAnchor) 
        self.titleAngle = try values.decodeOptional(TitleAngleChoice.self, forKey: .titleAngle) 
        self.titleBaseline = try values.decodeOptional(TitleBaselineChoice.self, forKey: .titleBaseline) 
        self.titleColor = try values.decodeOptional(TitleColorChoice.self, forKey: .titleColor) 
        self.titleFont = try values.decodeOptional(FontName.self, forKey: .titleFont) 
        self.titleFontSize = try values.decodeOptional(TitleFontSizeChoice.self, forKey: .titleFontSize) 
        self.titleFontStyle = try values.decodeOptional(TitleFontStyleChoice.self, forKey: .titleFontStyle) 
        self.titleFontWeight = try values.decodeOptional(TitleFontWeightChoice.self, forKey: .titleFontWeight) 
        self.titleLimit = try values.decodeOptional(TitleLimitChoice.self, forKey: .titleLimit) 
        self.titleLineHeight = try values.decodeOptional(TitleLineHeightChoice.self, forKey: .titleLineHeight) 
        self.titleOpacity = try values.decodeOptional(TitleOpacityChoice.self, forKey: .titleOpacity) 
        self.titlePadding = try values.decodeOptional(TitlePaddingChoice.self, forKey: .titlePadding) 
        self.titleX = try values.decodeOptional(TitleXChoice.self, forKey: .titleX) 
        self.titleY = try values.decodeOptional(TitleYChoice.self, forKey: .titleY) 
        self.translate = try values.decodeOptional(TranslateChoice.self, forKey: .translate) 
        self.values = try values.decodeOptional(ValuesChoice.self, forKey: .values) 
        self.zindex = try values.decodeOptional(Double.self, forKey: .zindex) 
    }

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias BandPositionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DomainWidthChoice = OneOf<Double>.Or<ExprRef>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Generated by Curio
    public typealias GridCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Generated by Curio
    public typealias GridColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>.Or<ConditionalAxisColor>

    /// Generated by Curio
    public typealias GridDashChoice = OneOf<[Double]>.Or<ExprRef>.Or<ConditionalAxisNumberArray>

    /// Generated by Curio
    public typealias GridDashOffsetChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias GridOpacityChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias GridWidthChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias LabelAlignChoice = OneOf<Align>.Or<ExprRef>.Or<ConditionalAxisLabelAlign>

    /// Generated by Curio
    public typealias LabelAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>.Or<ConditionalAxisLabelBaseline>

    /// Generated by Curio
    public typealias LabelBoundChoice = OneOf<OneOf<Double>.Or<Bool>>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>.Or<ConditionalAxisColor>

    /// Generated by Curio
    public typealias LabelFlush = OneOf<Bool>.Or<Double>

    /// Generated by Curio
    public typealias LabelFlushOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelFontSizeChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias LabelFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>.Or<ConditionalAxisLabelFontStyle>

    /// Generated by Curio
    public typealias LabelFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>.Or<ConditionalAxisLabelFontWeight>

    /// Generated by Curio
    public typealias LabelLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelOffsetChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias LabelOpacityChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
    /// __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log scales; otherwise `false`.
    /// Generated by Curio
    public typealias LabelOverlapChoice = OneOf<LabelOverlap>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelPaddingChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias LabelSeparationChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias MaxExtentChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias MinExtentChoice = OneOf<Double>.Or<ExprRef>

    /// The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.
    /// __Default value:__ derived from the [axis config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset` (`0` by default)
    /// Generated by Curio
    public typealias OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The orientation can be used to further specialize the axis type (e.g., a y-axis oriented towards the right edge of the chart).
    /// __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
    /// Generated by Curio
    public typealias OrientChoice = OneOf<AxisOrient>.Or<ExprRef>

    /// The anchor position of the axis in pixels. For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.
    /// __Default value__: `0`
    /// Generated by Curio
    public typealias PositionChoice = OneOf<Double>.Or<ExprRef>

    /// A string or array of strings indicating the name of custom styles to apply to the axis. A style is a named collection of axis property defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.
    /// __Default value:__ (none) __Note:__ Any specified style will augment the default style. For example, an x-axis mark with `"style": "foo"` will use `config.axisX` and `config.style.foo` (the specified style `"foo"` has higher precedence).
    /// Generated by Curio
    public typealias StyleChoice = OneOrMany<String>

    /// Generated by Curio
    public typealias TickBandChoice = OneOf<LiteralCenterOrExtent>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>.Or<ConditionalAxisColor>

    /// A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the underlying scale's range.
    /// For scales of type `"time"` or `"utc"`, the tick count can instead be a time interval specifier. Legal string values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, an object-valued interval specifier of the form `{"interval": "month", "step": 3}` includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.
    /// __Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)` for y.
    /// Generated by Curio
    public typealias TickCountChoice = OneOf<Double>.Or<TemporalUnit>.Or<TimeIntervalStep>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickDashChoice = OneOf<[Double]>.Or<ExprRef>.Or<ConditionalAxisNumberArray>

    /// Generated by Curio
    public typealias TickDashOffsetChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// The minimum desired step between axis ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value.
    /// Generated by Curio
    public typealias TickMinStepChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickOpacityChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias TickSizeChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias TickWidthChoice = OneOf<Double>.Or<ExprRef>.Or<ConditionalAxisNumber>

    /// Generated by Curio
    public typealias TitleAlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleAnchorChoice = OneOf<TitleAnchor>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    /// Generated by Curio
    public typealias TitleColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitlePaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleXChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleYChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TranslateChoice = OneOf<Double>.Or<ExprRef>

    /// Explicitly set the visible axis tick values.
    /// Generated by Curio
    public typealias ValuesChoice = OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[DateTime]>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aria
        case bandPosition
        case description
        case domain
        case domainCap
        case domainColor
        case domainDash
        case domainDashOffset
        case domainOpacity
        case domainWidth
        case format
        case formatType
        case grid
        case gridCap
        case gridColor
        case gridDash
        case gridDashOffset
        case gridOpacity
        case gridWidth
        case labelAlign
        case labelAngle
        case labelBaseline
        case labelBound
        case labelColor
        case labelExpr
        case labelFlush
        case labelFlushOffset
        case labelFont
        case labelFontSize
        case labelFontStyle
        case labelFontWeight
        case labelLimit
        case labelLineHeight
        case labelOffset
        case labelOpacity
        case labelOverlap
        case labelPadding
        case labelSeparation
        case labels
        case maxExtent
        case minExtent
        case offset
        case orient
        case position
        case style
        case tickBand
        case tickCap
        case tickColor
        case tickCount
        case tickDash
        case tickDashOffset
        case tickExtra
        case tickMinStep
        case tickOffset
        case tickOpacity
        case tickRound
        case tickSize
        case tickWidth
        case ticks
        case title
        case titleAlign
        case titleAnchor
        case titleAngle
        case titleBaseline
        case titleColor
        case titleFont
        case titleFontSize
        case titleFontStyle
        case titleFontWeight
        case titleLimit
        case titleLineHeight
        case titleOpacity
        case titlePadding
        case titleX
        case titleY
        case translate
        case values
        case zindex
        public var keyDescription: String? {
            switch self {
            case .aria: return nil
            case .bandPosition: return nil
            case .description: return nil
            case .domain: return "A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.\n\n__Default value:__ `true`"
            case .domainCap: return nil
            case .domainColor: return nil
            case .domainDash: return nil
            case .domainDashOffset: return nil
            case .domainOpacity: return nil
            case .domainWidth: return nil
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .grid: return "A boolean flag indicating if grid lines should be included as part of the axis\n\n__Default value:__ `true` for [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned; otherwise, `false`."
            case .gridCap: return nil
            case .gridColor: return nil
            case .gridDash: return nil
            case .gridDashOffset: return nil
            case .gridOpacity: return nil
            case .gridWidth: return nil
            case .labelAlign: return nil
            case .labelAngle: return nil
            case .labelBaseline: return nil
            case .labelBound: return nil
            case .labelColor: return nil
            case .labelExpr: return "[Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.\n\n__Note:__ The label text and value can be assessed via the `label` and `value` properties of the axis's backing `datum` object."
            case .labelFlush: return "Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.\n\n__Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`."
            case .labelFlushOffset: return nil
            case .labelFont: return nil
            case .labelFontSize: return nil
            case .labelFontStyle: return nil
            case .labelFontWeight: return nil
            case .labelLimit: return nil
            case .labelLineHeight: return nil
            case .labelOffset: return nil
            case .labelOpacity: return nil
            case .labelOverlap: return "The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `\"parity\"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `\"greedy\"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).\n\n__Default value:__ `true` for non-nominal fields with non-log scales; `\"greedy\"` for log scales; otherwise `false`."
            case .labelPadding: return nil
            case .labelSeparation: return nil
            case .labels: return "A boolean flag indicating if labels should be included as part of the axis.\n\n__Default value:__ `true`."
            case .maxExtent: return nil
            case .minExtent: return nil
            case .offset: return "The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n\n__Default value:__ derived from the [axis config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset` (`0` by default)"
            case .orient: return "The orientation of the axis. One of `\"top\"`, `\"bottom\"`, `\"left\"` or `\"right\"`. The orientation can be used to further specialize the axis type (e.g., a y-axis oriented towards the right edge of the chart).\n\n__Default value:__ `\"bottom\"` for x-axes and `\"left\"` for y-axes."
            case .position: return "The anchor position of the axis in pixels. For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.\n\n__Default value__: `0`"
            case .style: return "A string or array of strings indicating the name of custom styles to apply to the axis. A style is a named collection of axis property defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.\n\n__Default value:__ (none) __Note:__ Any specified style will augment the default style. For example, an x-axis mark with `\"style\": \"foo\"` will use `config.axisX` and `config.style.foo` (the specified style `\"foo\"` has higher precedence)."
            case .tickBand: return nil
            case .tickCap: return nil
            case .tickColor: return nil
            case .tickCount: return "A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.\n\nFor scales of type `\"time\"` or `\"utc\"`, the tick count can instead be a time interval specifier. Legal string values are `\"millisecond\"`, `\"second\"`, `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`. Alternatively, an object-valued interval specifier of the form `{\"interval\": \"month\", \"step\": 3}` includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.\n\n__Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)` for y."
            case .tickDash: return nil
            case .tickDashOffset: return nil
            case .tickExtra: return "Boolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for `band` scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with `\"bandPosition\": 1` and an axis `\"padding\"` value of `0`."
            case .tickMinStep: return "The minimum desired step between axis ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value."
            case .tickOffset: return nil
            case .tickOpacity: return nil
            case .tickRound: return "Boolean flag indicating if pixel position values should be rounded to the nearest integer.\n\n__Default value:__ `true`"
            case .tickSize: return nil
            case .tickWidth: return nil
            case .ticks: return "Boolean value that determines whether the axis should include ticks.\n\n__Default value:__ `true`"
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .titleAlign: return nil
            case .titleAnchor: return nil
            case .titleAngle: return nil
            case .titleBaseline: return nil
            case .titleColor: return nil
            case .titleFont: return nil
            case .titleFontSize: return nil
            case .titleFontStyle: return nil
            case .titleFontWeight: return nil
            case .titleLimit: return nil
            case .titleLineHeight: return nil
            case .titleOpacity: return nil
            case .titlePadding: return nil
            case .titleX: return nil
            case .titleY: return nil
            case .translate: return nil
            case .values: return "Explicitly set the visible axis tick values."
            case .zindex: return "A non-negative integer indicating the z-index of the axis. If zindex is 0, axes should be drawn behind all chart elements. To put them in front, set `zindex` to `1` or more.\n\n__Default value:__ `0` (behind the marks)."
             } 
        }

        public typealias CodingOwner = AxisDef
    }
}

/// Generated by Curio
public struct AxisResolveMap : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var x: ResolveMode?
    public var y: ResolveMode?
    public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y]

    public init(x: ResolveMode? = nil, y: ResolveMode? = nil) {
        self.x = x 
        self.y = y 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.x = try values.decodeOptional(ResolveMode.self, forKey: .x) 
        self.y = try values.decodeOptional(ResolveMode.self, forKey: .y) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case x
        case y
        public var keyDescription: String? {
            switch self {
            case .x: return nil
            case .y: return nil
             } 
        }

        public typealias CodingOwner = AxisResolveMap
    }
}

/// Generated by Curio
public struct BarConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var align: AlignChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    public var ariaRole: AriaRoleChoice?
    public var ariaRoleDescription: AriaRoleDescriptionChoice?
    public var aspect: AspectChoice?
    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var baseline: BaselineChoice?
    /// Offset between bars for binned field. The ideal value for this is either 0 (preferred by statisticians) or 1 (Vega-Lite default, D3 example style).
    /// __Default value:__ `1`
    public var binSpacing: Double?
    public var blend: BlendChoice?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    /// The default size of the bars on continuous scales.
    /// __Default value:__ `5`
    public var continuousBandSize: Double?
    public var cornerRadius: CornerRadiusChoice?
    public var cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice?
    public var cornerRadiusBottomRight: CornerRadiusBottomRightChoice?
    /// - For vertical bars, top-left and top-right corner radius.
    /// - For horizontal bars, top-right and bottom-right corner radius.
    public var cornerRadiusEnd: CornerRadiusEndChoice?
    public var cornerRadiusTopLeft: CornerRadiusTopLeftChoice?
    public var cornerRadiusTopRight: CornerRadiusTopRightChoice?
    public var cursor: CursorChoice?
    public var description: DescriptionChoice?
    public var dir: DirChoice?
    /// The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars.
    public var discreteBandSize: DiscreteBandSizeChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var ellipsis: EllipsisChoice?
    public var endAngle: EndAngleChoice?
    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// Whether the mark's color should be used as fill color instead of stroke color.
    /// __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.
    /// __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    public var filled: Bool?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var height: HeightChoice?
    public var href: HrefChoice?
    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    public var innerRadius: InnerRadiusChoice?
    public var interpolate: InterpolateChoice?
    /// Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
    /// - If set to `"filter"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).
    /// - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
    public var invalid: Invalid?
    public var limit: LimitChoice?
    public var lineBreak: LineBreakChoice?
    public var lineHeight: LineHeightChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources.
    public var order: Order?
    /// The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored.
    public var orient: Orientation?
    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    public var outerRadius: OuterRadiusChoice?
    public var padAngle: PadAngleChoice?
    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    public var radius: RadiusChoice?
    /// The secondary (inner) radius in pixels of arc marks.
    public var radius2: Radius2Choice?
    public var shape: ShapeChoice?
    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    public var size: SizeChoice?
    public var smooth: SmoothChoice?
    public var startAngle: StartAngleChoice?
    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOffset: StrokeOffsetChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    public var tension: TensionChoice?
    public var text: TextChoice?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaChoice?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Choice?
    /// Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step.
    public var timeUnitBandPosition: Double?
    /// Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step.
    public var timeUnitBandSize: Double?
    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    public var tooltip: TooltipChoice?
    public var url: UrlChoice?
    public var width: WidthChoice?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XChoice?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Choice?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YChoice?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Choice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.aspect as KeyPath, \Self.baseline as KeyPath, \Self.binSpacing as KeyPath, \Self.blend as KeyPath, \Self.color as KeyPath, \Self.continuousBandSize as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusEnd as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cursor as KeyPath, \Self.description as KeyPath, \Self.dir as KeyPath, \Self.discreteBandSize as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.ellipsis as KeyPath, \Self.endAngle as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.filled as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.height as KeyPath, \Self.href as KeyPath, \Self.innerRadius as KeyPath, \Self.interpolate as KeyPath, \Self.invalid as KeyPath, \Self.limit as KeyPath, \Self.lineBreak as KeyPath, \Self.lineHeight as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.orient as KeyPath, \Self.outerRadius as KeyPath, \Self.padAngle as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.smooth as KeyPath, \Self.startAngle as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.tension as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.timeUnitBandPosition as KeyPath, \Self.timeUnitBandSize as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.width as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.binSpacing as KeyPath : CodingKeys.binSpacing, \Self.blend as KeyPath : CodingKeys.blend, \Self.color as KeyPath : CodingKeys.color, \Self.continuousBandSize as KeyPath : CodingKeys.continuousBandSize, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusEnd as KeyPath : CodingKeys.cornerRadiusEnd, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.description as KeyPath : CodingKeys.description, \Self.dir as KeyPath : CodingKeys.dir, \Self.discreteBandSize as KeyPath : CodingKeys.discreteBandSize, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.endAngle as KeyPath : CodingKeys.endAngle, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.filled as KeyPath : CodingKeys.filled, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.height as KeyPath : CodingKeys.height, \Self.href as KeyPath : CodingKeys.href, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.invalid as KeyPath : CodingKeys.invalid, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.orient as KeyPath : CodingKeys.orient, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.startAngle as KeyPath : CodingKeys.startAngle, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.tension as KeyPath : CodingKeys.tension, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.timeUnitBandPosition as KeyPath : CodingKeys.timeUnitBandPosition, \Self.timeUnitBandSize as KeyPath : CodingKeys.timeUnitBandSize, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.width as KeyPath : CodingKeys.width, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2]

    public init(align: AlignChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, ariaRole: AriaRoleChoice? = nil, ariaRoleDescription: AriaRoleDescriptionChoice? = nil, aspect: AspectChoice? = nil, baseline: BaselineChoice? = nil, binSpacing: Double? = nil, blend: BlendChoice? = nil, color: ColorChoice? = nil, continuousBandSize: Double? = nil, cornerRadius: CornerRadiusChoice? = nil, cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice? = nil, cornerRadiusBottomRight: CornerRadiusBottomRightChoice? = nil, cornerRadiusEnd: CornerRadiusEndChoice? = nil, cornerRadiusTopLeft: CornerRadiusTopLeftChoice? = nil, cornerRadiusTopRight: CornerRadiusTopRightChoice? = nil, cursor: CursorChoice? = nil, description: DescriptionChoice? = nil, dir: DirChoice? = nil, discreteBandSize: DiscreteBandSizeChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, ellipsis: EllipsisChoice? = nil, endAngle: EndAngleChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, filled: Bool? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, height: HeightChoice? = nil, href: HrefChoice? = nil, innerRadius: InnerRadiusChoice? = nil, interpolate: InterpolateChoice? = nil, invalid: Invalid? = nil, limit: LimitChoice? = nil, lineBreak: LineBreakChoice? = nil, lineHeight: LineHeightChoice? = nil, opacity: OpacityChoice? = nil, order: Order? = nil, orient: Orientation? = nil, outerRadius: OuterRadiusChoice? = nil, padAngle: PadAngleChoice? = nil, radius: RadiusChoice? = nil, radius2: Radius2Choice? = nil, shape: ShapeChoice? = nil, size: SizeChoice? = nil, smooth: SmoothChoice? = nil, startAngle: StartAngleChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOffset: StrokeOffsetChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, tension: TensionChoice? = nil, text: TextChoice? = nil, theta: ThetaChoice? = nil, theta2: Theta2Choice? = nil, timeUnitBandPosition: Double? = nil, timeUnitBandSize: Double? = nil, tooltip: TooltipChoice? = nil, url: UrlChoice? = nil, width: WidthChoice? = nil, x: XChoice? = nil, x2: X2Choice? = nil, y: YChoice? = nil, y2: Y2Choice? = nil) {
        self.align = align 
        self.angle = angle 
        self.aria = aria 
        self.ariaRole = ariaRole 
        self.ariaRoleDescription = ariaRoleDescription 
        self.aspect = aspect 
        self.baseline = baseline 
        self.binSpacing = binSpacing 
        self.blend = blend 
        self.color = color 
        self.continuousBandSize = continuousBandSize 
        self.cornerRadius = cornerRadius 
        self.cornerRadiusBottomLeft = cornerRadiusBottomLeft 
        self.cornerRadiusBottomRight = cornerRadiusBottomRight 
        self.cornerRadiusEnd = cornerRadiusEnd 
        self.cornerRadiusTopLeft = cornerRadiusTopLeft 
        self.cornerRadiusTopRight = cornerRadiusTopRight 
        self.cursor = cursor 
        self.description = description 
        self.dir = dir 
        self.discreteBandSize = discreteBandSize 
        self.dx = dx 
        self.dy = dy 
        self.ellipsis = ellipsis 
        self.endAngle = endAngle 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.filled = filled 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.height = height 
        self.href = href 
        self.innerRadius = innerRadius 
        self.interpolate = interpolate 
        self.invalid = invalid 
        self.limit = limit 
        self.lineBreak = lineBreak 
        self.lineHeight = lineHeight 
        self.opacity = opacity 
        self.order = order 
        self.orient = orient 
        self.outerRadius = outerRadius 
        self.padAngle = padAngle 
        self.radius = radius 
        self.radius2 = radius2 
        self.shape = shape 
        self.size = size 
        self.smooth = smooth 
        self.startAngle = startAngle 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOffset = strokeOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.tension = tension 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.timeUnitBandPosition = timeUnitBandPosition 
        self.timeUnitBandSize = timeUnitBandSize 
        self.tooltip = tooltip 
        self.url = url 
        self.width = width 
        self.x = x 
        self.x2 = x2 
        self.y = y 
        self.y2 = y2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.ariaRole = try values.decodeOptional(AriaRoleChoice.self, forKey: .ariaRole) 
        self.ariaRoleDescription = try values.decodeOptional(AriaRoleDescriptionChoice.self, forKey: .ariaRoleDescription) 
        self.aspect = try values.decodeOptional(AspectChoice.self, forKey: .aspect) 
        self.baseline = try values.decodeOptional(BaselineChoice.self, forKey: .baseline) 
        self.binSpacing = try values.decodeOptional(Double.self, forKey: .binSpacing) 
        self.blend = try values.decodeOptional(BlendChoice.self, forKey: .blend) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.continuousBandSize = try values.decodeOptional(Double.self, forKey: .continuousBandSize) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cornerRadiusBottomLeft = try values.decodeOptional(CornerRadiusBottomLeftChoice.self, forKey: .cornerRadiusBottomLeft) 
        self.cornerRadiusBottomRight = try values.decodeOptional(CornerRadiusBottomRightChoice.self, forKey: .cornerRadiusBottomRight) 
        self.cornerRadiusEnd = try values.decodeOptional(CornerRadiusEndChoice.self, forKey: .cornerRadiusEnd) 
        self.cornerRadiusTopLeft = try values.decodeOptional(CornerRadiusTopLeftChoice.self, forKey: .cornerRadiusTopLeft) 
        self.cornerRadiusTopRight = try values.decodeOptional(CornerRadiusTopRightChoice.self, forKey: .cornerRadiusTopRight) 
        self.cursor = try values.decodeOptional(CursorChoice.self, forKey: .cursor) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.dir = try values.decodeOptional(DirChoice.self, forKey: .dir) 
        self.discreteBandSize = try values.decodeOptional(DiscreteBandSizeChoice.self, forKey: .discreteBandSize) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.ellipsis = try values.decodeOptional(EllipsisChoice.self, forKey: .ellipsis) 
        self.endAngle = try values.decodeOptional(EndAngleChoice.self, forKey: .endAngle) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.filled = try values.decodeOptional(Bool.self, forKey: .filled) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.href = try values.decodeOptional(HrefChoice.self, forKey: .href) 
        self.innerRadius = try values.decodeOptional(InnerRadiusChoice.self, forKey: .innerRadius) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.invalid = try values.decodeOptional(Invalid.self, forKey: .invalid) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.order = try values.decodeOptional(Order.self, forKey: .order) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outerRadius = try values.decodeOptional(OuterRadiusChoice.self, forKey: .outerRadius) 
        self.padAngle = try values.decodeOptional(PadAngleChoice.self, forKey: .padAngle) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Choice.self, forKey: .radius2) 
        self.shape = try values.decodeOptional(ShapeChoice.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.smooth = try values.decodeOptional(SmoothChoice.self, forKey: .smooth) 
        self.startAngle = try values.decodeOptional(StartAngleChoice.self, forKey: .startAngle) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOffset = try values.decodeOptional(StrokeOffsetChoice.self, forKey: .strokeOffset) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.tension = try values.decodeOptional(TensionChoice.self, forKey: .tension) 
        self.text = try values.decodeOptional(TextChoice.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaChoice.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Choice.self, forKey: .theta2) 
        self.timeUnitBandPosition = try values.decodeOptional(Double.self, forKey: .timeUnitBandPosition) 
        self.timeUnitBandSize = try values.decodeOptional(Double.self, forKey: .timeUnitBandSize) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlChoice.self, forKey: .url) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
        self.x = try values.decodeOptional(XChoice.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Choice.self, forKey: .x2) 
        self.y = try values.decodeOptional(YChoice.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Choice.self, forKey: .y2) 
    }

    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleDescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AspectChoice = OneOf<Bool>.Or<ExprRef>

    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias BaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias BlendChoice = OneOf<Blend>.Or<ExprRef>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// - For vertical bars, top-left and top-right corner radius.
    /// - For horizontal bars, top-right and bottom-right corner radius.
    /// Generated by Curio
    public typealias CornerRadiusEndChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CursorChoice = OneOf<Cursor>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DirChoice = OneOf<TextDirection>.Or<ExprRef>

    /// The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars.
    /// Generated by Curio
    public typealias DiscreteBandSizeChoice = OneOf<Double>.Or<RelativeBandSize>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias EllipsisChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias EndAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias HrefChoice = OneOf<URI>.Or<ExprRef>

    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    /// Generated by Curio
    public typealias InnerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<Interpolate>.Or<ExprRef>

    /// Generated by Curio
    public typealias Invalid = Nullable<String>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias Order = Nullable<Bool>

    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    /// Generated by Curio
    public typealias OuterRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PadAngleChoice = OneOf<Double>.Or<ExprRef>

    /// The secondary (inner) radius in pixels of arc marks.
    /// Generated by Curio
    public typealias Radius2Choice = OneOf<Double>.Or<ExprRef>

    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ShapeChoice = OneOf<OneOf<SymbolShape>.Or<String>>.Or<ExprRef>

    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    /// Generated by Curio
    public typealias SizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SmoothChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias StartAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TensionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    /// Generated by Curio
    public typealias Theta2Choice = OneOf<Double>.Or<ExprRef>

    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    /// Generated by Curio
    public typealias ThetaChoice = OneOf<Double>.Or<ExprRef>

    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<Double>.Or<String>.Or<Bool>.Or<TooltipContent>.Or<ExprRef>>

    /// Generated by Curio
    public typealias UrlChoice = OneOf<URI>.Or<ExprRef>

    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<ExprRef>

    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias X2Choice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias XChoice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias Y2Choice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias YChoice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case angle
        case aria
        case ariaRole
        case ariaRoleDescription
        case aspect
        case baseline
        case binSpacing
        case blend
        case color
        case continuousBandSize
        case cornerRadius
        case cornerRadiusBottomLeft
        case cornerRadiusBottomRight
        case cornerRadiusEnd
        case cornerRadiusTopLeft
        case cornerRadiusTopRight
        case cursor
        case description
        case dir
        case discreteBandSize
        case dx
        case dy
        case ellipsis
        case endAngle
        case fill
        case fillOpacity
        case filled
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case height
        case href
        case innerRadius
        case interpolate
        case invalid
        case limit
        case lineBreak
        case lineHeight
        case opacity
        case order
        case orient
        case outerRadius
        case padAngle
        case radius
        case radius2
        case shape
        case size
        case smooth
        case startAngle
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOffset
        case strokeOpacity
        case strokeWidth
        case tension
        case text
        case theta
        case theta2
        case timeUnitBandPosition
        case timeUnitBandSize
        case tooltip
        case url
        case width
        case x
        case x2
        case y
        case y2
        public var keyDescription: String? {
            switch self {
            case .align: return "The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `\"left\"`, `\"right\"`, `\"center\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .angle: return nil
            case .aria: return nil
            case .ariaRole: return nil
            case .ariaRoleDescription: return nil
            case .aspect: return nil
            case .baseline: return "For text marks, the vertical text baseline. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, `\"line-bottom\"`, or an expression reference that provides one of the valid values. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.\n\nFor range marks, the vertical alignment of the marks. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .binSpacing: return "Offset between bars for binned field. The ideal value for this is either 0 (preferred by statisticians) or 1 (Vega-Lite default, D3 example style).\n\n__Default value:__ `1`"
            case .blend: return nil
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .continuousBandSize: return "The default size of the bars on continuous scales.\n\n__Default value:__ `5`"
            case .cornerRadius: return nil
            case .cornerRadiusBottomLeft: return nil
            case .cornerRadiusBottomRight: return nil
            case .cornerRadiusEnd: return "- For vertical bars, top-left and top-right corner radius.\n\n- For horizontal bars, top-right and bottom-right corner radius."
            case .cornerRadiusTopLeft: return nil
            case .cornerRadiusTopRight: return nil
            case .cursor: return nil
            case .description: return nil
            case .dir: return nil
            case .discreteBandSize: return "The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars."
            case .dx: return nil
            case .dy: return nil
            case .ellipsis: return nil
            case .endAngle: return nil
            case .fill: return "Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.\n\n__Default value:__ (None)"
            case .fillOpacity: return nil
            case .filled: return "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.\n\n__Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config)."
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .height: return nil
            case .href: return nil
            case .innerRadius: return "The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`."
            case .interpolate: return nil
            case .invalid: return "Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes."
            case .limit: return nil
            case .lineBreak: return nil
            case .lineHeight: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .order: return "For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources."
            case .orient: return "The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored."
            case .outerRadius: return "The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`."
            case .padAngle: return nil
            case .radius: return "For arc mark, the primary (outer) radius in pixels.\n\nFor text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties."
            case .radius2: return "The secondary (inner) radius in pixels of arc marks."
            case .shape: return nil
            case .size: return "Default size for marks.\n- For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.\n- For `bar`, this represents the band size of the bar, in pixels.\n- For `text`, this represents the font size, in pixels.\n\n__Default value:__\n- `30` for point, circle, square marks; width/height's `step`\n- `2` for bar marks with discrete dimensions;\n- `5` for bar marks with continuous dimensions;\n- `11` for text marks."
            case .smooth: return nil
            case .startAngle: return nil
            case .stroke: return "Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.\n\n__Default value:__ (None)"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOffset: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .tension: return nil
            case .text: return nil
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .timeUnitBandPosition: return "Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step."
            case .timeUnitBandSize: return "Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step."
            case .tooltip: return "The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n\n- If `tooltip` is `true` or `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n- If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n- If set to `null` or `false`, then no tooltip will be used.\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.\n\n__Default value:__ `null`"
            case .url: return nil
            case .width: return nil
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
             } 
        }

        public typealias CodingOwner = BarConfig
    }
}

/// Generated by Curio
public struct BaseTitleNoValueRefs : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Horizontal text alignment for title text. One of `"left"`, `"center"`, or `"right"`.
    public var align: Align?
    public var anchor: AnchorChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    /// Vertical text baseline for title and subtitle text. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the *lineHeight* rather than *fontSize* alone.
    public var baseline: TextBaseline?
    public var color: ColorChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var frame: FrameChoice?
    public var limit: LimitChoice?
    public var lineHeight: LineHeightChoice?
    public var offset: OffsetChoice?
    public var orient: OrientChoice?
    public var subtitleColor: SubtitleColorChoice?
    public var subtitleFont: FontName?
    public var subtitleFontSize: SubtitleFontSizeChoice?
    public var subtitleFontStyle: SubtitleFontStyleChoice?
    public var subtitleFontWeight: SubtitleFontWeightChoice?
    public var subtitleLineHeight: SubtitleLineHeightChoice?
    public var subtitlePadding: SubtitlePaddingChoice?
    public var zindex: ZindexChoice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.anchor as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.baseline as KeyPath, \Self.color as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.frame as KeyPath, \Self.limit as KeyPath, \Self.lineHeight as KeyPath, \Self.offset as KeyPath, \Self.orient as KeyPath, \Self.subtitleColor as KeyPath, \Self.subtitleFont as KeyPath, \Self.subtitleFontSize as KeyPath, \Self.subtitleFontStyle as KeyPath, \Self.subtitleFontWeight as KeyPath, \Self.subtitleLineHeight as KeyPath, \Self.subtitlePadding as KeyPath, \Self.zindex as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.anchor as KeyPath : CodingKeys.anchor, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.color as KeyPath : CodingKeys.color, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.frame as KeyPath : CodingKeys.frame, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.offset as KeyPath : CodingKeys.offset, \Self.orient as KeyPath : CodingKeys.orient, \Self.subtitleColor as KeyPath : CodingKeys.subtitleColor, \Self.subtitleFont as KeyPath : CodingKeys.subtitleFont, \Self.subtitleFontSize as KeyPath : CodingKeys.subtitleFontSize, \Self.subtitleFontStyle as KeyPath : CodingKeys.subtitleFontStyle, \Self.subtitleFontWeight as KeyPath : CodingKeys.subtitleFontWeight, \Self.subtitleLineHeight as KeyPath : CodingKeys.subtitleLineHeight, \Self.subtitlePadding as KeyPath : CodingKeys.subtitlePadding, \Self.zindex as KeyPath : CodingKeys.zindex]

    public init(align: Align? = nil, anchor: AnchorChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, baseline: TextBaseline? = nil, color: ColorChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, frame: FrameChoice? = nil, limit: LimitChoice? = nil, lineHeight: LineHeightChoice? = nil, offset: OffsetChoice? = nil, orient: OrientChoice? = nil, subtitleColor: SubtitleColorChoice? = nil, subtitleFont: FontName? = nil, subtitleFontSize: SubtitleFontSizeChoice? = nil, subtitleFontStyle: SubtitleFontStyleChoice? = nil, subtitleFontWeight: SubtitleFontWeightChoice? = nil, subtitleLineHeight: SubtitleLineHeightChoice? = nil, subtitlePadding: SubtitlePaddingChoice? = nil, zindex: ZindexChoice? = nil) {
        self.align = align 
        self.anchor = anchor 
        self.angle = angle 
        self.aria = aria 
        self.baseline = baseline 
        self.color = color 
        self.dx = dx 
        self.dy = dy 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.frame = frame 
        self.limit = limit 
        self.lineHeight = lineHeight 
        self.offset = offset 
        self.orient = orient 
        self.subtitleColor = subtitleColor 
        self.subtitleFont = subtitleFont 
        self.subtitleFontSize = subtitleFontSize 
        self.subtitleFontStyle = subtitleFontStyle 
        self.subtitleFontWeight = subtitleFontWeight 
        self.subtitleLineHeight = subtitleLineHeight 
        self.subtitlePadding = subtitlePadding 
        self.zindex = zindex 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(Align.self, forKey: .align) 
        self.anchor = try values.decodeOptional(AnchorChoice.self, forKey: .anchor) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.baseline = try values.decodeOptional(TextBaseline.self, forKey: .baseline) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.frame = try values.decodeOptional(FrameChoice.self, forKey: .frame) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.offset = try values.decodeOptional(OffsetChoice.self, forKey: .offset) 
        self.orient = try values.decodeOptional(OrientChoice.self, forKey: .orient) 
        self.subtitleColor = try values.decodeOptional(SubtitleColorChoice.self, forKey: .subtitleColor) 
        self.subtitleFont = try values.decodeOptional(FontName.self, forKey: .subtitleFont) 
        self.subtitleFontSize = try values.decodeOptional(SubtitleFontSizeChoice.self, forKey: .subtitleFontSize) 
        self.subtitleFontStyle = try values.decodeOptional(SubtitleFontStyleChoice.self, forKey: .subtitleFontStyle) 
        self.subtitleFontWeight = try values.decodeOptional(SubtitleFontWeightChoice.self, forKey: .subtitleFontWeight) 
        self.subtitleLineHeight = try values.decodeOptional(SubtitleLineHeightChoice.self, forKey: .subtitleLineHeight) 
        self.subtitlePadding = try values.decodeOptional(SubtitlePaddingChoice.self, forKey: .subtitlePadding) 
        self.zindex = try values.decodeOptional(ZindexChoice.self, forKey: .zindex) 
    }

    /// Generated by Curio
    public typealias AnchorChoice = OneOf<TitleAnchor>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias ColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias FrameChoice = OneOf<OneOf<TitleFrame>.Or<String>>.Or<ExprRef>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias OrientChoice = OneOf<TitleOrient>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitlePaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ZindexChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case anchor
        case angle
        case aria
        case baseline
        case color
        case dx
        case dy
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case frame
        case limit
        case lineHeight
        case offset
        case orient
        case subtitleColor
        case subtitleFont
        case subtitleFontSize
        case subtitleFontStyle
        case subtitleFontWeight
        case subtitleLineHeight
        case subtitlePadding
        case zindex
        public var keyDescription: String? {
            switch self {
            case .align: return "Horizontal text alignment for title text. One of `\"left\"`, `\"center\"`, or `\"right\"`."
            case .anchor: return nil
            case .angle: return nil
            case .aria: return nil
            case .baseline: return "Vertical text baseline for title and subtitle text. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, or `\"line-bottom\"`. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the *lineHeight* rather than *fontSize* alone."
            case .color: return nil
            case .dx: return nil
            case .dy: return nil
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .frame: return nil
            case .limit: return nil
            case .lineHeight: return nil
            case .offset: return nil
            case .orient: return nil
            case .subtitleColor: return nil
            case .subtitleFont: return nil
            case .subtitleFontSize: return nil
            case .subtitleFontStyle: return nil
            case .subtitleFontWeight: return nil
            case .subtitleLineHeight: return nil
            case .subtitlePadding: return nil
            case .zindex: return nil
             } 
        }

        public typealias CodingOwner = BaseTitleNoValueRefs
    }
}

public struct BinExtent : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<[Double]>.Or<ParameterExtent>

    public init(rawValue: OneOf<[Double]>.Or<ParameterExtent>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<[Double]>.Or<ParameterExtent>) {
        self.rawValue = rawValue 
    }
}

/// Binning properties or boolean flag for determining whether to bin data or not.
/// Generated by Curio
public struct BinParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A value in the binned domain at which to anchor the bins, shifting the bin boundaries if necessary to ensure that a boundary aligns with the anchor value.
    /// __Default value:__ the minimum bin extent value
    public var anchor: Double?
    /// The number base to use for automatic bin determination (default is base 10).
    /// __Default value:__ `10`
    public var base: Double?
    /// When set to `true`, Vega-Lite treats the input data as already binned.
    public var binned: Bool?
    /// Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.
    /// __Default value:__ `[5, 2]`
    public var divide: [DivideItem]?
    /// A two-element (`[min, max]`) array indicating the range of desired bin values.
    public var extent: BinExtent?
    /// Maximum number of bins.
    /// __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels
    public var maxbins: Double?
    /// A minimum allowable step size (particularly useful for integer values).
    public var minstep: Double?
    /// If true, attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.
    /// __Default value:__ `true`
    public var nice: Bool?
    /// An exact step size to use between bins.
    /// __Note:__ If provided, options such as maxbins will be ignored.
    public var step: Double?
    /// An array of allowable step sizes to choose from.
    public var steps: [StepsItem]?
    public static let codingKeyPaths = (\Self.anchor as KeyPath, \Self.base as KeyPath, \Self.binned as KeyPath, \Self.divide as KeyPath, \Self.extent as KeyPath, \Self.maxbins as KeyPath, \Self.minstep as KeyPath, \Self.nice as KeyPath, \Self.step as KeyPath, \Self.steps as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.anchor as KeyPath : CodingKeys.anchor, \Self.base as KeyPath : CodingKeys.base, \Self.binned as KeyPath : CodingKeys.binned, \Self.divide as KeyPath : CodingKeys.divide, \Self.extent as KeyPath : CodingKeys.extent, \Self.maxbins as KeyPath : CodingKeys.maxbins, \Self.minstep as KeyPath : CodingKeys.minstep, \Self.nice as KeyPath : CodingKeys.nice, \Self.step as KeyPath : CodingKeys.step, \Self.steps as KeyPath : CodingKeys.steps]

    public init(anchor: Double? = nil, base: Double? = nil, binned: Bool? = nil, divide: [DivideItem]? = nil, extent: BinExtent? = nil, maxbins: Double? = nil, minstep: Double? = nil, nice: Bool? = nil, step: Double? = nil, steps: [StepsItem]? = nil) {
        self.anchor = anchor 
        self.base = base 
        self.binned = binned 
        self.divide = divide 
        self.extent = extent 
        self.maxbins = maxbins 
        self.minstep = minstep 
        self.nice = nice 
        self.step = step 
        self.steps = steps 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.anchor = try values.decodeOptional(Double.self, forKey: .anchor) 
        self.base = try values.decodeOptional(Double.self, forKey: .base) 
        self.binned = try values.decodeOptional(Bool.self, forKey: .binned) 
        self.divide = try values.decodeOptional([DivideItem].self, forKey: .divide) 
        self.extent = try values.decodeOptional(BinExtent.self, forKey: .extent) 
        self.maxbins = try values.decodeOptional(Double.self, forKey: .maxbins) 
        self.minstep = try values.decodeOptional(Double.self, forKey: .minstep) 
        self.nice = try values.decodeOptional(Bool.self, forKey: .nice) 
        self.step = try values.decodeOptional(Double.self, forKey: .step) 
        self.steps = try values.decodeOptional([StepsItem].self, forKey: .steps) 
    }

    public typealias DivideItem = Double

    public typealias StepsItem = Double

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case anchor
        case base
        case binned
        case divide
        case extent
        case maxbins
        case minstep
        case nice
        case step
        case steps
        public var keyDescription: String? {
            switch self {
            case .anchor: return "A value in the binned domain at which to anchor the bins, shifting the bin boundaries if necessary to ensure that a boundary aligns with the anchor value.\n\n__Default value:__ the minimum bin extent value"
            case .base: return "The number base to use for automatic bin determination (default is base 10).\n\n__Default value:__ `10`"
            case .binned: return "When set to `true`, Vega-Lite treats the input data as already binned."
            case .divide: return "Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n\n__Default value:__ `[5, 2]`"
            case .extent: return "A two-element (`[min, max]`) array indicating the range of desired bin values."
            case .maxbins: return "Maximum number of bins.\n\n__Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels"
            case .minstep: return "A minimum allowable step size (particularly useful for integer values)."
            case .nice: return "If true, attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.\n\n__Default value:__ `true`"
            case .step: return "An exact step size to use between bins.\n\n__Note:__ If provided, options such as maxbins will be ignored."
            case .steps: return "An array of allowable step sizes to choose from."
             } 
        }

        public typealias CodingOwner = BinParams
    }
}

/// Generated by Curio
public struct BinTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output fields at which to write the start and end bin values. This can be either a string or an array of strings with two elements denoting the name for the fields for bin start and bin end respectively. If a single string (e.g., `"val"`) is provided, the end field will be `"val_end"`.
    public var `as`: AsChoice
    /// An object indicating bin properties, or simply `true` for using default bin parameters.
    public var bin: BinChoice
    /// The data field to bin.
    public var field: FieldName
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field]

    public init(id: TransformId? = nil, `as`: AsChoice, bin: BinChoice, field: FieldName) {
        self.id = id 
        self.`as` = `as` 
        self.bin = bin 
        self.field = field 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decode(AsChoice.self, forKey: .`as`) 
        self.bin = try values.decode(BinChoice.self, forKey: .bin) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
    }

    /// The output fields at which to write the start and end bin values. This can be either a string or an array of strings with two elements denoting the name for the fields for bin start and bin end respectively. If a single string (e.g., `"val"`) is provided, the end field will be `"val_end"`.
    /// Generated by Curio
    public typealias AsChoice = OneOrMany<FieldName>

    /// An object indicating bin properties, or simply `true` for using default bin parameters.
    /// Generated by Curio
    public typealias BinChoice = OneOf<Bool>.Or<BinParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case bin
        case field
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output fields at which to write the start and end bin values. This can be either a string or an array of strings with two elements denoting the name for the fields for bin start and bin end respectively. If a single string (e.g., `\"val\"`) is provided, the end field will be `\"val_end\"`."
            case .bin: return "An object indicating bin properties, or simply `true` for using default bin parameters."
            case .field: return "The data field to bin."
             } 
        }

        public typealias CodingOwner = BinTransform
    }
}

/// Generated by Curio
public struct BindCheckbox : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    public var debounce: Double?
    /// An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view.
    public var element: Element?
    public var input: LiteralCheckbox
    /// By default, the signal name is used to label input elements. This `name` property can be used instead to specify a custom label for the bound signal.
    public var name: String?
    public static let codingKeyPaths = (\Self.debounce as KeyPath, \Self.element as KeyPath, \Self.input as KeyPath, \Self.name as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.debounce as KeyPath : CodingKeys.debounce, \Self.element as KeyPath : CodingKeys.element, \Self.input as KeyPath : CodingKeys.input, \Self.name as KeyPath : CodingKeys.name]

    public init(debounce: Double? = nil, element: Element? = nil, input: LiteralCheckbox = .checkbox, name: String? = nil) {
        self.debounce = debounce 
        self.element = element 
        self.input = input 
        self.name = name 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
        self.element = try values.decodeOptional(Element.self, forKey: .element) 
        self.input = try values.decode(LiteralCheckbox.self, forKey: .input) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case debounce
        case element
        case input
        case name
        public var keyDescription: String? {
            switch self {
            case .debounce: return "If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired."
            case .element: return "An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view."
            case .input: return nil
            case .name: return "By default, the signal name is used to label input elements. This `name` property can be used instead to specify a custom label for the bound signal."
             } 
        }

        public typealias CodingOwner = BindCheckbox
    }

    /// Generated by Curio
    public enum LiteralCheckbox : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case checkbox
    }
}

public struct BindControl : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<BindCheckbox>.Or<BindRadioSelect>.Or<BindRange>.Or<BindInput>.Or<BindDirect>

    public init(rawValue: OneOf<BindCheckbox>.Or<BindRadioSelect>.Or<BindRange>.Or<BindInput>.Or<BindDirect>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<BindCheckbox>.Or<BindRadioSelect>.Or<BindRange>.Or<BindInput>.Or<BindDirect>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct BindDirect : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    public var debounce: Double?
    /// An input element that exposes a _value_ property and supports the [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) interface, or a CSS selector string to such an element. When the element updates and dispatches an event, the _value_ property will be used as the new, bound signal value. When the signal updates independent of the element, the _value_ property will be set to the signal value and a new event will be dispatched on the element.
    public var element: ElementChoice
    /// The event (default `"input"`) to listen for to track changes on the external element.
    public var event: String?
    public static let codingKeyPaths = (\Self.debounce as KeyPath, \Self.element as KeyPath, \Self.event as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.debounce as KeyPath : CodingKeys.debounce, \Self.element as KeyPath : CodingKeys.element, \Self.event as KeyPath : CodingKeys.event]

    public init(debounce: Double? = nil, element: ElementChoice, event: String? = nil) {
        self.debounce = debounce 
        self.element = element 
        self.event = event 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
        self.element = try values.decode(ElementChoice.self, forKey: .element) 
        self.event = try values.decodeOptional(String.self, forKey: .event) 
    }

    /// An input element that exposes a _value_ property and supports the [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) interface, or a CSS selector string to such an element. When the element updates and dispatches an event, the _value_ property will be used as the new, bound signal value. When the signal updates independent of the element, the _value_ property will be set to the signal value and a new event will be dispatched on the element.
    /// Generated by Curio
    public typealias ElementChoice = OneOf<Element>.Or<Bric>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case debounce
        case element
        case event
        public var keyDescription: String? {
            switch self {
            case .debounce: return "If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired."
            case .element: return "An input element that exposes a _value_ property and supports the [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) interface, or a CSS selector string to such an element. When the element updates and dispatches an event, the _value_ property will be used as the new, bound signal value. When the signal updates independent of the element, the _value_ property will be set to the signal value and a new event will be dispatched on the element."
            case .event: return "The event (default `\"input\"`) to listen for to track changes on the external element."
             } 
        }

        public typealias CodingOwner = BindDirect
    }
}

/// Generated by Curio
public struct BindInput : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A hint for form autofill. See the [HTML autocomplete attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) for additional information.
    public var autocomplete: String?
    /// If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    public var debounce: Double?
    /// An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view.
    public var element: Element?
    /// The type of input element to use. The valid values are `"checkbox"`, `"radio"`, `"range"`, `"select"`, and any other legal [HTML form input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).
    public var input: String?
    /// By default, the signal name is used to label input elements. This `name` property can be used instead to specify a custom label for the bound signal.
    public var name: String?
    /// Text that appears in the form control when it has no value set.
    public var placeholder: String?
    public static let codingKeyPaths = (\Self.autocomplete as KeyPath, \Self.debounce as KeyPath, \Self.element as KeyPath, \Self.input as KeyPath, \Self.name as KeyPath, \Self.placeholder as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.autocomplete as KeyPath : CodingKeys.autocomplete, \Self.debounce as KeyPath : CodingKeys.debounce, \Self.element as KeyPath : CodingKeys.element, \Self.input as KeyPath : CodingKeys.input, \Self.name as KeyPath : CodingKeys.name, \Self.placeholder as KeyPath : CodingKeys.placeholder]

    public init(autocomplete: String? = nil, debounce: Double? = nil, element: Element? = nil, input: String? = nil, name: String? = nil, placeholder: String? = nil) {
        self.autocomplete = autocomplete 
        self.debounce = debounce 
        self.element = element 
        self.input = input 
        self.name = name 
        self.placeholder = placeholder 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.autocomplete = try values.decodeOptional(String.self, forKey: .autocomplete) 
        self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
        self.element = try values.decodeOptional(Element.self, forKey: .element) 
        self.input = try values.decodeOptional(String.self, forKey: .input) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.placeholder = try values.decodeOptional(String.self, forKey: .placeholder) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case autocomplete
        case debounce
        case element
        case input
        case name
        case placeholder
        public var keyDescription: String? {
            switch self {
            case .autocomplete: return "A hint for form autofill. See the [HTML autocomplete attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) for additional information."
            case .debounce: return "If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired."
            case .element: return "An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view."
            case .input: return "The type of input element to use. The valid values are `\"checkbox\"`, `\"radio\"`, `\"range\"`, `\"select\"`, and any other legal [HTML form input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input)."
            case .name: return "By default, the signal name is used to label input elements. This `name` property can be used instead to specify a custom label for the bound signal."
            case .placeholder: return "Text that appears in the form control when it has no value set."
             } 
        }

        public typealias CodingOwner = BindInput
    }
}

/// Generated by Curio
public struct BindRadioSelect : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    public var debounce: Double?
    /// An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view.
    public var element: Element?
    public var input: LiteralRadioOrSelect
    /// An array of label strings to represent the `options` values. If unspecified, the `options` value will be coerced to a string and used as the label.
    public var labels: [LabelsItem]?
    /// By default, the signal name is used to label input elements. This `name` property can be used instead to specify a custom label for the bound signal.
    public var name: String?
    /// An array of options to select from.
    public var options: [OptionsItem]
    public static let codingKeyPaths = (\Self.debounce as KeyPath, \Self.element as KeyPath, \Self.input as KeyPath, \Self.labels as KeyPath, \Self.name as KeyPath, \Self.options as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.debounce as KeyPath : CodingKeys.debounce, \Self.element as KeyPath : CodingKeys.element, \Self.input as KeyPath : CodingKeys.input, \Self.labels as KeyPath : CodingKeys.labels, \Self.name as KeyPath : CodingKeys.name, \Self.options as KeyPath : CodingKeys.options]

    public init(debounce: Double? = nil, element: Element? = nil, input: LiteralRadioOrSelect, labels: [LabelsItem]? = nil, name: String? = nil, options: [OptionsItem] = []) {
        self.debounce = debounce 
        self.element = element 
        self.input = input 
        self.labels = labels 
        self.name = name 
        self.options = options 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
        self.element = try values.decodeOptional(Element.self, forKey: .element) 
        self.input = try values.decode(LiteralRadioOrSelect.self, forKey: .input) 
        self.labels = try values.decodeOptional([LabelsItem].self, forKey: .labels) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.options = try values.decode([OptionsItem].self, forKey: .options) 
    }

    public typealias LabelsItem = String

    public typealias OptionsItem = Bric

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case debounce
        case element
        case input
        case labels
        case name
        case options
        public var keyDescription: String? {
            switch self {
            case .debounce: return "If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired."
            case .element: return "An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view."
            case .input: return nil
            case .labels: return "An array of label strings to represent the `options` values. If unspecified, the `options` value will be coerced to a string and used as the label."
            case .name: return "By default, the signal name is used to label input elements. This `name` property can be used instead to specify a custom label for the bound signal."
            case .options: return "An array of options to select from."
             } 
        }

        public typealias CodingOwner = BindRadioSelect
    }

    /// Generated by Curio
    public enum LiteralRadioOrSelect : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case radio
        case select
    }
}

/// Generated by Curio
public struct BindRange : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    public var debounce: Double?
    /// An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view.
    public var element: Element?
    public var input: LiteralRange
    /// Sets the maximum slider value. Defaults to the larger of the signal value and `100`.
    public var max: Double?
    /// Sets the minimum slider value. Defaults to the smaller of the signal value and `0`.
    public var min: Double?
    /// By default, the signal name is used to label input elements. This `name` property can be used instead to specify a custom label for the bound signal.
    public var name: String?
    /// Sets the minimum slider increment. If undefined, the step size will be automatically determined based on the `min` and `max` values.
    public var step: Double?
    public static let codingKeyPaths = (\Self.debounce as KeyPath, \Self.element as KeyPath, \Self.input as KeyPath, \Self.max as KeyPath, \Self.min as KeyPath, \Self.name as KeyPath, \Self.step as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.debounce as KeyPath : CodingKeys.debounce, \Self.element as KeyPath : CodingKeys.element, \Self.input as KeyPath : CodingKeys.input, \Self.max as KeyPath : CodingKeys.max, \Self.min as KeyPath : CodingKeys.min, \Self.name as KeyPath : CodingKeys.name, \Self.step as KeyPath : CodingKeys.step]

    public init(debounce: Double? = nil, element: Element? = nil, input: LiteralRange = .range, max: Double? = nil, min: Double? = nil, name: String? = nil, step: Double? = nil) {
        self.debounce = debounce 
        self.element = element 
        self.input = input 
        self.max = max 
        self.min = min 
        self.name = name 
        self.step = step 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
        self.element = try values.decodeOptional(Element.self, forKey: .element) 
        self.input = try values.decode(LiteralRange.self, forKey: .input) 
        self.max = try values.decodeOptional(Double.self, forKey: .max) 
        self.min = try values.decodeOptional(Double.self, forKey: .min) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.step = try values.decodeOptional(Double.self, forKey: .step) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case debounce
        case element
        case input
        case max
        case min
        case name
        case step
        public var keyDescription: String? {
            switch self {
            case .debounce: return "If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired."
            case .element: return "An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view."
            case .input: return nil
            case .max: return "Sets the maximum slider value. Defaults to the larger of the signal value and `100`."
            case .min: return "Sets the minimum slider value. Defaults to the smaller of the signal value and `0`."
            case .name: return "By default, the signal name is used to label input elements. This `name` property can be used instead to specify a custom label for the bound signal."
            case .step: return "Sets the minimum slider increment. If undefined, the step size will be automatically determined based on the `min` and `max` values."
             } 
        }

        public typealias CodingOwner = BindRange
    }

    /// Generated by Curio
    public enum LiteralRange : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case range
    }
}

/// Generated by Curio
public struct BoxPlotConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var box: BoxChoice?
    /// The extent of the whiskers. Available options include:
    /// - `"min-max"`: min and max are the lower and upper whiskers respectively.
    /// - A number representing multiple of the interquartile range. This number will be multiplied by the IQR to determine whisker boundary, which spans from the smallest data to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_ are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).
    /// __Default value:__ `1.5`.
    public var extent: ExtentChoice?
    public var median: MedianChoice?
    public var outliers: OutliersChoice?
    public var rule: RuleChoice?
    /// Size of the box and median tick of a box plot
    public var size: Double?
    public var ticks: TicksChoice?
    public static let codingKeyPaths = (\Self.box as KeyPath, \Self.extent as KeyPath, \Self.median as KeyPath, \Self.outliers as KeyPath, \Self.rule as KeyPath, \Self.size as KeyPath, \Self.ticks as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.box as KeyPath : CodingKeys.box, \Self.extent as KeyPath : CodingKeys.extent, \Self.median as KeyPath : CodingKeys.median, \Self.outliers as KeyPath : CodingKeys.outliers, \Self.rule as KeyPath : CodingKeys.rule, \Self.size as KeyPath : CodingKeys.size, \Self.ticks as KeyPath : CodingKeys.ticks]

    public init(box: BoxChoice? = nil, extent: ExtentChoice? = nil, median: MedianChoice? = nil, outliers: OutliersChoice? = nil, rule: RuleChoice? = nil, size: Double? = nil, ticks: TicksChoice? = nil) {
        self.box = box 
        self.extent = extent 
        self.median = median 
        self.outliers = outliers 
        self.rule = rule 
        self.size = size 
        self.ticks = ticks 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.box = try values.decodeOptional(BoxChoice.self, forKey: .box) 
        self.extent = try values.decodeOptional(ExtentChoice.self, forKey: .extent) 
        self.median = try values.decodeOptional(MedianChoice.self, forKey: .median) 
        self.outliers = try values.decodeOptional(OutliersChoice.self, forKey: .outliers) 
        self.rule = try values.decodeOptional(RuleChoice.self, forKey: .rule) 
        self.size = try values.decodeOptional(Double.self, forKey: .size) 
        self.ticks = try values.decodeOptional(TicksChoice.self, forKey: .ticks) 
    }

    /// Generated by Curio
    public typealias BoxChoice = OneOf<Bool>.Or<MarkConfig>

    /// The extent of the whiskers. Available options include:
    /// - `"min-max"`: min and max are the lower and upper whiskers respectively.
    /// - A number representing multiple of the interquartile range. This number will be multiplied by the IQR to determine whisker boundary, which spans from the smallest data to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_ are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).
    /// __Default value:__ `1.5`.
    /// Generated by Curio
    public typealias ExtentChoice = OneOf<LiteralMinMax>.Or<Double>

    /// Generated by Curio
    public typealias MedianChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias OutliersChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias RuleChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias TicksChoice = OneOf<Bool>.Or<MarkConfig>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case box
        case extent
        case median
        case outliers
        case rule
        case size
        case ticks
        public var keyDescription: String? {
            switch self {
            case .box: return nil
            case .extent: return "The extent of the whiskers. Available options include:\n- `\"min-max\"`: min and max are the lower and upper whiskers respectively.\n- A number representing multiple of the interquartile range. This number will be multiplied by the IQR to determine whisker boundary, which spans from the smallest data to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_ are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).\n\n__Default value:__ `1.5`."
            case .median: return nil
            case .outliers: return nil
            case .rule: return nil
            case .size: return "Size of the box and median tick of a box plot"
            case .ticks: return nil
             } 
        }

        public typealias CodingOwner = BoxPlotConfig
    }
}

/// Generated by Curio
public struct BoxPlotDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var box: BoxChoice?
    /// Whether a composite mark be clipped to the enclosing group’s width and height.
    public var clip: Bool?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    /// The extent of the whiskers. Available options include:
    /// - `"min-max"`: min and max are the lower and upper whiskers respectively.
    /// - A number representing multiple of the interquartile range. This number will be multiplied by the IQR to determine whisker boundary, which spans from the smallest data to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_ are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).
    /// __Default value:__ `1.5`.
    public var extent: ExtentChoice?
    public var median: MedianChoice?
    /// The opacity (value between [0,1]) of the mark.
    public var opacity: Double?
    /// Orientation of the box plot. This is normally automatically determined based on types of fields on x and y channels. However, an explicit `orient` be specified when the orientation is ambiguous.
    /// __Default value:__ `"vertical"`.
    public var orient: Orientation?
    public var outliers: OutliersChoice?
    public var rule: RuleChoice?
    /// Size of the box and median tick of a box plot
    public var size: Double?
    public var ticks: TicksChoice?
    /// The mark type. This could a primitive mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`, `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`) or a composite mark type (`"boxplot"`, `"errorband"`, `"errorbar"`).
    public var type: BoxPlotLiteral
    public static let codingKeyPaths = (\Self.box as KeyPath, \Self.clip as KeyPath, \Self.color as KeyPath, \Self.extent as KeyPath, \Self.median as KeyPath, \Self.opacity as KeyPath, \Self.orient as KeyPath, \Self.outliers as KeyPath, \Self.rule as KeyPath, \Self.size as KeyPath, \Self.ticks as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.box as KeyPath : CodingKeys.box, \Self.clip as KeyPath : CodingKeys.clip, \Self.color as KeyPath : CodingKeys.color, \Self.extent as KeyPath : CodingKeys.extent, \Self.median as KeyPath : CodingKeys.median, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.orient as KeyPath : CodingKeys.orient, \Self.outliers as KeyPath : CodingKeys.outliers, \Self.rule as KeyPath : CodingKeys.rule, \Self.size as KeyPath : CodingKeys.size, \Self.ticks as KeyPath : CodingKeys.ticks, \Self.type as KeyPath : CodingKeys.type]

    public init(box: BoxChoice? = nil, clip: Bool? = nil, color: ColorChoice? = nil, extent: ExtentChoice? = nil, median: MedianChoice? = nil, opacity: Double? = nil, orient: Orientation? = nil, outliers: OutliersChoice? = nil, rule: RuleChoice? = nil, size: Double? = nil, ticks: TicksChoice? = nil, type: BoxPlotLiteral) {
        self.box = box 
        self.clip = clip 
        self.color = color 
        self.extent = extent 
        self.median = median 
        self.opacity = opacity 
        self.orient = orient 
        self.outliers = outliers 
        self.rule = rule 
        self.size = size 
        self.ticks = ticks 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.box = try values.decodeOptional(BoxChoice.self, forKey: .box) 
        self.clip = try values.decodeOptional(Bool.self, forKey: .clip) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.extent = try values.decodeOptional(ExtentChoice.self, forKey: .extent) 
        self.median = try values.decodeOptional(MedianChoice.self, forKey: .median) 
        self.opacity = try values.decodeOptional(Double.self, forKey: .opacity) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outliers = try values.decodeOptional(OutliersChoice.self, forKey: .outliers) 
        self.rule = try values.decodeOptional(RuleChoice.self, forKey: .rule) 
        self.size = try values.decodeOptional(Double.self, forKey: .size) 
        self.ticks = try values.decodeOptional(TicksChoice.self, forKey: .ticks) 
        self.type = try values.decode(BoxPlotLiteral.self, forKey: .type) 
    }

    /// Generated by Curio
    public typealias BoxChoice = OneOf<Bool>.Or<MarkConfig>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// The extent of the whiskers. Available options include:
    /// - `"min-max"`: min and max are the lower and upper whiskers respectively.
    /// - A number representing multiple of the interquartile range. This number will be multiplied by the IQR to determine whisker boundary, which spans from the smallest data to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_ are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).
    /// __Default value:__ `1.5`.
    /// Generated by Curio
    public typealias ExtentChoice = OneOf<LiteralMinMax>.Or<Double>

    /// Generated by Curio
    public typealias MedianChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias OutliersChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias RuleChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias TicksChoice = OneOf<Bool>.Or<MarkConfig>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case box
        case clip
        case color
        case extent
        case median
        case opacity
        case orient
        case outliers
        case rule
        case size
        case ticks
        case type
        public var keyDescription: String? {
            switch self {
            case .box: return nil
            case .clip: return "Whether a composite mark be clipped to the enclosing group’s width and height."
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .extent: return "The extent of the whiskers. Available options include:\n- `\"min-max\"`: min and max are the lower and upper whiskers respectively.\n- A number representing multiple of the interquartile range. This number will be multiplied by the IQR to determine whisker boundary, which spans from the smallest data to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_ are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).\n\n__Default value:__ `1.5`."
            case .median: return nil
            case .opacity: return "The opacity (value between [0,1]) of the mark."
            case .orient: return "Orientation of the box plot. This is normally automatically determined based on types of fields on x and y channels. However, an explicit `orient` be specified when the orientation is ambiguous.\n\n__Default value:__ `\"vertical\"`."
            case .outliers: return nil
            case .rule: return nil
            case .size: return "Size of the box and median tick of a box plot"
            case .ticks: return nil
            case .type: return "The mark type. This could a primitive mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`, `\"area\"`, `\"point\"`, `\"geoshape\"`, `\"rule\"`, and `\"text\"`) or a composite mark type (`\"boxplot\"`, `\"errorband\"`, `\"errorbar\"`)."
             } 
        }

        public typealias CodingOwner = BoxPlotDef
    }
}

/// Generated by Curio
public struct BrushConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The mouse cursor used over the interval mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
    public var cursor: Cursor?
    /// The fill color of the interval mark.
    /// __Default value:__ `"#333333"`
    public var fill: ColorLiteral?
    /// The fill opacity of the interval mark (a value between `0` and `1`).
    /// __Default value:__ `0.125`
    public var fillOpacity: Double?
    /// The stroke color of the interval mark.
    /// __Default value:__ `"#ffffff"`
    public var stroke: ColorLiteral?
    /// An array of alternating stroke and space lengths, for creating dashed or dotted lines.
    public var strokeDash: [StrokeDashItem]?
    /// The offset (in pixels) with which to begin drawing the stroke dash array.
    public var strokeDashOffset: Double?
    /// The stroke opacity of the interval mark (a value between `0` and `1`).
    public var strokeOpacity: Double?
    /// The stroke width of the interval mark.
    public var strokeWidth: Double?
    public static let codingKeyPaths = (\Self.cursor as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.cursor as KeyPath : CodingKeys.cursor, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth]

    public init(cursor: Cursor? = nil, fill: ColorLiteral? = nil, fillOpacity: Double? = nil, stroke: ColorLiteral? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil) {
        self.cursor = cursor 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.stroke = stroke 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.cursor = try values.decodeOptional(Cursor.self, forKey: .cursor) 
        self.fill = try values.decodeOptional(ColorLiteral.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity) 
        self.stroke = try values.decodeOptional(ColorLiteral.self, forKey: .stroke) 
        self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset) 
        self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth) 
    }

    public typealias StrokeDashItem = Double

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case cursor
        case fill
        case fillOpacity
        case stroke
        case strokeDash
        case strokeDashOffset
        case strokeOpacity
        case strokeWidth
        public var keyDescription: String? {
            switch self {
            case .cursor: return "The mouse cursor used over the interval mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used."
            case .fill: return "The fill color of the interval mark.\n\n__Default value:__ `\"#333333\"`"
            case .fillOpacity: return "The fill opacity of the interval mark (a value between `0` and `1`).\n\n__Default value:__ `0.125`"
            case .stroke: return "The stroke color of the interval mark.\n\n__Default value:__ `\"#ffffff\"`"
            case .strokeDash: return "An array of alternating stroke and space lengths, for creating dashed or dotted lines."
            case .strokeDashOffset: return "The offset (in pixels) with which to begin drawing the stroke dash array."
            case .strokeOpacity: return "The stroke opacity of the interval mark (a value between `0` and `1`)."
            case .strokeWidth: return "The stroke width of the interval mark."
             } 
        }

        public typealias CodingOwner = BrushConfig
    }
}

/// Generated by Curio
public struct CalculateTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The field for storing the computed formula value.
    public var `as`: FieldName
    /// A [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string. Use the variable `datum` to refer to the current data object.
    public var calculate: Expr
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.calculate as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.calculate as KeyPath : CodingKeys.calculate]

    public init(id: TransformId? = nil, `as`: FieldName, calculate: Expr) {
        self.id = id 
        self.`as` = `as` 
        self.calculate = calculate 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decode(FieldName.self, forKey: .`as`) 
        self.calculate = try values.decode(Expr.self, forKey: .calculate) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case calculate
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The field for storing the computed formula value."
            case .calculate: return "A [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string. Use the variable `datum` to refer to the current data object."
             } 
        }

        public typealias CodingOwner = CalculateTransform
    }
}

public struct ColorGradient : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ColorGradientLinear>.Or<ColorGradientRadial>

    public init(rawValue: OneOf<ColorGradientLinear>.Or<ColorGradientRadial>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ColorGradientLinear>.Or<ColorGradientRadial>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct ColorGradientLinear : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The type of gradient. Use `"linear"` for a linear gradient.
    public var gradient: LiteralLinear
    public var id: String?
    /// An array of gradient stops defining the gradient color sequence.
    public var stops: [GradientStop]
    /// The starting x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
    /// __Default value:__ `0`
    public var x1: Double?
    /// The ending x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
    /// __Default value:__ `1`
    public var x2: Double?
    /// The starting y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
    /// __Default value:__ `0`
    public var y1: Double?
    /// The ending y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
    /// __Default value:__ `0`
    public var y2: Double?
    public static let codingKeyPaths = (\Self.gradient as KeyPath, \Self.id as KeyPath, \Self.stops as KeyPath, \Self.x1 as KeyPath, \Self.x2 as KeyPath, \Self.y1 as KeyPath, \Self.y2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.gradient as KeyPath : CodingKeys.gradient, \Self.id as KeyPath : CodingKeys.id, \Self.stops as KeyPath : CodingKeys.stops, \Self.x1 as KeyPath : CodingKeys.x1, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y1 as KeyPath : CodingKeys.y1, \Self.y2 as KeyPath : CodingKeys.y2]

    public init(gradient: LiteralLinear = .linear, id: String? = nil, stops: [GradientStop] = [], x1: Double? = nil, x2: Double? = nil, y1: Double? = nil, y2: Double? = nil) {
        self.gradient = gradient 
        self.id = id 
        self.stops = stops 
        self.x1 = x1 
        self.x2 = x2 
        self.y1 = y1 
        self.y2 = y2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.gradient = try values.decode(LiteralLinear.self, forKey: .gradient) 
        self.id = try values.decodeOptional(String.self, forKey: .id) 
        self.stops = try values.decode([GradientStop].self, forKey: .stops) 
        self.x1 = try values.decodeOptional(Double.self, forKey: .x1) 
        self.x2 = try values.decodeOptional(Double.self, forKey: .x2) 
        self.y1 = try values.decodeOptional(Double.self, forKey: .y1) 
        self.y2 = try values.decodeOptional(Double.self, forKey: .y2) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case gradient
        case id
        case stops
        case x1
        case x2
        case y1
        case y2
        public var keyDescription: String? {
            switch self {
            case .gradient: return "The type of gradient. Use `\"linear\"` for a linear gradient."
            case .id: return nil
            case .stops: return "An array of gradient stops defining the gradient color sequence."
            case .x1: return "The starting x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.\n\n__Default value:__ `0`"
            case .x2: return "The ending x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.\n\n__Default value:__ `1`"
            case .y1: return "The starting y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.\n\n__Default value:__ `0`"
            case .y2: return "The ending y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.\n\n__Default value:__ `0`"
             } 
        }

        public typealias CodingOwner = ColorGradientLinear
    }

    /// The type of gradient. Use `"linear"` for a linear gradient.
    /// Generated by Curio
    public enum LiteralLinear : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case linear
    }
}

/// Generated by Curio
public struct ColorGradientRadial : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The type of gradient. Use `"radial"` for a radial gradient.
    public var gradient: LiteralRadial
    public var id: String?
    /// The radius length, in normalized [0, 1] coordinates, of the inner circle for the gradient.
    /// __Default value:__ `0`
    public var r1: Double?
    /// The radius length, in normalized [0, 1] coordinates, of the outer circle for the gradient.
    /// __Default value:__ `0.5`
    public var r2: Double?
    /// An array of gradient stops defining the gradient color sequence.
    public var stops: [GradientStop]
    /// The x-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient.
    /// __Default value:__ `0.5`
    public var x1: Double?
    /// The x-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient.
    /// __Default value:__ `0.5`
    public var x2: Double?
    /// The y-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient.
    /// __Default value:__ `0.5`
    public var y1: Double?
    /// The y-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient.
    /// __Default value:__ `0.5`
    public var y2: Double?
    public static let codingKeyPaths = (\Self.gradient as KeyPath, \Self.id as KeyPath, \Self.r1 as KeyPath, \Self.r2 as KeyPath, \Self.stops as KeyPath, \Self.x1 as KeyPath, \Self.x2 as KeyPath, \Self.y1 as KeyPath, \Self.y2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.gradient as KeyPath : CodingKeys.gradient, \Self.id as KeyPath : CodingKeys.id, \Self.r1 as KeyPath : CodingKeys.r1, \Self.r2 as KeyPath : CodingKeys.r2, \Self.stops as KeyPath : CodingKeys.stops, \Self.x1 as KeyPath : CodingKeys.x1, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y1 as KeyPath : CodingKeys.y1, \Self.y2 as KeyPath : CodingKeys.y2]

    public init(gradient: LiteralRadial = .radial, id: String? = nil, r1: Double? = nil, r2: Double? = nil, stops: [GradientStop] = [], x1: Double? = nil, x2: Double? = nil, y1: Double? = nil, y2: Double? = nil) {
        self.gradient = gradient 
        self.id = id 
        self.r1 = r1 
        self.r2 = r2 
        self.stops = stops 
        self.x1 = x1 
        self.x2 = x2 
        self.y1 = y1 
        self.y2 = y2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.gradient = try values.decode(LiteralRadial.self, forKey: .gradient) 
        self.id = try values.decodeOptional(String.self, forKey: .id) 
        self.r1 = try values.decodeOptional(Double.self, forKey: .r1) 
        self.r2 = try values.decodeOptional(Double.self, forKey: .r2) 
        self.stops = try values.decode([GradientStop].self, forKey: .stops) 
        self.x1 = try values.decodeOptional(Double.self, forKey: .x1) 
        self.x2 = try values.decodeOptional(Double.self, forKey: .x2) 
        self.y1 = try values.decodeOptional(Double.self, forKey: .y1) 
        self.y2 = try values.decodeOptional(Double.self, forKey: .y2) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case gradient
        case id
        case r1
        case r2
        case stops
        case x1
        case x2
        case y1
        case y2
        public var keyDescription: String? {
            switch self {
            case .gradient: return "The type of gradient. Use `\"radial\"` for a radial gradient."
            case .id: return nil
            case .r1: return "The radius length, in normalized [0, 1] coordinates, of the inner circle for the gradient.\n\n__Default value:__ `0`"
            case .r2: return "The radius length, in normalized [0, 1] coordinates, of the outer circle for the gradient.\n\n__Default value:__ `0.5`"
            case .stops: return "An array of gradient stops defining the gradient color sequence."
            case .x1: return "The x-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient.\n\n__Default value:__ `0.5`"
            case .x2: return "The x-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient.\n\n__Default value:__ `0.5`"
            case .y1: return "The y-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient.\n\n__Default value:__ `0.5`"
            case .y2: return "The y-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient.\n\n__Default value:__ `0.5`"
             } 
        }

        public typealias CodingOwner = ColorGradientRadial
    }

    /// The type of gradient. Use `"radial"` for a radial gradient.
    /// Generated by Curio
    public enum LiteralRadial : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case radial
    }
}

public struct ColorLiteral : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ColorName>.Or<HexColor>.Or<String>

    public init(rawValue: OneOf<ColorName>.Or<HexColor>.Or<String>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ColorName>.Or<HexColor>.Or<String>) {
        self.rawValue = rawValue 
    }
}

public struct ColorScheme : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Categorical>.Or<SequentialSingleHue>.Or<SequentialMultiHue>.Or<Diverging>.Or<Cyclical>

    public init(rawValue: OneOf<Categorical>.Or<SequentialSingleHue>.Or<SequentialMultiHue>.Or<Diverging>.Or<Cyclical>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Categorical>.Or<SequentialSingleHue>.Or<SequentialMultiHue>.Or<Diverging>.Or<Cyclical>) {
        self.rawValue = rawValue 
    }
}

public struct CompositeMark : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<BoxPlotLiteral>.Or<ErrorBarLiteral>.Or<ErrorBandLiteral>

    public init(rawValue: OneOf<BoxPlotLiteral>.Or<ErrorBarLiteral>.Or<ErrorBandLiteral>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<BoxPlotLiteral>.Or<ErrorBarLiteral>.Or<ErrorBandLiteral>) {
        self.rawValue = rawValue 
    }
}

public struct CompositeMarkDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<BoxPlotDef>.Or<ErrorBarDef>.Or<ErrorBandDef>

    public init(rawValue: OneOf<BoxPlotDef>.Or<ErrorBarDef>.Or<ErrorBandDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<BoxPlotDef>.Or<ErrorBarDef>.Or<ErrorBandDef>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct CompositionConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The number of columns to include in the view composition layout.
    /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
    /// __Note__:
    /// 1) This property is only for:
    /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
    /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
    /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
    public var columns: Double?
    /// The default spacing in pixels between composed sub-views.
    /// __Default value__: `20`
    public var spacing: Double?
    public static let codingKeyPaths = (\Self.columns as KeyPath, \Self.spacing as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.columns as KeyPath : CodingKeys.columns, \Self.spacing as KeyPath : CodingKeys.spacing]

    public init(columns: Double? = nil, spacing: Double? = nil) {
        self.columns = columns 
        self.spacing = spacing 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
        self.spacing = try values.decodeOptional(Double.self, forKey: .spacing) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case columns
        case spacing
        public var keyDescription: String? {
            switch self {
            case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
            case .spacing: return "The default spacing in pixels between composed sub-views.\n\n__Default value__: `20`"
             } 
        }

        public typealias CodingOwner = CompositionConfig
    }
}

/// Base interface for a generalized concatenation specification.
/// Generated by Curio
public struct ConcatSpecGenericSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// The number of columns to include in the view composition layout.
    /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
    /// __Note__:
    /// 1) This property is only for:
    /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
    /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
    /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
    public var columns: Double?
    /// A list of views to be concatenated.
    public var concat: [Spec]
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// Name of the visualization for later reference.
    public var name: String?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.align as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.concat as KeyPath, \Self.data as KeyPath, \Self.description as KeyPath, \Self.name as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.align as KeyPath : CodingKeys.align, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.concat as KeyPath : CodingKeys.concat, \Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.name as KeyPath : CodingKeys.name, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform]

    public init(id: LayerId? = nil, align: AlignChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, concat: [Spec] = [], data: DataChoice? = nil, description: String? = nil, name: String? = nil, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil) {
        self.id = id 
        self.align = align 
        self.bounds = bounds 
        self.center = center 
        self.columns = columns 
        self.concat = concat 
        self.data = data 
        self.description = description 
        self.name = name 
        self.resolve = resolve 
        self.spacing = spacing 
        self.title = title 
        self.transform = transform 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
        self.concat = try values.decode([Spec].self, forKey: .concat) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case align
        case bounds
        case center
        case columns
        case concat
        case data
        case description
        case name
        case resolve
        case spacing
        case title
        case transform
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
            case .concat: return "A list of views to be concatenated."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .name: return "Name of the visualization for later reference."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
             } 
        }

        public typealias CodingOwner = ConcatSpecGenericSpec
    }
}

public struct ConditionalAxisPropertyAlignNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>

    public init(rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ConditionExprType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.expr as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.expr as KeyPath : CodingKeys.expr]

        public init(condition: ConditionChoice, expr: Expr) {
            self.condition = condition 
            self.expr = expr 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefAlignNullExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case expr
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                 } 
            }

            public typealias CodingOwner = ConditionExprType
        }
    }

    /// Generated by Curio
    public struct ConditionValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

        public init(condition: ConditionChoice, value: ValueChoice) {
            self.condition = condition 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefAlignNullExprRef>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<Align>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case value
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = ConditionValueType
        }
    }
}

public struct ConditionalAxisPropertyColorNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>

    public init(rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ConditionExprType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.expr as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.expr as KeyPath : CodingKeys.expr]

        public init(condition: ConditionChoice, expr: Expr) {
            self.condition = condition 
            self.expr = expr 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefColorNullExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case expr
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                 } 
            }

            public typealias CodingOwner = ConditionExprType
        }
    }

    /// Generated by Curio
    public struct ConditionValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

        public init(condition: ConditionChoice, value: ValueChoice) {
            self.condition = condition 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefColorNullExprRef>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<ColorLiteral>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case value
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = ConditionValueType
        }
    }
}

public struct ConditionalAxisPropertyFontStyleNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>

    public init(rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ConditionExprType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.expr as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.expr as KeyPath : CodingKeys.expr]

        public init(condition: ConditionChoice, expr: Expr) {
            self.condition = condition 
            self.expr = expr 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefFontStyleNullExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case expr
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                 } 
            }

            public typealias CodingOwner = ConditionExprType
        }
    }

    /// Generated by Curio
    public struct ConditionValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

        public init(condition: ConditionChoice, value: ValueChoice) {
            self.condition = condition 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefFontStyleNullExprRef>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<FontStyle>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case value
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = ConditionValueType
        }
    }
}

public struct ConditionalAxisPropertyFontWeightNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>

    public init(rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ConditionExprType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.expr as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.expr as KeyPath : CodingKeys.expr]

        public init(condition: ConditionChoice, expr: Expr) {
            self.condition = condition 
            self.expr = expr 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefFontWeightNullExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case expr
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                 } 
            }

            public typealias CodingOwner = ConditionExprType
        }
    }

    /// Generated by Curio
    public struct ConditionValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

        public init(condition: ConditionChoice, value: ValueChoice) {
            self.condition = condition 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefFontWeightNullExprRef>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<FontWeight>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case value
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = ConditionValueType
        }
    }
}

public struct ConditionalAxisPropertyNumberArrayNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>

    public init(rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ConditionExprType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.expr as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.expr as KeyPath : CodingKeys.expr]

        public init(condition: ConditionChoice, expr: Expr) {
            self.condition = condition 
            self.expr = expr 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefNumberArrayNullExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case expr
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                 } 
            }

            public typealias CodingOwner = ConditionExprType
        }
    }

    /// Generated by Curio
    public struct ConditionValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

        public init(condition: ConditionChoice, value: ValueChoice) {
            self.condition = condition 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefNumberArrayNullExprRef>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<[Double]>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case value
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = ConditionValueType
        }
    }
}

public struct ConditionalAxisPropertyNumberNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>

    public init(rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ConditionExprType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.expr as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.expr as KeyPath : CodingKeys.expr]

        public init(condition: ConditionChoice, expr: Expr) {
            self.condition = condition 
            self.expr = expr 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefNumberNullExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case expr
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                 } 
            }

            public typealias CodingOwner = ConditionExprType
        }
    }

    /// Generated by Curio
    public struct ConditionValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

        public init(condition: ConditionChoice, value: ValueChoice) {
            self.condition = condition 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefNumberNullExprRef>

        /// Generated by Curio
        public typealias ValueChoice = Nullable<Double>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case value
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = ConditionValueType
        }
    }
}

public struct ConditionalAxisPropertyStringNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>

    public init(rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ConditionExprType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.expr as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.expr as KeyPath : CodingKeys.expr]

        public init(condition: ConditionChoice, expr: Expr) {
            self.condition = condition 
            self.expr = expr 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefStringNullExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case expr
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                 } 
            }

            public typealias CodingOwner = ConditionExprType
        }
    }

    /// Generated by Curio
    public struct ConditionValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

        public init(condition: ConditionChoice, value: ValueChoice) {
            self.condition = condition 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefStringNullExprRef>

        /// Generated by Curio
        public typealias ValueChoice = Nullable<String>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case value
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = ConditionValueType
        }
    }
}

public struct ConditionalAxisPropertyTextBaselineNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>

    public init(rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionValueType>.Or<ConditionExprType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ConditionExprType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.expr as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.expr as KeyPath : CodingKeys.expr]

        public init(condition: ConditionChoice, expr: Expr) {
            self.condition = condition 
            self.expr = expr 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefTextBaselineNullExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case expr
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                 } 
            }

            public typealias CodingOwner = ConditionExprType
        }
    }

    /// Generated by Curio
    public struct ConditionValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var condition: ConditionChoice
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

        public init(condition: ConditionChoice, value: ValueChoice) {
            self.condition = condition 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.condition = try values.decode(ConditionChoice.self, forKey: .condition) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ConditionChoice = OneOrMany<ConditionalPredicateValueDefTextBaselineNullExprRef>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<TextBaseline>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case condition
            case value
            public var keyDescription: String? {
                switch self {
                case .condition: return nil
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = ConditionValueType
        }
    }
}

public struct ConditionalMarkPropFieldOrDatumDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateMarkPropFieldOrDatumDef>.Or<ConditionalParameterMarkPropFieldOrDatumDef>

    public init(rawValue: OneOf<ConditionalPredicateMarkPropFieldOrDatumDef>.Or<ConditionalParameterMarkPropFieldOrDatumDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateMarkPropFieldOrDatumDef>.Or<ConditionalParameterMarkPropFieldOrDatumDef>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalMarkPropFieldOrDatumDefTypeForShape : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape>.Or<ConditionalParameterMarkPropFieldOrDatumDefTypeForShape>

    public init(rawValue: OneOf<ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape>.Or<ConditionalParameterMarkPropFieldOrDatumDefTypeForShape>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape>.Or<ConditionalParameterMarkPropFieldOrDatumDefTypeForShape>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalParameterMarkPropFieldOrDatumDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Type1>.Or<Type2>

    public init(rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct Type1 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
        public var empty: Bool?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// Filter using a parameter name.
        public var param: ParameterName
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: StandardMeasureType?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.empty as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.param as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.empty as KeyPath : CodingKeys.empty, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.param as KeyPath : CodingKeys.param, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, empty: Bool? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, param: ParameterName, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.empty = empty 
            self.field = field 
            self.legend = legend 
            self.param = param 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.param = try values.decode(ParameterName.self, forKey: .param) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case empty
            case field
            case legend
            case param
            case scale
            case sort
            case timeUnit
            case title
            case type
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .param: return "Filter using a parameter name."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Type1
        }
    }

    /// Generated by Curio
    public struct Type2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
        public var empty: Bool?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// Filter using a parameter name.
        public var param: ParameterName
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.datum as KeyPath, \Self.empty as KeyPath, \Self.legend as KeyPath, \Self.param as KeyPath, \Self.scale as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.datum as KeyPath : CodingKeys.datum, \Self.empty as KeyPath : CodingKeys.empty, \Self.legend as KeyPath : CodingKeys.legend, \Self.param as KeyPath : CodingKeys.param, \Self.scale as KeyPath : CodingKeys.scale, \Self.type as KeyPath : CodingKeys.type]

        public init(bandPosition: Double? = nil, datum: DatumChoice? = nil, empty: Bool? = nil, legend: LegendChoice? = nil, param: ParameterName, scale: ScaleChoice? = nil, type: MeasureType? = nil) {
            self.bandPosition = bandPosition 
            self.datum = datum 
            self.empty = empty 
            self.legend = legend 
            self.param = param 
            self.scale = scale 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.param = try values.decode(ParameterName.self, forKey: .param) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case bandPosition
            case datum
            case empty
            case legend
            case param
            case scale
            case type
            public var keyDescription: String? {
                switch self {
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .datum: return "A constant value in data domain."
                case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .param: return "Filter using a parameter name."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Type2
        }
    }
}

public struct ConditionalParameterMarkPropFieldOrDatumDefTypeForShape : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Type1>.Or<Type2>

    public init(rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct Type1 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
        public var empty: Bool?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// Filter using a parameter name.
        public var param: ParameterName
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeForShape?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.empty as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.param as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.empty as KeyPath : CodingKeys.empty, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.param as KeyPath : CodingKeys.param, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, empty: Bool? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, param: ParameterName, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeForShape? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.empty = empty 
            self.field = field 
            self.legend = legend 
            self.param = param 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.param = try values.decode(ParameterName.self, forKey: .param) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeForShape.self, forKey: .type) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case empty
            case field
            case legend
            case param
            case scale
            case sort
            case timeUnit
            case title
            case type
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .param: return "Filter using a parameter name."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Type1
        }
    }

    /// Generated by Curio
    public struct Type2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
        public var empty: Bool?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// Filter using a parameter name.
        public var param: ParameterName
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.datum as KeyPath, \Self.empty as KeyPath, \Self.legend as KeyPath, \Self.param as KeyPath, \Self.scale as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.datum as KeyPath : CodingKeys.datum, \Self.empty as KeyPath : CodingKeys.empty, \Self.legend as KeyPath : CodingKeys.legend, \Self.param as KeyPath : CodingKeys.param, \Self.scale as KeyPath : CodingKeys.scale, \Self.type as KeyPath : CodingKeys.type]

        public init(bandPosition: Double? = nil, datum: DatumChoice? = nil, empty: Bool? = nil, legend: LegendChoice? = nil, param: ParameterName, scale: ScaleChoice? = nil, type: MeasureType? = nil) {
            self.bandPosition = bandPosition 
            self.datum = datum 
            self.empty = empty 
            self.legend = legend 
            self.param = param 
            self.scale = scale 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.param = try values.decode(ParameterName.self, forKey: .param) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case bandPosition
            case datum
            case empty
            case legend
            case param
            case scale
            case type
            public var keyDescription: String? {
                switch self {
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .datum: return "A constant value in data domain."
                case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .param: return "Filter using a parameter name."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Type2
        }
    }
}

/// Generated by Curio
public struct ConditionalParameterStringFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// Filter using a parameter name.
    public var param: ParameterName
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.empty as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.param as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.empty as KeyPath : CodingKeys.empty, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.param as KeyPath : CodingKeys.param, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, empty: Bool? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, param: ParameterName, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.empty = empty 
        self.field = field 
        self.format = format 
        self.formatType = formatType 
        self.param = param 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case empty
        case field
        case format
        case formatType
        case param
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .param: return "Filter using a parameter name."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = ConditionalParameterStringFieldDef
    }
}

/// Generated by Curio
public struct ConditionalParameterValueDefGradientStringNullExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// Filter using a parameter name.
    public var param: ParameterName
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.empty as KeyPath, \Self.param as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.empty as KeyPath : CodingKeys.empty, \Self.param as KeyPath : CodingKeys.param, \Self.value as KeyPath : CodingKeys.value]

    public init(empty: Bool? = nil, param: ParameterName, value: ValueChoice) {
        self.empty = empty 
        self.param = param 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = Nullable<OneOf<ColorGradient>.Or<String>.Or<ExprRef>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case empty
        case param
        case value
        public var keyDescription: String? {
            switch self {
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .param: return "Filter using a parameter name."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalParameterValueDefGradientStringNullExprRef
    }
}

/// Generated by Curio
public struct ConditionalParameterValueDefNumber : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// Filter using a parameter name.
    public var param: ParameterName
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: Double
    public static let codingKeyPaths = (\Self.empty as KeyPath, \Self.param as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.empty as KeyPath : CodingKeys.empty, \Self.param as KeyPath : CodingKeys.param, \Self.value as KeyPath : CodingKeys.value]

    public init(empty: Bool? = nil, param: ParameterName, value: Double) {
        self.empty = empty 
        self.param = param 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
        self.value = try values.decode(Double.self, forKey: .value) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case empty
        case param
        case value
        public var keyDescription: String? {
            switch self {
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .param: return "Filter using a parameter name."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalParameterValueDefNumber
    }
}

/// Generated by Curio
public struct ConditionalParameterValueDefNumberArrayExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// Filter using a parameter name.
    public var param: ParameterName
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.empty as KeyPath, \Self.param as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.empty as KeyPath : CodingKeys.empty, \Self.param as KeyPath : CodingKeys.param, \Self.value as KeyPath : CodingKeys.value]

    public init(empty: Bool? = nil, param: ParameterName, value: ValueChoice) {
        self.empty = empty 
        self.param = param 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<[Double]>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case empty
        case param
        case value
        public var keyDescription: String? {
            switch self {
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .param: return "Filter using a parameter name."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalParameterValueDefNumberArrayExprRef
    }
}

/// Generated by Curio
public struct ConditionalParameterValueDefNumberExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// Filter using a parameter name.
    public var param: ParameterName
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.empty as KeyPath, \Self.param as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.empty as KeyPath : CodingKeys.empty, \Self.param as KeyPath : CodingKeys.param, \Self.value as KeyPath : CodingKeys.value]

    public init(empty: Bool? = nil, param: ParameterName, value: ValueChoice) {
        self.empty = empty 
        self.param = param 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case empty
        case param
        case value
        public var keyDescription: String? {
            switch self {
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .param: return "Filter using a parameter name."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalParameterValueDefNumberExprRef
    }
}

/// Generated by Curio
public struct ConditionalParameterValueDefStringExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// Filter using a parameter name.
    public var param: ParameterName
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.empty as KeyPath, \Self.param as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.empty as KeyPath : CodingKeys.empty, \Self.param as KeyPath : CodingKeys.param, \Self.value as KeyPath : CodingKeys.value]

    public init(empty: Bool? = nil, param: ParameterName, value: ValueChoice) {
        self.empty = empty 
        self.param = param 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<String>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case empty
        case param
        case value
        public var keyDescription: String? {
            switch self {
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .param: return "Filter using a parameter name."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalParameterValueDefStringExprRef
    }
}

/// Generated by Curio
public struct ConditionalParameterValueDefStringNullExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// Filter using a parameter name.
    public var param: ParameterName
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.empty as KeyPath, \Self.param as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.empty as KeyPath : CodingKeys.empty, \Self.param as KeyPath : CodingKeys.param, \Self.value as KeyPath : CodingKeys.value]

    public init(empty: Bool? = nil, param: ParameterName, value: ValueChoice) {
        self.empty = empty 
        self.param = param 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = Nullable<OneOf<String>.Or<ExprRef>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case empty
        case param
        case value
        public var keyDescription: String? {
            switch self {
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .param: return "Filter using a parameter name."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalParameterValueDefStringNullExprRef
    }
}

/// Generated by Curio
public struct ConditionalParameterValueDefTextExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// Filter using a parameter name.
    public var param: ParameterName
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.empty as KeyPath, \Self.param as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.empty as KeyPath : CodingKeys.empty, \Self.param as KeyPath : CodingKeys.param, \Self.value as KeyPath : CodingKeys.value]

    public init(empty: Bool? = nil, param: ParameterName, value: ValueChoice) {
        self.empty = empty 
        self.param = param 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<StringList>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case empty
        case param
        case value
        public var keyDescription: String? {
            switch self {
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .param: return "Filter using a parameter name."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalParameterValueDefTextExprRef
    }
}

public struct ConditionalPredicateMarkPropFieldOrDatumDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Type1>.Or<Type2>

    public init(rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct Type1 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: StandardMeasureType?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.test as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.test as KeyPath : CodingKeys.test, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, test: PredicateComposition, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.test = test 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case field
            case legend
            case scale
            case sort
            case test
            case timeUnit
            case title
            case type
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .test: return "Predicate for triggering the condition"
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Type1
        }
    }

    /// Generated by Curio
    public struct Type2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.datum as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.test as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.datum as KeyPath : CodingKeys.datum, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.test as KeyPath : CodingKeys.test, \Self.type as KeyPath : CodingKeys.type]

        public init(bandPosition: Double? = nil, datum: DatumChoice? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, test: PredicateComposition, type: MeasureType? = nil) {
            self.bandPosition = bandPosition 
            self.datum = datum 
            self.legend = legend 
            self.scale = scale 
            self.test = test 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case bandPosition
            case datum
            case legend
            case scale
            case test
            case type
            public var keyDescription: String? {
                switch self {
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .datum: return "A constant value in data domain."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .test: return "Predicate for triggering the condition"
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Type2
        }
    }
}

public struct ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Type1>.Or<Type2>

    public init(rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct Type1 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeForShape?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.test as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.test as KeyPath : CodingKeys.test, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, test: PredicateComposition, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeForShape? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.test = test 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeForShape.self, forKey: .type) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case field
            case legend
            case scale
            case sort
            case test
            case timeUnit
            case title
            case type
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .test: return "Predicate for triggering the condition"
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Type1
        }
    }

    /// Generated by Curio
    public struct Type2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.datum as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.test as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.datum as KeyPath : CodingKeys.datum, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.test as KeyPath : CodingKeys.test, \Self.type as KeyPath : CodingKeys.type]

        public init(bandPosition: Double? = nil, datum: DatumChoice? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, test: PredicateComposition, type: MeasureType? = nil) {
            self.bandPosition = bandPosition 
            self.datum = datum 
            self.legend = legend 
            self.scale = scale 
            self.test = test 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case bandPosition
            case datum
            case legend
            case scale
            case test
            case type
            public var keyDescription: String? {
                switch self {
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .datum: return "A constant value in data domain."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .test: return "Predicate for triggering the condition"
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Type2
        }
    }
}

/// Generated by Curio
public struct ConditionalPredicateStringFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// Predicate for triggering the condition
    public var test: PredicateComposition
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.test as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.test as KeyPath : CodingKeys.test, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, test: PredicateComposition, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.format = format 
        self.formatType = formatType 
        self.test = test 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case field
        case format
        case formatType
        case test
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .test: return "Predicate for triggering the condition"
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = ConditionalPredicateStringFieldDef
    }
}

public struct ConditionalPredicateValueDefAlignNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TestValueType>.Or<ExprTestType>

    public init(rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ExprTestType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        public static let codingKeyPaths = (\Self.expr as KeyPath, \Self.test as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr, \Self.test as KeyPath : CodingKeys.test]

        public init(expr: Expr, test: PredicateComposition) {
            self.expr = expr 
            self.test = test 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case expr
            case test
            public var keyDescription: String? {
                switch self {
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                case .test: return "Predicate for triggering the condition"
                 } 
            }

            public typealias CodingOwner = ExprTestType
        }
    }

    /// Generated by Curio
    public struct TestValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

        public init(test: PredicateComposition, value: ValueChoice) {
            self.test = test 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<Align>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case test
            case value
            public var keyDescription: String? {
                switch self {
                case .test: return "Predicate for triggering the condition"
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = TestValueType
        }
    }
}

public struct ConditionalPredicateValueDefColorNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TestValueType>.Or<ExprTestType>

    public init(rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ExprTestType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        public static let codingKeyPaths = (\Self.expr as KeyPath, \Self.test as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr, \Self.test as KeyPath : CodingKeys.test]

        public init(expr: Expr, test: PredicateComposition) {
            self.expr = expr 
            self.test = test 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case expr
            case test
            public var keyDescription: String? {
                switch self {
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                case .test: return "Predicate for triggering the condition"
                 } 
            }

            public typealias CodingOwner = ExprTestType
        }
    }

    /// Generated by Curio
    public struct TestValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

        public init(test: PredicateComposition, value: ValueChoice) {
            self.test = test 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<ColorLiteral>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case test
            case value
            public var keyDescription: String? {
                switch self {
                case .test: return "Predicate for triggering the condition"
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = TestValueType
        }
    }
}

public struct ConditionalPredicateValueDefFontStyleNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TestValueType>.Or<ExprTestType>

    public init(rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ExprTestType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        public static let codingKeyPaths = (\Self.expr as KeyPath, \Self.test as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr, \Self.test as KeyPath : CodingKeys.test]

        public init(expr: Expr, test: PredicateComposition) {
            self.expr = expr 
            self.test = test 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case expr
            case test
            public var keyDescription: String? {
                switch self {
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                case .test: return "Predicate for triggering the condition"
                 } 
            }

            public typealias CodingOwner = ExprTestType
        }
    }

    /// Generated by Curio
    public struct TestValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

        public init(test: PredicateComposition, value: ValueChoice) {
            self.test = test 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<FontStyle>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case test
            case value
            public var keyDescription: String? {
                switch self {
                case .test: return "Predicate for triggering the condition"
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = TestValueType
        }
    }
}

public struct ConditionalPredicateValueDefFontWeightNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TestValueType>.Or<ExprTestType>

    public init(rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ExprTestType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        public static let codingKeyPaths = (\Self.expr as KeyPath, \Self.test as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr, \Self.test as KeyPath : CodingKeys.test]

        public init(expr: Expr, test: PredicateComposition) {
            self.expr = expr 
            self.test = test 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case expr
            case test
            public var keyDescription: String? {
                switch self {
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                case .test: return "Predicate for triggering the condition"
                 } 
            }

            public typealias CodingOwner = ExprTestType
        }
    }

    /// Generated by Curio
    public struct TestValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

        public init(test: PredicateComposition, value: ValueChoice) {
            self.test = test 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<FontWeight>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case test
            case value
            public var keyDescription: String? {
                switch self {
                case .test: return "Predicate for triggering the condition"
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = TestValueType
        }
    }
}

/// Generated by Curio
public struct ConditionalPredicateValueDefGradientStringNullExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Predicate for triggering the condition
    public var test: PredicateComposition
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

    public init(test: PredicateComposition, value: ValueChoice) {
        self.test = test 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = Nullable<OneOf<ColorGradient>.Or<String>.Or<ExprRef>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case test
        case value
        public var keyDescription: String? {
            switch self {
            case .test: return "Predicate for triggering the condition"
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalPredicateValueDefGradientStringNullExprRef
    }
}

/// Generated by Curio
public struct ConditionalPredicateValueDefNumber : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Predicate for triggering the condition
    public var test: PredicateComposition
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: Double
    public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

    public init(test: PredicateComposition, value: Double) {
        self.test = test 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        self.value = try values.decode(Double.self, forKey: .value) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case test
        case value
        public var keyDescription: String? {
            switch self {
            case .test: return "Predicate for triggering the condition"
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalPredicateValueDefNumber
    }
}

/// Generated by Curio
public struct ConditionalPredicateValueDefNumberArrayExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Predicate for triggering the condition
    public var test: PredicateComposition
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

    public init(test: PredicateComposition, value: ValueChoice) {
        self.test = test 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<[Double]>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case test
        case value
        public var keyDescription: String? {
            switch self {
            case .test: return "Predicate for triggering the condition"
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalPredicateValueDefNumberArrayExprRef
    }
}

public struct ConditionalPredicateValueDefNumberArrayNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TestValueType>.Or<ExprTestType>

    public init(rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ExprTestType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        public static let codingKeyPaths = (\Self.expr as KeyPath, \Self.test as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr, \Self.test as KeyPath : CodingKeys.test]

        public init(expr: Expr, test: PredicateComposition) {
            self.expr = expr 
            self.test = test 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case expr
            case test
            public var keyDescription: String? {
                switch self {
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                case .test: return "Predicate for triggering the condition"
                 } 
            }

            public typealias CodingOwner = ExprTestType
        }
    }

    /// Generated by Curio
    public struct TestValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

        public init(test: PredicateComposition, value: ValueChoice) {
            self.test = test 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<[Double]>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case test
            case value
            public var keyDescription: String? {
                switch self {
                case .test: return "Predicate for triggering the condition"
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = TestValueType
        }
    }
}

/// Generated by Curio
public struct ConditionalPredicateValueDefNumberExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Predicate for triggering the condition
    public var test: PredicateComposition
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

    public init(test: PredicateComposition, value: ValueChoice) {
        self.test = test 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case test
        case value
        public var keyDescription: String? {
            switch self {
            case .test: return "Predicate for triggering the condition"
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalPredicateValueDefNumberExprRef
    }
}

public struct ConditionalPredicateValueDefNumberNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TestValueType>.Or<ExprTestType>

    public init(rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ExprTestType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        public static let codingKeyPaths = (\Self.expr as KeyPath, \Self.test as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr, \Self.test as KeyPath : CodingKeys.test]

        public init(expr: Expr, test: PredicateComposition) {
            self.expr = expr 
            self.test = test 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case expr
            case test
            public var keyDescription: String? {
                switch self {
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                case .test: return "Predicate for triggering the condition"
                 } 
            }

            public typealias CodingOwner = ExprTestType
        }
    }

    /// Generated by Curio
    public struct TestValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

        public init(test: PredicateComposition, value: ValueChoice) {
            self.test = test 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ValueChoice = Nullable<Double>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case test
            case value
            public var keyDescription: String? {
                switch self {
                case .test: return "Predicate for triggering the condition"
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = TestValueType
        }
    }
}

/// Generated by Curio
public struct ConditionalPredicateValueDefStringExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Predicate for triggering the condition
    public var test: PredicateComposition
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

    public init(test: PredicateComposition, value: ValueChoice) {
        self.test = test 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<String>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case test
        case value
        public var keyDescription: String? {
            switch self {
            case .test: return "Predicate for triggering the condition"
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalPredicateValueDefStringExprRef
    }
}

public struct ConditionalPredicateValueDefStringNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TestValueType>.Or<ExprTestType>

    public init(rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ExprTestType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        public static let codingKeyPaths = (\Self.expr as KeyPath, \Self.test as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr, \Self.test as KeyPath : CodingKeys.test]

        public init(expr: Expr, test: PredicateComposition) {
            self.expr = expr 
            self.test = test 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case expr
            case test
            public var keyDescription: String? {
                switch self {
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                case .test: return "Predicate for triggering the condition"
                 } 
            }

            public typealias CodingOwner = ExprTestType
        }
    }

    /// Generated by Curio
    public struct TestValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

        public init(test: PredicateComposition, value: ValueChoice) {
            self.test = test 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// Generated by Curio
        public typealias ValueChoice = Nullable<String>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case test
            case value
            public var keyDescription: String? {
                switch self {
                case .test: return "Predicate for triggering the condition"
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = TestValueType
        }
    }
}

/// Generated by Curio
public struct ConditionalPredicateValueDefStringNullExprReference : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Predicate for triggering the condition
    public var test: PredicateComposition
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

    public init(test: PredicateComposition, value: ValueChoice) {
        self.test = test 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = Nullable<OneOf<String>.Or<ExprRef>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case test
        case value
        public var keyDescription: String? {
            switch self {
            case .test: return "Predicate for triggering the condition"
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalPredicateValueDefStringNullExprReference
    }
}

public struct ConditionalPredicateValueDefTextBaselineNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TestValueType>.Or<ExprTestType>

    public init(rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TestValueType>.Or<ExprTestType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct ExprTestType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Vega expression (which can refer to Vega-Lite parameters).
        public var expr: Expr
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        public static let codingKeyPaths = (\Self.expr as KeyPath, \Self.test as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr, \Self.test as KeyPath : CodingKeys.test]

        public init(expr: Expr, test: PredicateComposition) {
            self.expr = expr 
            self.test = test 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.expr = try values.decode(Expr.self, forKey: .expr) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case expr
            case test
            public var keyDescription: String? {
                switch self {
                case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
                case .test: return "Predicate for triggering the condition"
                 } 
            }

            public typealias CodingOwner = ExprTestType
        }
    }

    /// Generated by Curio
    public struct TestValueType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Predicate for triggering the condition
        public var test: PredicateComposition
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice
        public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

        public init(test: PredicateComposition, value: ValueChoice) {
            self.test = test 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.test = try values.decode(PredicateComposition.self, forKey: .test) 
            self.value = try values.decode(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<TextBaseline>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case test
            case value
            public var keyDescription: String? {
                switch self {
                case .test: return "Predicate for triggering the condition"
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = TestValueType
        }
    }
}

/// Generated by Curio
public struct ConditionalPredicateValueDefTextExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Predicate for triggering the condition
    public var test: PredicateComposition
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.test as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.test as KeyPath : CodingKeys.test, \Self.value as KeyPath : CodingKeys.value]

    public init(test: PredicateComposition, value: ValueChoice) {
        self.test = test 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.test = try values.decode(PredicateComposition.self, forKey: .test) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<StringList>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case test
        case value
        public var keyDescription: String? {
            switch self {
            case .test: return "Predicate for triggering the condition"
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ConditionalPredicateValueDefTextExprRef
    }
}

public struct ConditionalStringFieldDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateStringFieldDef>.Or<ConditionalParameterStringFieldDef>

    public init(rawValue: OneOf<ConditionalPredicateStringFieldDef>.Or<ConditionalParameterStringFieldDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateStringFieldDef>.Or<ConditionalParameterStringFieldDef>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalValueDefGradientStringNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateValueDefGradientStringNullExprRef>.Or<ConditionalParameterValueDefGradientStringNullExprRef>

    public init(rawValue: OneOf<ConditionalPredicateValueDefGradientStringNullExprRef>.Or<ConditionalParameterValueDefGradientStringNullExprRef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateValueDefGradientStringNullExprRef>.Or<ConditionalParameterValueDefGradientStringNullExprRef>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalValueDefNumber : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateValueDefNumber>.Or<ConditionalParameterValueDefNumber>

    public init(rawValue: OneOf<ConditionalPredicateValueDefNumber>.Or<ConditionalParameterValueDefNumber>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateValueDefNumber>.Or<ConditionalParameterValueDefNumber>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalValueDefNumberArrayExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateValueDefNumberArrayExprRef>.Or<ConditionalParameterValueDefNumberArrayExprRef>

    public init(rawValue: OneOf<ConditionalPredicateValueDefNumberArrayExprRef>.Or<ConditionalParameterValueDefNumberArrayExprRef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateValueDefNumberArrayExprRef>.Or<ConditionalParameterValueDefNumberArrayExprRef>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalValueDefNumberExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateValueDefNumberExprRef>.Or<ConditionalParameterValueDefNumberExprRef>

    public init(rawValue: OneOf<ConditionalPredicateValueDefNumberExprRef>.Or<ConditionalParameterValueDefNumberExprRef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateValueDefNumberExprRef>.Or<ConditionalParameterValueDefNumberExprRef>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalValueDefStringExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateValueDefStringExprRef>.Or<ConditionalParameterValueDefStringExprRef>

    public init(rawValue: OneOf<ConditionalPredicateValueDefStringExprRef>.Or<ConditionalParameterValueDefStringExprRef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateValueDefStringExprRef>.Or<ConditionalParameterValueDefStringExprRef>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalValueDefStringNullExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateValueDefStringNullExprReference>.Or<ConditionalParameterValueDefStringNullExprRef>

    public init(rawValue: OneOf<ConditionalPredicateValueDefStringNullExprReference>.Or<ConditionalParameterValueDefStringNullExprRef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateValueDefStringNullExprReference>.Or<ConditionalParameterValueDefStringNullExprRef>) {
        self.rawValue = rawValue 
    }
}

public struct ConditionalValueDefTextExprRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<ConditionalPredicateValueDefTextExprRef>.Or<ConditionalParameterValueDefTextExprRef>

    public init(rawValue: OneOf<ConditionalPredicateValueDefTextExprRef>.Or<ConditionalParameterValueDefTextExprRef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<ConditionalPredicateValueDefTextExprRef>.Or<ConditionalParameterValueDefTextExprRef>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct ConfigTheme : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    private var _arc: Indirect<RectConfig>?
    /// Arc-specific Config
    public var arc: RectConfig? {
        get { return _arc?.wrappedValue }
        set { _arc = newValue.indirect() }
    }
    private var _area: Indirect<AreaConfig>?
    /// Area-Specific Config
    public var area: AreaConfig? {
        get { return _area?.wrappedValue }
        set { _area = newValue.indirect() }
    }
    /// A boolean flag indicating if ARIA default attributes should be included for marks and guides (SVG output only). If false, the `"aria-hidden"` attribute will be set for all guides, removing them from the ARIA accessibility tree and Vega-Lite will not generate default descriptions for marks.
    /// __Default value:__ `true`.
    public var aria: Bool?
    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    public var autosize: AutosizeChoice?
    private var _axis: Indirect<AxisConfig>?
    /// Axis configuration, which determines default properties for all `x` and `y` [axes](https://vega.github.io/vega-lite/docs/axis.html). For a full list of axis configuration options, please see the [corresponding section of the axis documentation](https://vega.github.io/vega-lite/docs/axis.html#config).
    public var axis: AxisConfig? {
        get { return _axis?.wrappedValue }
        set { _axis = newValue.indirect() }
    }
    private var _axisBand: Indirect<AxisConfig>?
    /// Config for axes with "band" scales.
    public var axisBand: AxisConfig? {
        get { return _axisBand?.wrappedValue }
        set { _axisBand = newValue.indirect() }
    }
    private var _axisBottom: Indirect<AxisConfig>?
    /// Config for x-axis along the bottom edge of the chart.
    public var axisBottom: AxisConfig? {
        get { return _axisBottom?.wrappedValue }
        set { _axisBottom = newValue.indirect() }
    }
    private var _axisDiscrete: Indirect<AxisConfig>?
    /// Config for axes with "point" or "band" scales.
    public var axisDiscrete: AxisConfig? {
        get { return _axisDiscrete?.wrappedValue }
        set { _axisDiscrete = newValue.indirect() }
    }
    private var _axisLeft: Indirect<AxisConfig>?
    /// Config for y-axis along the left edge of the chart.
    public var axisLeft: AxisConfig? {
        get { return _axisLeft?.wrappedValue }
        set { _axisLeft = newValue.indirect() }
    }
    private var _axisPoint: Indirect<AxisConfig>?
    /// Config for axes with "point" scales.
    public var axisPoint: AxisConfig? {
        get { return _axisPoint?.wrappedValue }
        set { _axisPoint = newValue.indirect() }
    }
    private var _axisQuantitative: Indirect<AxisConfig>?
    /// Config for quantitative axes.
    public var axisQuantitative: AxisConfig? {
        get { return _axisQuantitative?.wrappedValue }
        set { _axisQuantitative = newValue.indirect() }
    }
    private var _axisRight: Indirect<AxisConfig>?
    /// Config for y-axis along the right edge of the chart.
    public var axisRight: AxisConfig? {
        get { return _axisRight?.wrappedValue }
        set { _axisRight = newValue.indirect() }
    }
    private var _axisTemporal: Indirect<AxisConfig>?
    /// Config for temporal axes.
    public var axisTemporal: AxisConfig? {
        get { return _axisTemporal?.wrappedValue }
        set { _axisTemporal = newValue.indirect() }
    }
    private var _axisTop: Indirect<AxisConfig>?
    /// Config for x-axis along the top edge of the chart.
    public var axisTop: AxisConfig? {
        get { return _axisTop?.wrappedValue }
        set { _axisTop = newValue.indirect() }
    }
    private var _axisX: Indirect<AxisConfig>?
    /// X-axis specific config.
    public var axisX: AxisConfig? {
        get { return _axisX?.wrappedValue }
        set { _axisX = newValue.indirect() }
    }
    private var _axisXBand: Indirect<AxisConfig>?
    /// Config for x-axes with "band" scales.
    public var axisXBand: AxisConfig? {
        get { return _axisXBand?.wrappedValue }
        set { _axisXBand = newValue.indirect() }
    }
    private var _axisXDiscrete: Indirect<AxisConfig>?
    /// Config for x-axes with "point" or "band" scales.
    public var axisXDiscrete: AxisConfig? {
        get { return _axisXDiscrete?.wrappedValue }
        set { _axisXDiscrete = newValue.indirect() }
    }
    private var _axisXPoint: Indirect<AxisConfig>?
    /// Config for x-axes with "point" scales.
    public var axisXPoint: AxisConfig? {
        get { return _axisXPoint?.wrappedValue }
        set { _axisXPoint = newValue.indirect() }
    }
    private var _axisXQuantitative: Indirect<AxisConfig>?
    /// Config for x-quantitative axes.
    public var axisXQuantitative: AxisConfig? {
        get { return _axisXQuantitative?.wrappedValue }
        set { _axisXQuantitative = newValue.indirect() }
    }
    private var _axisXTemporal: Indirect<AxisConfig>?
    /// Config for x-temporal axes.
    public var axisXTemporal: AxisConfig? {
        get { return _axisXTemporal?.wrappedValue }
        set { _axisXTemporal = newValue.indirect() }
    }
    private var _axisY: Indirect<AxisConfig>?
    /// Y-axis specific config.
    public var axisY: AxisConfig? {
        get { return _axisY?.wrappedValue }
        set { _axisY = newValue.indirect() }
    }
    private var _axisYBand: Indirect<AxisConfig>?
    /// Config for y-axes with "band" scales.
    public var axisYBand: AxisConfig? {
        get { return _axisYBand?.wrappedValue }
        set { _axisYBand = newValue.indirect() }
    }
    private var _axisYDiscrete: Indirect<AxisConfig>?
    /// Config for y-axes with "point" or "band" scales.
    public var axisYDiscrete: AxisConfig? {
        get { return _axisYDiscrete?.wrappedValue }
        set { _axisYDiscrete = newValue.indirect() }
    }
    private var _axisYPoint: Indirect<AxisConfig>?
    /// Config for y-axes with "point" scales.
    public var axisYPoint: AxisConfig? {
        get { return _axisYPoint?.wrappedValue }
        set { _axisYPoint = newValue.indirect() }
    }
    private var _axisYQuantitative: Indirect<AxisConfig>?
    /// Config for y-quantitative axes.
    public var axisYQuantitative: AxisConfig? {
        get { return _axisYQuantitative?.wrappedValue }
        set { _axisYQuantitative = newValue.indirect() }
    }
    private var _axisYTemporal: Indirect<AxisConfig>?
    /// Config for y-temporal axes.
    public var axisYTemporal: AxisConfig? {
        get { return _axisYTemporal?.wrappedValue }
        set { _axisYTemporal = newValue.indirect() }
    }
    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    public var background: BackgroundChoice?
    private var _bar: Indirect<BarConfig>?
    /// Bar-Specific Config
    public var bar: BarConfig? {
        get { return _bar?.wrappedValue }
        set { _bar = newValue.indirect() }
    }
    private var _boxplot: Indirect<BoxPlotConfig>?
    /// Box Config
    public var boxplot: BoxPlotConfig? {
        get { return _boxplot?.wrappedValue }
        set { _boxplot = newValue.indirect() }
    }
    private var _circle: Indirect<MarkConfig>?
    /// Circle-Specific Config
    public var circle: MarkConfig? {
        get { return _circle?.wrappedValue }
        set { _circle = newValue.indirect() }
    }
    private var _concat: Indirect<CompositionConfig>?
    /// Default configuration for all concatenation and repeat view composition operators (`concat`, `hconcat`, `vconcat`, and `repeat`)
    public var concat: CompositionConfig? {
        get { return _concat?.wrappedValue }
        set { _concat = newValue.indirect() }
    }
    /// Default axis and legend title for count fields.
    /// __Default value:__ `'Count of Records`.
    public var countTitle: String?
    /// Allow the `formatType` property for text marks and guides to accept a custom formatter function [registered as a Vega expression](https://vega.github.io/vega-lite/usage/compile.html#format-type).
    public var customFormatTypes: Bool?
    private var _errorband: Indirect<ErrorBandConfig>?
    /// ErrorBand Config
    public var errorband: ErrorBandConfig? {
        get { return _errorband?.wrappedValue }
        set { _errorband = newValue.indirect() }
    }
    private var _errorbar: Indirect<ErrorBarConfig>?
    /// ErrorBar Config
    public var errorbar: ErrorBarConfig? {
        get { return _errorbar?.wrappedValue }
        set { _errorbar = newValue.indirect() }
    }
    private var _facet: Indirect<CompositionConfig>?
    /// Default configuration for the `facet` view composition operator
    public var facet: CompositionConfig? {
        get { return _facet?.wrappedValue }
        set { _facet = newValue.indirect() }
    }
    /// Defines how Vega-Lite generates title for fields. There are three possible styles:
    /// - `"verbal"` (Default) - displays function in a verbal style (e.g., "Sum of field", "Year-month of date", "field (binned)").
    /// - `"function"` - displays function using parentheses and capitalized texts (e.g., "SUM(field)", "YEARMONTH(date)", "BIN(field)").
    /// - `"plain"` - displays only the field name without functions (e.g., "field", "date", "field").
    public var fieldTitle: LiteralVerbalOrFunctionalOrPlain?
    /// Default font for all text marks, titles, and labels.
    public var font: FontName?
    private var _geoshape: Indirect<MarkConfig>?
    /// Geoshape-Specific Config
    public var geoshape: MarkConfig? {
        get { return _geoshape?.wrappedValue }
        set { _geoshape = newValue.indirect() }
    }
    private var _header: Indirect<HeaderConfig>?
    /// Header configuration, which determines default properties for all [headers](https://vega.github.io/vega-lite/docs/header.html).
    /// For a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
    public var header: HeaderConfig? {
        get { return _header?.wrappedValue }
        set { _header = newValue.indirect() }
    }
    private var _headerColumn: Indirect<HeaderConfig>?
    /// Header configuration, which determines default properties for column [headers](https://vega.github.io/vega-lite/docs/header.html).
    /// For a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
    public var headerColumn: HeaderConfig? {
        get { return _headerColumn?.wrappedValue }
        set { _headerColumn = newValue.indirect() }
    }
    private var _headerFacet: Indirect<HeaderConfig>?
    /// Header configuration, which determines default properties for non-row/column facet [headers](https://vega.github.io/vega-lite/docs/header.html).
    /// For a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
    public var headerFacet: HeaderConfig? {
        get { return _headerFacet?.wrappedValue }
        set { _headerFacet = newValue.indirect() }
    }
    private var _headerRow: Indirect<HeaderConfig>?
    /// Header configuration, which determines default properties for row [headers](https://vega.github.io/vega-lite/docs/header.html).
    /// For a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
    public var headerRow: HeaderConfig? {
        get { return _headerRow?.wrappedValue }
        set { _headerRow = newValue.indirect() }
    }
    private var _image: Indirect<RectConfig>?
    /// Image-specific Config
    public var image: RectConfig? {
        get { return _image?.wrappedValue }
        set { _image = newValue.indirect() }
    }
    private var _legend: Indirect<LegendConfig>?
    /// Legend configuration, which determines default properties for all [legends](https://vega.github.io/vega-lite/docs/legend.html). For a full list of legend configuration options, please see the [corresponding section of in the legend documentation](https://vega.github.io/vega-lite/docs/legend.html#config).
    public var legend: LegendConfig? {
        get { return _legend?.wrappedValue }
        set { _legend = newValue.indirect() }
    }
    private var _line: Indirect<LineConfig>?
    /// Line-Specific Config
    public var line: LineConfig? {
        get { return _line?.wrappedValue }
        set { _line = newValue.indirect() }
    }
    /// A delimiter, such as a newline character, upon which to break text strings into multiple lines. This property provides a global default for text marks, which is overridden by mark or style config settings, and by the lineBreak mark encoding channel. If signal-valued, either string or regular expression (regexp) values are valid.
    public var lineBreak: LineBreakChoice?
    /// Locale definitions for string parsing and formatting of number and date values. The locale object should contain `number` and/or `time` properties with [locale definitions](https://vega.github.io/vega/docs/api/locale/). Locale definitions provided in the config block may be overridden by the View constructor locale option.
    public var locale: Locale?
    private var _mark: Indirect<MarkConfig>?
    /// Mark Config
    public var mark: MarkConfig? {
        get { return _mark?.wrappedValue }
        set { _mark = newValue.indirect() }
    }
    /// D3 Number format for guide labels and text marks. For example `"s"` for SI units. Use [D3's number format pattern](https://github.com/d3/d3-format#locale_format).
    public var numberFormat: String?
    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    public var padding: PaddingChoice?
    /// Dynamic variables or selections that parameterize a visualization.
    public var params: [ParamsItemChoice]?
    private var _point: Indirect<MarkConfig>?
    /// Point-Specific Config
    public var point: MarkConfig? {
        get { return _point?.wrappedValue }
        set { _point = newValue.indirect() }
    }
    private var _projection: Indirect<ProjectionConfig>?
    /// Projection configuration, which determines default properties for all [projections](https://vega.github.io/vega-lite/docs/projection.html). For a full list of projection configuration options, please see the [corresponding section of the projection documentation](https://vega.github.io/vega-lite/docs/projection.html#config).
    public var projection: ProjectionConfig? {
        get { return _projection?.wrappedValue }
        set { _projection = newValue.indirect() }
    }
    private var _range: Indirect<RangeConfig>?
    /// An object hash that defines default range arrays or schemes for using with scales. For a full list of scale range configuration options, please see the [corresponding section of the scale documentation](https://vega.github.io/vega-lite/docs/scale.html#config).
    public var range: RangeConfig? {
        get { return _range?.wrappedValue }
        set { _range = newValue.indirect() }
    }
    private var _rect: Indirect<RectConfig>?
    /// Rect-Specific Config
    public var rect: RectConfig? {
        get { return _rect?.wrappedValue }
        set { _rect = newValue.indirect() }
    }
    private var _rule: Indirect<MarkConfig>?
    /// Rule-Specific Config
    public var rule: MarkConfig? {
        get { return _rule?.wrappedValue }
        set { _rule = newValue.indirect() }
    }
    private var _scale: Indirect<ScaleConfig>?
    /// Scale configuration determines default properties for all [scales](https://vega.github.io/vega-lite/docs/scale.html). For a full list of scale configuration options, please see the [corresponding section of the scale documentation](https://vega.github.io/vega-lite/docs/scale.html#config).
    public var scale: ScaleConfig? {
        get { return _scale?.wrappedValue }
        set { _scale = newValue.indirect() }
    }
    private var _selection: Indirect<SelectionConfig>?
    /// An object hash for defining default properties for each type of selections.
    public var selection: SelectionConfig? {
        get { return _selection?.wrappedValue }
        set { _selection = newValue.indirect() }
    }
    private var _square: Indirect<MarkConfig>?
    /// Square-Specific Config
    public var square: MarkConfig? {
        get { return _square?.wrappedValue }
        set { _square = newValue.indirect() }
    }
    /// An object hash that defines key-value mappings to determine default properties for marks with a given [style](https://vega.github.io/vega-lite/docs/mark.html#mark-def). The keys represent styles names; the values have to be valid [mark configuration objects](https://vega.github.io/vega-lite/docs/mark.html#config).
    public var style: StyleConfigIndex?
    private var _text: Indirect<MarkConfig>?
    /// Text-Specific Config
    public var text: MarkConfig? {
        get { return _text?.wrappedValue }
        set { _text = newValue.indirect() }
    }
    private var _tick: Indirect<TickConfig>?
    /// Tick-Specific Config
    public var tick: TickConfig? {
        get { return _tick?.wrappedValue }
        set { _tick = newValue.indirect() }
    }
    /// Default time format for raw time values (without time units) in text marks, legend labels and header labels.
    /// __Default value:__ `"%b %d, %Y"` __Note:__ Axes automatically determine the format for each label automatically so this config does not affect axes.
    public var timeFormat: String?
    private var _title: Indirect<TitleConfig>?
    /// Title configuration, which determines default properties for all [titles](https://vega.github.io/vega-lite/docs/title.html). For a full list of title configuration options, please see the [corresponding section of the title documentation](https://vega.github.io/vega-lite/docs/title.html#config).
    public var title: TitleConfig? {
        get { return _title?.wrappedValue }
        set { _title = newValue.indirect() }
    }
    private var _trail: Indirect<LineConfig>?
    /// Trail-Specific Config
    public var trail: LineConfig? {
        get { return _trail?.wrappedValue }
        set { _trail = newValue.indirect() }
    }
    private var _view: Indirect<ViewConfig>?
    /// Default properties for [single view plots](https://vega.github.io/vega-lite/docs/spec.html#single).
    public var view: ViewConfig? {
        get { return _view?.wrappedValue }
        set { _view = newValue.indirect() }
    }
    public static let codingKeyPaths = (\Self._arc as KeyPath, \Self._area as KeyPath, \Self.aria as KeyPath, \Self.autosize as KeyPath, \Self._axis as KeyPath, \Self._axisBand as KeyPath, \Self._axisBottom as KeyPath, \Self._axisDiscrete as KeyPath, \Self._axisLeft as KeyPath, \Self._axisPoint as KeyPath, \Self._axisQuantitative as KeyPath, \Self._axisRight as KeyPath, \Self._axisTemporal as KeyPath, \Self._axisTop as KeyPath, \Self._axisX as KeyPath, \Self._axisXBand as KeyPath, \Self._axisXDiscrete as KeyPath, \Self._axisXPoint as KeyPath, \Self._axisXQuantitative as KeyPath, \Self._axisXTemporal as KeyPath, \Self._axisY as KeyPath, \Self._axisYBand as KeyPath, \Self._axisYDiscrete as KeyPath, \Self._axisYPoint as KeyPath, \Self._axisYQuantitative as KeyPath, \Self._axisYTemporal as KeyPath, \Self.background as KeyPath, \Self._bar as KeyPath, \Self._boxplot as KeyPath, \Self._circle as KeyPath, \Self._concat as KeyPath, \Self.countTitle as KeyPath, \Self.customFormatTypes as KeyPath, \Self._errorband as KeyPath, \Self._errorbar as KeyPath, \Self._facet as KeyPath, \Self.fieldTitle as KeyPath, \Self.font as KeyPath, \Self._geoshape as KeyPath, \Self._header as KeyPath, \Self._headerColumn as KeyPath, \Self._headerFacet as KeyPath, \Self._headerRow as KeyPath, \Self._image as KeyPath, \Self._legend as KeyPath, \Self._line as KeyPath, \Self.lineBreak as KeyPath, \Self.locale as KeyPath, \Self._mark as KeyPath, \Self.numberFormat as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self._point as KeyPath, \Self._projection as KeyPath, \Self._range as KeyPath, \Self._rect as KeyPath, \Self._rule as KeyPath, \Self._scale as KeyPath, \Self._selection as KeyPath, \Self._square as KeyPath, \Self.style as KeyPath, \Self._text as KeyPath, \Self._tick as KeyPath, \Self.timeFormat as KeyPath, \Self._title as KeyPath, \Self._trail as KeyPath, \Self._view as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self._arc as KeyPath : CodingKeys._arc, \Self._area as KeyPath : CodingKeys._area, \Self.aria as KeyPath : CodingKeys.aria, \Self.autosize as KeyPath : CodingKeys.autosize, \Self._axis as KeyPath : CodingKeys._axis, \Self._axisBand as KeyPath : CodingKeys._axisBand, \Self._axisBottom as KeyPath : CodingKeys._axisBottom, \Self._axisDiscrete as KeyPath : CodingKeys._axisDiscrete, \Self._axisLeft as KeyPath : CodingKeys._axisLeft, \Self._axisPoint as KeyPath : CodingKeys._axisPoint, \Self._axisQuantitative as KeyPath : CodingKeys._axisQuantitative, \Self._axisRight as KeyPath : CodingKeys._axisRight, \Self._axisTemporal as KeyPath : CodingKeys._axisTemporal, \Self._axisTop as KeyPath : CodingKeys._axisTop, \Self._axisX as KeyPath : CodingKeys._axisX, \Self._axisXBand as KeyPath : CodingKeys._axisXBand, \Self._axisXDiscrete as KeyPath : CodingKeys._axisXDiscrete, \Self._axisXPoint as KeyPath : CodingKeys._axisXPoint, \Self._axisXQuantitative as KeyPath : CodingKeys._axisXQuantitative, \Self._axisXTemporal as KeyPath : CodingKeys._axisXTemporal, \Self._axisY as KeyPath : CodingKeys._axisY, \Self._axisYBand as KeyPath : CodingKeys._axisYBand, \Self._axisYDiscrete as KeyPath : CodingKeys._axisYDiscrete, \Self._axisYPoint as KeyPath : CodingKeys._axisYPoint, \Self._axisYQuantitative as KeyPath : CodingKeys._axisYQuantitative, \Self._axisYTemporal as KeyPath : CodingKeys._axisYTemporal, \Self.background as KeyPath : CodingKeys.background, \Self._bar as KeyPath : CodingKeys._bar, \Self._boxplot as KeyPath : CodingKeys._boxplot, \Self._circle as KeyPath : CodingKeys._circle, \Self._concat as KeyPath : CodingKeys._concat, \Self.countTitle as KeyPath : CodingKeys.countTitle, \Self.customFormatTypes as KeyPath : CodingKeys.customFormatTypes, \Self._errorband as KeyPath : CodingKeys._errorband, \Self._errorbar as KeyPath : CodingKeys._errorbar, \Self._facet as KeyPath : CodingKeys._facet, \Self.fieldTitle as KeyPath : CodingKeys.fieldTitle, \Self.font as KeyPath : CodingKeys.font, \Self._geoshape as KeyPath : CodingKeys._geoshape, \Self._header as KeyPath : CodingKeys._header, \Self._headerColumn as KeyPath : CodingKeys._headerColumn, \Self._headerFacet as KeyPath : CodingKeys._headerFacet, \Self._headerRow as KeyPath : CodingKeys._headerRow, \Self._image as KeyPath : CodingKeys._image, \Self._legend as KeyPath : CodingKeys._legend, \Self._line as KeyPath : CodingKeys._line, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.locale as KeyPath : CodingKeys.locale, \Self._mark as KeyPath : CodingKeys._mark, \Self.numberFormat as KeyPath : CodingKeys.numberFormat, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self._point as KeyPath : CodingKeys._point, \Self._projection as KeyPath : CodingKeys._projection, \Self._range as KeyPath : CodingKeys._range, \Self._rect as KeyPath : CodingKeys._rect, \Self._rule as KeyPath : CodingKeys._rule, \Self._scale as KeyPath : CodingKeys._scale, \Self._selection as KeyPath : CodingKeys._selection, \Self._square as KeyPath : CodingKeys._square, \Self.style as KeyPath : CodingKeys.style, \Self._text as KeyPath : CodingKeys._text, \Self._tick as KeyPath : CodingKeys._tick, \Self.timeFormat as KeyPath : CodingKeys.timeFormat, \Self._title as KeyPath : CodingKeys._title, \Self._trail as KeyPath : CodingKeys._trail, \Self._view as KeyPath : CodingKeys._view]

    public init(arc: RectConfig? = nil, area: AreaConfig? = nil, aria: Bool? = nil, autosize: AutosizeChoice? = nil, axis: AxisConfig? = nil, axisBand: AxisConfig? = nil, axisBottom: AxisConfig? = nil, axisDiscrete: AxisConfig? = nil, axisLeft: AxisConfig? = nil, axisPoint: AxisConfig? = nil, axisQuantitative: AxisConfig? = nil, axisRight: AxisConfig? = nil, axisTemporal: AxisConfig? = nil, axisTop: AxisConfig? = nil, axisX: AxisConfig? = nil, axisXBand: AxisConfig? = nil, axisXDiscrete: AxisConfig? = nil, axisXPoint: AxisConfig? = nil, axisXQuantitative: AxisConfig? = nil, axisXTemporal: AxisConfig? = nil, axisY: AxisConfig? = nil, axisYBand: AxisConfig? = nil, axisYDiscrete: AxisConfig? = nil, axisYPoint: AxisConfig? = nil, axisYQuantitative: AxisConfig? = nil, axisYTemporal: AxisConfig? = nil, background: BackgroundChoice? = nil, bar: BarConfig? = nil, boxplot: BoxPlotConfig? = nil, circle: MarkConfig? = nil, concat: CompositionConfig? = nil, countTitle: String? = nil, customFormatTypes: Bool? = nil, errorband: ErrorBandConfig? = nil, errorbar: ErrorBarConfig? = nil, facet: CompositionConfig? = nil, fieldTitle: LiteralVerbalOrFunctionalOrPlain? = nil, font: FontName? = nil, geoshape: MarkConfig? = nil, header: HeaderConfig? = nil, headerColumn: HeaderConfig? = nil, headerFacet: HeaderConfig? = nil, headerRow: HeaderConfig? = nil, image: RectConfig? = nil, legend: LegendConfig? = nil, line: LineConfig? = nil, lineBreak: LineBreakChoice? = nil, locale: Locale? = nil, mark: MarkConfig? = nil, numberFormat: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, point: MarkConfig? = nil, projection: ProjectionConfig? = nil, range: RangeConfig? = nil, rect: RectConfig? = nil, rule: MarkConfig? = nil, scale: ScaleConfig? = nil, selection: SelectionConfig? = nil, square: MarkConfig? = nil, style: StyleConfigIndex? = nil, text: MarkConfig? = nil, tick: TickConfig? = nil, timeFormat: String? = nil, title: TitleConfig? = nil, trail: LineConfig? = nil, view: ViewConfig? = nil) {
        self._arc = arc.indirect() 
        self._area = area.indirect() 
        self.aria = aria 
        self.autosize = autosize 
        self._axis = axis.indirect() 
        self._axisBand = axisBand.indirect() 
        self._axisBottom = axisBottom.indirect() 
        self._axisDiscrete = axisDiscrete.indirect() 
        self._axisLeft = axisLeft.indirect() 
        self._axisPoint = axisPoint.indirect() 
        self._axisQuantitative = axisQuantitative.indirect() 
        self._axisRight = axisRight.indirect() 
        self._axisTemporal = axisTemporal.indirect() 
        self._axisTop = axisTop.indirect() 
        self._axisX = axisX.indirect() 
        self._axisXBand = axisXBand.indirect() 
        self._axisXDiscrete = axisXDiscrete.indirect() 
        self._axisXPoint = axisXPoint.indirect() 
        self._axisXQuantitative = axisXQuantitative.indirect() 
        self._axisXTemporal = axisXTemporal.indirect() 
        self._axisY = axisY.indirect() 
        self._axisYBand = axisYBand.indirect() 
        self._axisYDiscrete = axisYDiscrete.indirect() 
        self._axisYPoint = axisYPoint.indirect() 
        self._axisYQuantitative = axisYQuantitative.indirect() 
        self._axisYTemporal = axisYTemporal.indirect() 
        self.background = background 
        self._bar = bar.indirect() 
        self._boxplot = boxplot.indirect() 
        self._circle = circle.indirect() 
        self._concat = concat.indirect() 
        self.countTitle = countTitle 
        self.customFormatTypes = customFormatTypes 
        self._errorband = errorband.indirect() 
        self._errorbar = errorbar.indirect() 
        self._facet = facet.indirect() 
        self.fieldTitle = fieldTitle 
        self.font = font 
        self._geoshape = geoshape.indirect() 
        self._header = header.indirect() 
        self._headerColumn = headerColumn.indirect() 
        self._headerFacet = headerFacet.indirect() 
        self._headerRow = headerRow.indirect() 
        self._image = image.indirect() 
        self._legend = legend.indirect() 
        self._line = line.indirect() 
        self.lineBreak = lineBreak 
        self.locale = locale 
        self._mark = mark.indirect() 
        self.numberFormat = numberFormat 
        self.padding = padding 
        self.params = params 
        self._point = point.indirect() 
        self._projection = projection.indirect() 
        self._range = range.indirect() 
        self._rect = rect.indirect() 
        self._rule = rule.indirect() 
        self._scale = scale.indirect() 
        self._selection = selection.indirect() 
        self._square = square.indirect() 
        self.style = style 
        self._text = text.indirect() 
        self._tick = tick.indirect() 
        self.timeFormat = timeFormat 
        self._title = title.indirect() 
        self._trail = trail.indirect() 
        self._view = view.indirect() 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self._arc = try values.decodeOptional(Indirect<RectConfig>.self, forKey: ._arc) 
        self._area = try values.decodeOptional(Indirect<AreaConfig>.self, forKey: ._area) 
        self.aria = try values.decodeOptional(Bool.self, forKey: .aria) 
        self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
        self._axis = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axis) 
        self._axisBand = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisBand) 
        self._axisBottom = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisBottom) 
        self._axisDiscrete = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisDiscrete) 
        self._axisLeft = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisLeft) 
        self._axisPoint = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisPoint) 
        self._axisQuantitative = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisQuantitative) 
        self._axisRight = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisRight) 
        self._axisTemporal = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisTemporal) 
        self._axisTop = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisTop) 
        self._axisX = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisX) 
        self._axisXBand = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisXBand) 
        self._axisXDiscrete = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisXDiscrete) 
        self._axisXPoint = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisXPoint) 
        self._axisXQuantitative = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisXQuantitative) 
        self._axisXTemporal = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisXTemporal) 
        self._axisY = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisY) 
        self._axisYBand = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisYBand) 
        self._axisYDiscrete = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisYDiscrete) 
        self._axisYPoint = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisYPoint) 
        self._axisYQuantitative = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisYQuantitative) 
        self._axisYTemporal = try values.decodeOptional(Indirect<AxisConfig>.self, forKey: ._axisYTemporal) 
        self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
        self._bar = try values.decodeOptional(Indirect<BarConfig>.self, forKey: ._bar) 
        self._boxplot = try values.decodeOptional(Indirect<BoxPlotConfig>.self, forKey: ._boxplot) 
        self._circle = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._circle) 
        self._concat = try values.decodeOptional(Indirect<CompositionConfig>.self, forKey: ._concat) 
        self.countTitle = try values.decodeOptional(String.self, forKey: .countTitle) 
        self.customFormatTypes = try values.decodeOptional(Bool.self, forKey: .customFormatTypes) 
        self._errorband = try values.decodeOptional(Indirect<ErrorBandConfig>.self, forKey: ._errorband) 
        self._errorbar = try values.decodeOptional(Indirect<ErrorBarConfig>.self, forKey: ._errorbar) 
        self._facet = try values.decodeOptional(Indirect<CompositionConfig>.self, forKey: ._facet) 
        self.fieldTitle = try values.decodeOptional(LiteralVerbalOrFunctionalOrPlain.self, forKey: .fieldTitle) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self._geoshape = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._geoshape) 
        self._header = try values.decodeOptional(Indirect<HeaderConfig>.self, forKey: ._header) 
        self._headerColumn = try values.decodeOptional(Indirect<HeaderConfig>.self, forKey: ._headerColumn) 
        self._headerFacet = try values.decodeOptional(Indirect<HeaderConfig>.self, forKey: ._headerFacet) 
        self._headerRow = try values.decodeOptional(Indirect<HeaderConfig>.self, forKey: ._headerRow) 
        self._image = try values.decodeOptional(Indirect<RectConfig>.self, forKey: ._image) 
        self._legend = try values.decodeOptional(Indirect<LegendConfig>.self, forKey: ._legend) 
        self._line = try values.decodeOptional(Indirect<LineConfig>.self, forKey: ._line) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.locale = try values.decodeOptional(Locale.self, forKey: .locale) 
        self._mark = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._mark) 
        self.numberFormat = try values.decodeOptional(String.self, forKey: .numberFormat) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self._point = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._point) 
        self._projection = try values.decodeOptional(Indirect<ProjectionConfig>.self, forKey: ._projection) 
        self._range = try values.decodeOptional(Indirect<RangeConfig>.self, forKey: ._range) 
        self._rect = try values.decodeOptional(Indirect<RectConfig>.self, forKey: ._rect) 
        self._rule = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._rule) 
        self._scale = try values.decodeOptional(Indirect<ScaleConfig>.self, forKey: ._scale) 
        self._selection = try values.decodeOptional(Indirect<SelectionConfig>.self, forKey: ._selection) 
        self._square = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._square) 
        self.style = try values.decodeOptional(StyleConfigIndex.self, forKey: .style) 
        self._text = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._text) 
        self._tick = try values.decodeOptional(Indirect<TickConfig>.self, forKey: ._tick) 
        self.timeFormat = try values.decodeOptional(String.self, forKey: .timeFormat) 
        self._title = try values.decodeOptional(Indirect<TitleConfig>.self, forKey: ._title) 
        self._trail = try values.decodeOptional(Indirect<LineConfig>.self, forKey: ._trail) 
        self._view = try values.decodeOptional(Indirect<ViewConfig>.self, forKey: ._view) 
    }

    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    /// Generated by Curio
    public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    /// Generated by Curio
    public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// A delimiter, such as a newline character, upon which to break text strings into multiple lines. This property provides a global default for text marks, which is overridden by mark or style config settings, and by the lineBreak mark encoding channel. If signal-valued, either string or regular expression (regexp) values are valid.
    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<TopLevelSelectionParameter>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case _arc = "arc"
        case _area = "area"
        case aria
        case autosize
        case _axis = "axis"
        case _axisBand = "axisBand"
        case _axisBottom = "axisBottom"
        case _axisDiscrete = "axisDiscrete"
        case _axisLeft = "axisLeft"
        case _axisPoint = "axisPoint"
        case _axisQuantitative = "axisQuantitative"
        case _axisRight = "axisRight"
        case _axisTemporal = "axisTemporal"
        case _axisTop = "axisTop"
        case _axisX = "axisX"
        case _axisXBand = "axisXBand"
        case _axisXDiscrete = "axisXDiscrete"
        case _axisXPoint = "axisXPoint"
        case _axisXQuantitative = "axisXQuantitative"
        case _axisXTemporal = "axisXTemporal"
        case _axisY = "axisY"
        case _axisYBand = "axisYBand"
        case _axisYDiscrete = "axisYDiscrete"
        case _axisYPoint = "axisYPoint"
        case _axisYQuantitative = "axisYQuantitative"
        case _axisYTemporal = "axisYTemporal"
        case background
        case _bar = "bar"
        case _boxplot = "boxplot"
        case _circle = "circle"
        case _concat = "concat"
        case countTitle
        case customFormatTypes
        case _errorband = "errorband"
        case _errorbar = "errorbar"
        case _facet = "facet"
        case fieldTitle
        case font
        case _geoshape = "geoshape"
        case _header = "header"
        case _headerColumn = "headerColumn"
        case _headerFacet = "headerFacet"
        case _headerRow = "headerRow"
        case _image = "image"
        case _legend = "legend"
        case _line = "line"
        case lineBreak
        case locale
        case _mark = "mark"
        case numberFormat
        case padding
        case params
        case _point = "point"
        case _projection = "projection"
        case _range = "range"
        case _rect = "rect"
        case _rule = "rule"
        case _scale = "scale"
        case _selection = "selection"
        case _square = "square"
        case style
        case _text = "text"
        case _tick = "tick"
        case timeFormat
        case _title = "title"
        case _trail = "trail"
        case _view = "view"
        public var keyDescription: String? {
            switch self {
            case ._arc: return "Arc-specific Config"
            case ._area: return "Area-Specific Config"
            case .aria: return "A boolean flag indicating if ARIA default attributes should be included for marks and guides (SVG output only). If false, the `\"aria-hidden\"` attribute will be set for all guides, removing them from the ARIA accessibility tree and Vega-Lite will not generate default descriptions for marks.\n\n__Default value:__ `true`."
            case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
            case ._axis: return "Axis configuration, which determines default properties for all `x` and `y` [axes](https://vega.github.io/vega-lite/docs/axis.html). For a full list of axis configuration options, please see the [corresponding section of the axis documentation](https://vega.github.io/vega-lite/docs/axis.html#config)."
            case ._axisBand: return "Config for axes with \"band\" scales."
            case ._axisBottom: return "Config for x-axis along the bottom edge of the chart."
            case ._axisDiscrete: return "Config for axes with \"point\" or \"band\" scales."
            case ._axisLeft: return "Config for y-axis along the left edge of the chart."
            case ._axisPoint: return "Config for axes with \"point\" scales."
            case ._axisQuantitative: return "Config for quantitative axes."
            case ._axisRight: return "Config for y-axis along the right edge of the chart."
            case ._axisTemporal: return "Config for temporal axes."
            case ._axisTop: return "Config for x-axis along the top edge of the chart."
            case ._axisX: return "X-axis specific config."
            case ._axisXBand: return "Config for x-axes with \"band\" scales."
            case ._axisXDiscrete: return "Config for x-axes with \"point\" or \"band\" scales."
            case ._axisXPoint: return "Config for x-axes with \"point\" scales."
            case ._axisXQuantitative: return "Config for x-quantitative axes."
            case ._axisXTemporal: return "Config for x-temporal axes."
            case ._axisY: return "Y-axis specific config."
            case ._axisYBand: return "Config for y-axes with \"band\" scales."
            case ._axisYDiscrete: return "Config for y-axes with \"point\" or \"band\" scales."
            case ._axisYPoint: return "Config for y-axes with \"point\" scales."
            case ._axisYQuantitative: return "Config for y-quantitative axes."
            case ._axisYTemporal: return "Config for y-temporal axes."
            case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
            case ._bar: return "Bar-Specific Config"
            case ._boxplot: return "Box Config"
            case ._circle: return "Circle-Specific Config"
            case ._concat: return "Default configuration for all concatenation and repeat view composition operators (`concat`, `hconcat`, `vconcat`, and `repeat`)"
            case .countTitle: return "Default axis and legend title for count fields.\n\n__Default value:__ `'Count of Records`."
            case .customFormatTypes: return "Allow the `formatType` property for text marks and guides to accept a custom formatter function [registered as a Vega expression](https://vega.github.io/vega-lite/usage/compile.html#format-type)."
            case ._errorband: return "ErrorBand Config"
            case ._errorbar: return "ErrorBar Config"
            case ._facet: return "Default configuration for the `facet` view composition operator"
            case .fieldTitle: return "Defines how Vega-Lite generates title for fields. There are three possible styles:\n- `\"verbal\"` (Default) - displays function in a verbal style (e.g., \"Sum of field\", \"Year-month of date\", \"field (binned)\").\n- `\"function\"` - displays function using parentheses and capitalized texts (e.g., \"SUM(field)\", \"YEARMONTH(date)\", \"BIN(field)\").\n- `\"plain\"` - displays only the field name without functions (e.g., \"field\", \"date\", \"field\")."
            case .font: return "Default font for all text marks, titles, and labels."
            case ._geoshape: return "Geoshape-Specific Config"
            case ._header: return "Header configuration, which determines default properties for all [headers](https://vega.github.io/vega-lite/docs/header.html).\n\nFor a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config)."
            case ._headerColumn: return "Header configuration, which determines default properties for column [headers](https://vega.github.io/vega-lite/docs/header.html).\n\nFor a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config)."
            case ._headerFacet: return "Header configuration, which determines default properties for non-row/column facet [headers](https://vega.github.io/vega-lite/docs/header.html).\n\nFor a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config)."
            case ._headerRow: return "Header configuration, which determines default properties for row [headers](https://vega.github.io/vega-lite/docs/header.html).\n\nFor a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config)."
            case ._image: return "Image-specific Config"
            case ._legend: return "Legend configuration, which determines default properties for all [legends](https://vega.github.io/vega-lite/docs/legend.html). For a full list of legend configuration options, please see the [corresponding section of in the legend documentation](https://vega.github.io/vega-lite/docs/legend.html#config)."
            case ._line: return "Line-Specific Config"
            case .lineBreak: return "A delimiter, such as a newline character, upon which to break text strings into multiple lines. This property provides a global default for text marks, which is overridden by mark or style config settings, and by the lineBreak mark encoding channel. If signal-valued, either string or regular expression (regexp) values are valid."
            case .locale: return "Locale definitions for string parsing and formatting of number and date values. The locale object should contain `number` and/or `time` properties with [locale definitions](https://vega.github.io/vega/docs/api/locale/). Locale definitions provided in the config block may be overridden by the View constructor locale option."
            case ._mark: return "Mark Config"
            case .numberFormat: return "D3 Number format for guide labels and text marks. For example `\"s\"` for SI units. Use [D3's number format pattern](https://github.com/d3/d3-format#locale_format)."
            case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
            case .params: return "Dynamic variables or selections that parameterize a visualization."
            case ._point: return "Point-Specific Config"
            case ._projection: return "Projection configuration, which determines default properties for all [projections](https://vega.github.io/vega-lite/docs/projection.html). For a full list of projection configuration options, please see the [corresponding section of the projection documentation](https://vega.github.io/vega-lite/docs/projection.html#config)."
            case ._range: return "An object hash that defines default range arrays or schemes for using with scales. For a full list of scale range configuration options, please see the [corresponding section of the scale documentation](https://vega.github.io/vega-lite/docs/scale.html#config)."
            case ._rect: return "Rect-Specific Config"
            case ._rule: return "Rule-Specific Config"
            case ._scale: return "Scale configuration determines default properties for all [scales](https://vega.github.io/vega-lite/docs/scale.html). For a full list of scale configuration options, please see the [corresponding section of the scale documentation](https://vega.github.io/vega-lite/docs/scale.html#config)."
            case ._selection: return "An object hash for defining default properties for each type of selections."
            case ._square: return "Square-Specific Config"
            case .style: return "An object hash that defines key-value mappings to determine default properties for marks with a given [style](https://vega.github.io/vega-lite/docs/mark.html#mark-def). The keys represent styles names; the values have to be valid [mark configuration objects](https://vega.github.io/vega-lite/docs/mark.html#config)."
            case ._text: return "Text-Specific Config"
            case ._tick: return "Tick-Specific Config"
            case .timeFormat: return "Default time format for raw time values (without time units) in text marks, legend labels and header labels.\n\n__Default value:__ `\"%b %d, %Y\"` __Note:__ Axes automatically determine the format for each label automatically so this config does not affect axes."
            case ._title: return "Title configuration, which determines default properties for all [titles](https://vega.github.io/vega-lite/docs/title.html). For a full list of title configuration options, please see the [corresponding section of the title documentation](https://vega.github.io/vega-lite/docs/title.html#config)."
            case ._trail: return "Trail-Specific Config"
            case ._view: return "Default properties for [single view plots](https://vega.github.io/vega-lite/docs/spec.html#single)."
             } 
        }

        public typealias CodingOwner = ConfigTheme
    }

    /// Defines how Vega-Lite generates title for fields. There are three possible styles:
    /// - `"verbal"` (Default) - displays function in a verbal style (e.g., "Sum of field", "Year-month of date", "field (binned)").
    /// - `"function"` - displays function using parentheses and capitalized texts (e.g., "SUM(field)", "YEARMONTH(date)", "BIN(field)").
    /// - `"plain"` - displays only the field name without functions (e.g., "field", "date", "field").
    /// Generated by Curio
    public enum LiteralVerbalOrFunctionalOrPlain : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case verbal
        case functional
        case plain
    }
}

/// Generated by Curio
public struct CsvDataFormat : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
    /// For `"date"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
    public var parse: ParseChoice?
    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// __Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `"json"` will be used by default.
    public var type: LiteralCsvOrTsv?
    public static let codingKeyPaths = (\Self.parse as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.parse as KeyPath : CodingKeys.parse, \Self.type as KeyPath : CodingKeys.type]

    public init(parse: ParseChoice? = nil, type: LiteralCsvOrTsv? = nil) {
        self.parse = parse 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.parse = try values.decodeOptional(ParseChoice.self, forKey: .parse) 
        self.type = try values.decodeOptional(LiteralCsvOrTsv.self, forKey: .type) 
    }

    /// If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
    /// For `"date"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
    /// Generated by Curio
    public typealias ParseChoice = Nullable<Parse>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case parse
        case type
        public var keyDescription: String? {
            switch self {
            case .parse: return "If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"`, `\"date\"`, or null (do not parse the field)). For example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n\nFor `\"date\"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: \"date:'%m%d%Y'\"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: \"utc:'%m%d%Y'\"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)"
            case .type: return "Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n\n__Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `\"json\"` will be used by default."
             } 
        }

        public typealias CodingOwner = CsvDataFormat
    }

    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// __Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `"json"` will be used by default.
    /// Generated by Curio
    public enum LiteralCsvOrTsv : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case csv
        case tsv
    }
}

public struct DataFormat : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<CsvDataFormat>.Or<DsvDataFormat>.Or<JsonDataFormat>.Or<TopoDataFormat>

    public init(rawValue: OneOf<CsvDataFormat>.Or<DsvDataFormat>.Or<JsonDataFormat>.Or<TopoDataFormat>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<CsvDataFormat>.Or<DsvDataFormat>.Or<JsonDataFormat>.Or<TopoDataFormat>) {
        self.rawValue = rawValue 
    }
}

public struct DataProvider : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<DataSource>.Or<Generator>

    public init(rawValue: OneOf<DataSource>.Or<Generator>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<DataSource>.Or<Generator>) {
        self.rawValue = rawValue 
    }
}

public struct DataSource : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<UrlData>.Or<InlineData>.Or<NamedData>

    public init(rawValue: OneOf<UrlData>.Or<InlineData>.Or<NamedData>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<UrlData>.Or<InlineData>.Or<NamedData>) {
        self.rawValue = rawValue 
    }
}

/// Object for defining datetime in Vega-Lite Filter. If both month and quarter are provided, month has higher precedence. `day` cannot be combined with other date. We accept string for month and day names.
/// Generated by Curio
public struct DateTime : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Integer value representing the date (day of the month) from 1-31.
    public var date: Double?
    /// Value representing the day of a week. This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3) case-insensitive, 3-character short day name (e.g., `"Mon"`).
    /// **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`.
    public var day: DayChoice?
    /// Integer value representing the hour of a day from 0-23.
    public var hours: Double?
    /// Integer value representing the millisecond segment of time.
    public var milliseconds: Double?
    /// Integer value representing the minute segment of time from 0-59.
    public var minutes: Double?
    /// One of: (1) integer value representing the month from `1`-`12`. `1` represents January; (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character short month name (e.g., `"Jan"`).
    public var month: MonthChoice?
    /// Integer value representing the quarter of the year (from 1-4).
    public var quarter: Double?
    /// Integer value representing the second segment (0-59) of a time value
    public var seconds: Double?
    /// A boolean flag indicating if date time is in utc time. If false, the date time is in local time
    public var utc: Bool?
    /// Integer value representing the year.
    public var year: Double?
    public static let codingKeyPaths = (\Self.date as KeyPath, \Self.day as KeyPath, \Self.hours as KeyPath, \Self.milliseconds as KeyPath, \Self.minutes as KeyPath, \Self.month as KeyPath, \Self.quarter as KeyPath, \Self.seconds as KeyPath, \Self.utc as KeyPath, \Self.year as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.date as KeyPath : CodingKeys.date, \Self.day as KeyPath : CodingKeys.day, \Self.hours as KeyPath : CodingKeys.hours, \Self.milliseconds as KeyPath : CodingKeys.milliseconds, \Self.minutes as KeyPath : CodingKeys.minutes, \Self.month as KeyPath : CodingKeys.month, \Self.quarter as KeyPath : CodingKeys.quarter, \Self.seconds as KeyPath : CodingKeys.seconds, \Self.utc as KeyPath : CodingKeys.utc, \Self.year as KeyPath : CodingKeys.year]

    public init(date: Double? = nil, day: DayChoice? = nil, hours: Double? = nil, milliseconds: Double? = nil, minutes: Double? = nil, month: MonthChoice? = nil, quarter: Double? = nil, seconds: Double? = nil, utc: Bool? = nil, year: Double? = nil) {
        self.date = date 
        self.day = day 
        self.hours = hours 
        self.milliseconds = milliseconds 
        self.minutes = minutes 
        self.month = month 
        self.quarter = quarter 
        self.seconds = seconds 
        self.utc = utc 
        self.year = year 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.date = try values.decodeOptional(Double.self, forKey: .date) 
        self.day = try values.decodeOptional(DayChoice.self, forKey: .day) 
        self.hours = try values.decodeOptional(Double.self, forKey: .hours) 
        self.milliseconds = try values.decodeOptional(Double.self, forKey: .milliseconds) 
        self.minutes = try values.decodeOptional(Double.self, forKey: .minutes) 
        self.month = try values.decodeOptional(MonthChoice.self, forKey: .month) 
        self.quarter = try values.decodeOptional(Double.self, forKey: .quarter) 
        self.seconds = try values.decodeOptional(Double.self, forKey: .seconds) 
        self.utc = try values.decodeOptional(Bool.self, forKey: .utc) 
        self.year = try values.decodeOptional(Double.self, forKey: .year) 
    }

    /// Value representing the day of a week. This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3) case-insensitive, 3-character short day name (e.g., `"Mon"`).
    /// **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`.
    /// Generated by Curio
    public typealias DayChoice = OneOf<Day>.Or<String>

    /// One of: (1) integer value representing the month from `1`-`12`. `1` represents January; (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character short month name (e.g., `"Jan"`).
    /// Generated by Curio
    public typealias MonthChoice = OneOf<Month>.Or<String>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case date
        case day
        case hours
        case milliseconds
        case minutes
        case month
        case quarter
        case seconds
        case utc
        case year
        public var keyDescription: String? {
            switch self {
            case .date: return "Integer value representing the date (day of the month) from 1-31."
            case .day: return "Value representing the day of a week. This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `\"Monday\"`); (3) case-insensitive, 3-character short day name (e.g., `\"Mon\"`).\n\n**Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`."
            case .hours: return "Integer value representing the hour of a day from 0-23."
            case .milliseconds: return "Integer value representing the millisecond segment of time."
            case .minutes: return "Integer value representing the minute segment of time from 0-59."
            case .month: return "One of: (1) integer value representing the month from `1`-`12`. `1` represents January; (2) case-insensitive month name (e.g., `\"January\"`); (3) case-insensitive, 3-character short month name (e.g., `\"Jan\"`)."
            case .quarter: return "Integer value representing the quarter of the year (from 1-4)."
            case .seconds: return "Integer value representing the second segment (0-59) of a time value"
            case .utc: return "A boolean flag indicating if date time is in utc time. If false, the date time is in local time"
            case .year: return "Integer value representing the year."
             } 
        }

        public typealias CodingOwner = DateTime
    }
}

/// Generated by Curio
public struct DatumDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A constant value in data domain.
    public var datum: DatumChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: MeasureType?
    public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.datum as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.datum as KeyPath : CodingKeys.datum, \Self.type as KeyPath : CodingKeys.type]

    public init(bandPosition: Double? = nil, datum: DatumChoice? = nil, type: MeasureType? = nil) {
        self.bandPosition = bandPosition 
        self.datum = datum 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
        self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
    }

    /// A constant value in data domain.
    /// Generated by Curio
    public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case bandPosition
        case datum
        case type
        public var keyDescription: String? {
            switch self {
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .datum: return "A constant value in data domain."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = DatumDef
    }
}

public struct Day : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: UInt8

    public init(rawValue: UInt8) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: UInt8) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct DensityTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output fields for the sample value and corresponding density estimate.
    /// __Default value:__ `["value", "density"]`
    public var `as`: [FieldName]?
    /// The bandwidth (standard deviation) of the Gaussian kernel. If unspecified or set to zero, the bandwidth value is automatically estimated from the input data using Scott’s rule.
    public var bandwidth: Double?
    /// A boolean flag indicating if the output values should be probability estimates (false) or smoothed counts (true).
    /// __Default value:__ `false`
    public var counts: Bool?
    /// A boolean flag indicating whether to produce density estimates (false) or cumulative density estimates (true).
    /// __Default value:__ `false`
    public var cumulative: Bool?
    /// The data field for which to perform density estimation.
    public var density: FieldName
    /// A [min, max] domain from which to sample the distribution. If unspecified, the extent will be determined by the observed minimum and maximum values of the density value field.
    public var extent: [ExtentItem]?
    /// The data fields to group by. If not specified, a single group containing all data objects will be used.
    public var groupby: [FieldName]?
    /// The maximum number of samples to take along the extent domain for plotting the density.
    /// __Default value:__ `200`
    public var maxsteps: Double?
    /// The minimum number of samples to take along the extent domain for plotting the density.
    /// __Default value:__ `25`
    public var minsteps: Double?
    /// The exact number of samples to take along the extent domain for plotting the density. If specified, overrides both minsteps and maxsteps to set an exact number of uniform samples. Potentially useful in conjunction with a fixed extent to ensure consistent sample points for stacked densities.
    public var steps: Double?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.bandwidth as KeyPath, \Self.counts as KeyPath, \Self.cumulative as KeyPath, \Self.density as KeyPath, \Self.extent as KeyPath, \Self.groupby as KeyPath, \Self.maxsteps as KeyPath, \Self.minsteps as KeyPath, \Self.steps as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.bandwidth as KeyPath : CodingKeys.bandwidth, \Self.counts as KeyPath : CodingKeys.counts, \Self.cumulative as KeyPath : CodingKeys.cumulative, \Self.density as KeyPath : CodingKeys.density, \Self.extent as KeyPath : CodingKeys.extent, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.maxsteps as KeyPath : CodingKeys.maxsteps, \Self.minsteps as KeyPath : CodingKeys.minsteps, \Self.steps as KeyPath : CodingKeys.steps]

    public init(id: TransformId? = nil, `as`: [FieldName]? = nil, bandwidth: Double? = nil, counts: Bool? = nil, cumulative: Bool? = nil, density: FieldName, extent: [ExtentItem]? = nil, groupby: [FieldName]? = nil, maxsteps: Double? = nil, minsteps: Double? = nil, steps: Double? = nil) {
        self.id = id 
        self.`as` = `as` 
        self.bandwidth = bandwidth 
        self.counts = counts 
        self.cumulative = cumulative 
        self.density = density 
        self.extent = extent 
        self.groupby = groupby 
        self.maxsteps = maxsteps 
        self.minsteps = minsteps 
        self.steps = steps 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decodeOptional([FieldName].self, forKey: .`as`) 
        self.bandwidth = try values.decodeOptional(Double.self, forKey: .bandwidth) 
        self.counts = try values.decodeOptional(Bool.self, forKey: .counts) 
        self.cumulative = try values.decodeOptional(Bool.self, forKey: .cumulative) 
        self.density = try values.decode(FieldName.self, forKey: .density) 
        self.extent = try values.decodeOptional([ExtentItem].self, forKey: .extent) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
        self.maxsteps = try values.decodeOptional(Double.self, forKey: .maxsteps) 
        self.minsteps = try values.decodeOptional(Double.self, forKey: .minsteps) 
        self.steps = try values.decodeOptional(Double.self, forKey: .steps) 
    }

    public typealias ExtentItem = Double

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case bandwidth
        case counts
        case cumulative
        case density
        case extent
        case groupby
        case maxsteps
        case minsteps
        case steps
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output fields for the sample value and corresponding density estimate.\n\n__Default value:__ `[\"value\", \"density\"]`"
            case .bandwidth: return "The bandwidth (standard deviation) of the Gaussian kernel. If unspecified or set to zero, the bandwidth value is automatically estimated from the input data using Scott’s rule."
            case .counts: return "A boolean flag indicating if the output values should be probability estimates (false) or smoothed counts (true).\n\n__Default value:__ `false`"
            case .cumulative: return "A boolean flag indicating whether to produce density estimates (false) or cumulative density estimates (true).\n\n__Default value:__ `false`"
            case .density: return "The data field for which to perform density estimation."
            case .extent: return "A [min, max] domain from which to sample the distribution. If unspecified, the extent will be determined by the observed minimum and maximum values of the density value field."
            case .groupby: return "The data fields to group by. If not specified, a single group containing all data objects will be used."
            case .maxsteps: return "The maximum number of samples to take along the extent domain for plotting the density.\n\n__Default value:__ `200`"
            case .minsteps: return "The minimum number of samples to take along the extent domain for plotting the density.\n\n__Default value:__ `25`"
            case .steps: return "The exact number of samples to take along the extent domain for plotting the density. If specified, overrides both minsteps and maxsteps to set an exact number of uniform samples. Potentially useful in conjunction with a fixed extent to ensure consistent sample points for stacked densities."
             } 
        }

        public typealias CodingOwner = DensityTransform
    }
}

/// Generated by Curio
public struct DerivedStream : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var between: [Stream]?
    public var consume: Bool?
    public var debounce: Double?
    public var filter: FilterChoice?
    public var markname: String?
    public var marktype: VgMarkType?
    public var stream: Stream
    public var throttle: Double?
    public static let codingKeyPaths = (\Self.between as KeyPath, \Self.consume as KeyPath, \Self.debounce as KeyPath, \Self.filter as KeyPath, \Self.markname as KeyPath, \Self.marktype as KeyPath, \Self.stream as KeyPath, \Self.throttle as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.between as KeyPath : CodingKeys.between, \Self.consume as KeyPath : CodingKeys.consume, \Self.debounce as KeyPath : CodingKeys.debounce, \Self.filter as KeyPath : CodingKeys.filter, \Self.markname as KeyPath : CodingKeys.markname, \Self.marktype as KeyPath : CodingKeys.marktype, \Self.stream as KeyPath : CodingKeys.stream, \Self.throttle as KeyPath : CodingKeys.throttle]

    public init(between: [Stream]? = nil, consume: Bool? = nil, debounce: Double? = nil, filter: FilterChoice? = nil, markname: String? = nil, marktype: VgMarkType? = nil, stream: Stream, throttle: Double? = nil) {
        self.between = between 
        self.consume = consume 
        self.debounce = debounce 
        self.filter = filter 
        self.markname = markname 
        self.marktype = marktype 
        self.stream = stream 
        self.throttle = throttle 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.between = try values.decodeOptional([Stream].self, forKey: .between) 
        self.consume = try values.decodeOptional(Bool.self, forKey: .consume) 
        self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
        self.filter = try values.decodeOptional(FilterChoice.self, forKey: .filter) 
        self.markname = try values.decodeOptional(String.self, forKey: .markname) 
        self.marktype = try values.decodeOptional(VgMarkType.self, forKey: .marktype) 
        self.stream = try values.decode(Stream.self, forKey: .stream) 
        self.throttle = try values.decodeOptional(Double.self, forKey: .throttle) 
    }

    /// Generated by Curio
    public typealias FilterChoice = OneOrMany<Expr>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case between
        case consume
        case debounce
        case filter
        case markname
        case marktype
        case stream
        case throttle
        public var keyDescription: String? {
            switch self {
            case .between: return nil
            case .consume: return nil
            case .debounce: return nil
            case .filter: return nil
            case .markname: return nil
            case .marktype: return nil
            case .stream: return nil
            case .throttle: return nil
             } 
        }

        public typealias CodingOwner = DerivedStream
    }
}

/// Generated by Curio
public struct DomainUnionWith : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Customized domain values to be union with the field's values or explicitly defined domain. Should be an array of valid scale domain values.
    public var unionWith: UnionWithChoice
    public static let codingKeyPaths = (\Self.unionWith as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.unionWith as KeyPath : CodingKeys.unionWith]

    public init(unionWith: UnionWithChoice) {
        self.unionWith = unionWith 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.unionWith = try values.decode(UnionWithChoice.self, forKey: .unionWith) 
    }

    /// Customized domain values to be union with the field's values or explicitly defined domain. Should be an array of valid scale domain values.
    /// Generated by Curio
    public typealias UnionWithChoice = OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[DateTime]>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case unionWith
        public var keyDescription: String? {
            switch self {
            case .unionWith: return "Customized domain values to be union with the field's values or explicitly defined domain. Should be an array of valid scale domain values."
             } 
        }

        public typealias CodingOwner = DomainUnionWith
    }
}

/// Generated by Curio
public struct DsvDataFormat : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The delimiter between records. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.
    public var delimiter: String
    /// If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
    /// For `"date"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
    public var parse: ParseChoice?
    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// __Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `"json"` will be used by default.
    public var type: LiteralDsv?
    public static let codingKeyPaths = (\Self.delimiter as KeyPath, \Self.parse as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.delimiter as KeyPath : CodingKeys.delimiter, \Self.parse as KeyPath : CodingKeys.parse, \Self.type as KeyPath : CodingKeys.type]

    public init(delimiter: String, parse: ParseChoice? = nil, type: LiteralDsv? = nil) {
        self.delimiter = delimiter 
        self.parse = parse 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.delimiter = try values.decode(String.self, forKey: .delimiter) 
        self.parse = try values.decodeOptional(ParseChoice.self, forKey: .parse) 
        self.type = try values.decodeOptional(LiteralDsv.self, forKey: .type) 
    }

    /// If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
    /// For `"date"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
    /// Generated by Curio
    public typealias ParseChoice = Nullable<Parse>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case delimiter
        case parse
        case type
        public var keyDescription: String? {
            switch self {
            case .delimiter: return "The delimiter between records. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not."
            case .parse: return "If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"`, `\"date\"`, or null (do not parse the field)). For example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n\nFor `\"date\"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: \"date:'%m%d%Y'\"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: \"utc:'%m%d%Y'\"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)"
            case .type: return "Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n\n__Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `\"json\"` will be used by default."
             } 
        }

        public typealias CodingOwner = DsvDataFormat
    }

    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// __Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `"json"` will be used by default.
    /// Generated by Curio
    public enum LiteralDsv : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case dsv
    }
}

public struct Element : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: String) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct Encoding : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Rotation angle of point and text marks.
    public var angle: AngleEncoding?
    /// Color of the marks – either fill or stroke color based on  the `filled` property of mark definition. By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`, `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and `"point"`.
    /// __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.
    /// _Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified. 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
    public var color: ColorEncoding?
    /// A text description of this mark for ARIA accessibility (SVG output only). For SVG output the `"aria-label"` attribute will be set to this description.
    public var description: DescriptionEncoding?
    /// Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel.
    public var detail: DetailEncoding?
    /// Fill color of the marks. __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.
    /// _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.
    public var fill: FillEncoding?
    /// Fill opacity of the marks.
    /// __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity` property.
    public var fillOpacity: FillOpacityEncoding?
    /// A URL to load upon mouse click.
    public var href: HrefEncoding?
    /// A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data.
    public var key: KeyEncoding?
    /// Latitude position of geographically projected marks.
    public var latitude: LatitudeEncoding?
    /// Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    public var latitude2: Latitude2Encoding?
    /// Longitude position of geographically projected marks.
    public var longitude: LongitudeEncoding?
    /// Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    public var longitude2: Longitude2Encoding?
    /// Opacity of the marks.
    /// __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity` property.
    public var opacity: OpacityEncoding?
    /// Order of the marks.
    /// - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).
    /// - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{"value": null}` makes the line marks use the original order in the data sources.
    /// - Otherwise, this `order` channel encodes layer order of the marks.
    /// __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.
    public var order: OrderEncoding?
    /// The outer radius in pixels of arc marks.
    public var radius: RadiusEncoding?
    /// The inner radius in pixels of arc marks.
    public var radius2: Radius2Encoding?
    /// Shape of the mark.
    /// 1. For `point` marks the supported values include:   - plotting shapes: `"circle"`, `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, `"triangle-down"`, `"triangle-right"`, or `"triangle-left"`.   - the line symbol `"stroke"`   - centered directional shapes `"arrow"`, `"wedge"`, or `"triangle"`   - a custom [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct sizing, custom shape paths should be defined within a square bounding box with coordinates ranging from -1 to 1 along both the x and y dimensions.)
    /// 2. For `geoshape` marks it should be a field definition of the geojson data
    /// __Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property. (`"circle"` if unset.)
    public var shape: ShapeEncoding?
    /// Size of the mark.
    /// - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
    /// - For `"bar"` and `"tick"` – the bar and tick's size.
    /// - For `"text"` – the text's font size.
    /// - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of line with varying size)
    public var size: SizeEncoding?
    /// Stroke color of the marks. __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.
    /// _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.
    public var stroke: StrokeEncoding?
    /// Stroke dash of the marks.
    /// __Default value:__ `[1,0]` (No dash).
    public var strokeDash: StrokeDashEncoding?
    /// Stroke opacity of the marks.
    /// __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity` property.
    public var strokeOpacity: StrokeOpacityEncoding?
    /// Stroke width of the marks.
    /// __Default value:__ If undefined, the default stroke width depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth` property.
    public var strokeWidth: StrokeWidthEncoding?
    /// Text of the `text` mark.
    public var text: TextEncoding?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaEncoding?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Encoding?
    /// The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite.
    public var tooltip: TooltipEncoding?
    /// The URL of an image mark.
    public var url: UrlEncoding?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XEncoding?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Encoding?
    /// Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    public var xError: XErrorEncoding?
    /// Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    public var xError2: XError2Encoding?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YEncoding?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Encoding?
    /// Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    public var yError: YErrorEncoding?
    /// Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    public var yError2: YError2Encoding?
    public static let codingKeyPaths = (\Self.angle as KeyPath, \Self.color as KeyPath, \Self.description as KeyPath, \Self.detail as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.href as KeyPath, \Self.key as KeyPath, \Self.latitude as KeyPath, \Self.latitude2 as KeyPath, \Self.longitude as KeyPath, \Self.longitude2 as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.stroke as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.xError as KeyPath, \Self.xError2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath, \Self.yError as KeyPath, \Self.yError2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.angle as KeyPath : CodingKeys.angle, \Self.color as KeyPath : CodingKeys.color, \Self.description as KeyPath : CodingKeys.description, \Self.detail as KeyPath : CodingKeys.detail, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.href as KeyPath : CodingKeys.href, \Self.key as KeyPath : CodingKeys.key, \Self.latitude as KeyPath : CodingKeys.latitude, \Self.latitude2 as KeyPath : CodingKeys.latitude2, \Self.longitude as KeyPath : CodingKeys.longitude, \Self.longitude2 as KeyPath : CodingKeys.longitude2, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.xError as KeyPath : CodingKeys.xError, \Self.xError2 as KeyPath : CodingKeys.xError2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2, \Self.yError as KeyPath : CodingKeys.yError, \Self.yError2 as KeyPath : CodingKeys.yError2]

    public init(angle: AngleEncoding? = nil, color: ColorEncoding? = nil, description: DescriptionEncoding? = nil, detail: DetailEncoding? = nil, fill: FillEncoding? = nil, fillOpacity: FillOpacityEncoding? = nil, href: HrefEncoding? = nil, key: KeyEncoding? = nil, latitude: LatitudeEncoding? = nil, latitude2: Latitude2Encoding? = nil, longitude: LongitudeEncoding? = nil, longitude2: Longitude2Encoding? = nil, opacity: OpacityEncoding? = nil, order: OrderEncoding? = nil, radius: RadiusEncoding? = nil, radius2: Radius2Encoding? = nil, shape: ShapeEncoding? = nil, size: SizeEncoding? = nil, stroke: StrokeEncoding? = nil, strokeDash: StrokeDashEncoding? = nil, strokeOpacity: StrokeOpacityEncoding? = nil, strokeWidth: StrokeWidthEncoding? = nil, text: TextEncoding? = nil, theta: ThetaEncoding? = nil, theta2: Theta2Encoding? = nil, tooltip: TooltipEncoding? = nil, url: UrlEncoding? = nil, x: XEncoding? = nil, x2: X2Encoding? = nil, xError: XErrorEncoding? = nil, xError2: XError2Encoding? = nil, y: YEncoding? = nil, y2: Y2Encoding? = nil, yError: YErrorEncoding? = nil, yError2: YError2Encoding? = nil) {
        self.angle = angle 
        self.color = color 
        self.description = description 
        self.detail = detail 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.href = href 
        self.key = key 
        self.latitude = latitude 
        self.latitude2 = latitude2 
        self.longitude = longitude 
        self.longitude2 = longitude2 
        self.opacity = opacity 
        self.order = order 
        self.radius = radius 
        self.radius2 = radius2 
        self.shape = shape 
        self.size = size 
        self.stroke = stroke 
        self.strokeDash = strokeDash 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.tooltip = tooltip 
        self.url = url 
        self.x = x 
        self.x2 = x2 
        self.xError = xError 
        self.xError2 = xError2 
        self.y = y 
        self.y2 = y2 
        self.yError = yError 
        self.yError2 = yError2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.angle = try values.decodeOptional(AngleEncoding.self, forKey: .angle) 
        self.color = try values.decodeOptional(ColorEncoding.self, forKey: .color) 
        self.description = try values.decodeOptional(DescriptionEncoding.self, forKey: .description) 
        self.detail = try values.decodeOptional(DetailEncoding.self, forKey: .detail) 
        self.fill = try values.decodeOptional(FillEncoding.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityEncoding.self, forKey: .fillOpacity) 
        self.href = try values.decodeOptional(HrefEncoding.self, forKey: .href) 
        self.key = try values.decodeOptional(KeyEncoding.self, forKey: .key) 
        self.latitude = try values.decodeOptional(LatitudeEncoding.self, forKey: .latitude) 
        self.latitude2 = try values.decodeOptional(Latitude2Encoding.self, forKey: .latitude2) 
        self.longitude = try values.decodeOptional(LongitudeEncoding.self, forKey: .longitude) 
        self.longitude2 = try values.decodeOptional(Longitude2Encoding.self, forKey: .longitude2) 
        self.opacity = try values.decodeOptional(OpacityEncoding.self, forKey: .opacity) 
        self.order = try values.decodeOptional(OrderEncoding.self, forKey: .order) 
        self.radius = try values.decodeOptional(RadiusEncoding.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Encoding.self, forKey: .radius2) 
        self.shape = try values.decodeOptional(ShapeEncoding.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeEncoding.self, forKey: .size) 
        self.stroke = try values.decodeOptional(StrokeEncoding.self, forKey: .stroke) 
        self.strokeDash = try values.decodeOptional(StrokeDashEncoding.self, forKey: .strokeDash) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityEncoding.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthEncoding.self, forKey: .strokeWidth) 
        self.text = try values.decodeOptional(TextEncoding.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaEncoding.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Encoding.self, forKey: .theta2) 
        self.tooltip = try values.decodeOptional(TooltipEncoding.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlEncoding.self, forKey: .url) 
        self.x = try values.decodeOptional(XEncoding.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Encoding.self, forKey: .x2) 
        self.xError = try values.decodeOptional(XErrorEncoding.self, forKey: .xError) 
        self.xError2 = try values.decodeOptional(XError2Encoding.self, forKey: .xError2) 
        self.y = try values.decodeOptional(YEncoding.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Encoding.self, forKey: .y2) 
        self.yError = try values.decodeOptional(YErrorEncoding.self, forKey: .yError) 
        self.yError2 = try values.decodeOptional(YError2Encoding.self, forKey: .yError2) 
    }

    public typealias Angle = NumericMarkPropDef

    public typealias Color = ColorDef

    /// A text description of this mark for ARIA accessibility (SVG output only). For SVG output the `"aria-label"` attribute will be set to this description.
    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>

    /// Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel.
    /// Generated by Curio
    public typealias DetailChoice = OneOrMany<FieldDefWithoutScale>

    public typealias Fill = ColorDef

    public typealias FillOpacity = NumericMarkPropDef

    /// A URL to load upon mouse click.
    /// Generated by Curio
    public typealias HrefChoice = OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>

    public typealias Key = FieldDefWithoutScale

    public typealias Latitude = LatLongDef

    public typealias Latitude2 = Position2Def

    public typealias Longitude = LatLongDef

    public typealias Longitude2 = Position2Def

    public typealias Opacity = NumericMarkPropDef

    /// Order of the marks.
    /// - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).
    /// - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{"value": null}` makes the line marks use the original order in the data sources.
    /// - Otherwise, this `order` channel encodes layer order of the marks.
    /// __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.
    /// Generated by Curio
    public typealias OrderChoice = OneOf<OneOrMany<OrderFieldDef>>.Or<OrderValueDef>

    public typealias Radius = PolarDef

    public typealias Radius2 = Position2Def

    public typealias Shape = ShapeDef

    public typealias Size = NumericMarkPropDef

    public typealias Stroke = ColorDef

    public typealias StrokeDash = NumericArrayMarkPropDef

    public typealias StrokeOpacity = NumericMarkPropDef

    public typealias StrokeWidth = NumericMarkPropDef

    public typealias Text = TextDef

    public typealias Theta = PolarDef

    public typealias Theta2 = Position2Def

    /// The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite.
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>.Or<[StringFieldDef]>>

    /// The URL of an image mark.
    /// Generated by Curio
    public typealias UrlChoice = OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>

    public typealias X = PositionDef

    public typealias X2 = Position2Def

    /// Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    /// Generated by Curio
    public typealias XError2Choice = OneOf<SecondaryFieldDef>.Or<ValueDefNumber>

    /// Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    /// Generated by Curio
    public typealias XErrorChoice = OneOf<SecondaryFieldDef>.Or<ValueDefNumber>

    public typealias Y = PositionDef

    public typealias Y2 = Position2Def

    /// Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    /// Generated by Curio
    public typealias YError2Choice = OneOf<SecondaryFieldDef>.Or<ValueDefNumber>

    /// Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    /// Generated by Curio
    public typealias YErrorChoice = OneOf<SecondaryFieldDef>.Or<ValueDefNumber>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case angle
        case color
        case description
        case detail
        case fill
        case fillOpacity
        case href
        case key
        case latitude
        case latitude2
        case longitude
        case longitude2
        case opacity
        case order
        case radius
        case radius2
        case shape
        case size
        case stroke
        case strokeDash
        case strokeOpacity
        case strokeWidth
        case text
        case theta
        case theta2
        case tooltip
        case url
        case x
        case x2
        case xError
        case xError2
        case y
        case y2
        case yError
        case yError2
        public var keyDescription: String? {
            switch self {
            case .angle: return "Rotation angle of point and text marks."
            case .color: return "Color of the marks – either fill or stroke color based on  the `filled` property of mark definition. By default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`, `\"text\"`, `\"trail\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n\n__Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n\n_Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified. 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme)."
            case .description: return "A text description of this mark for ARIA accessibility (SVG output only). For SVG output the `\"aria-label\"` attribute will be set to this description."
            case .detail: return "Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel."
            case .fill: return "Fill color of the marks. __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n\n_Note:_ The `fill` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified."
            case .fillOpacity: return "Fill opacity of the marks.\n\n__Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity` property."
            case .href: return "A URL to load upon mouse click."
            case .key: return "A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data."
            case .latitude: return "Latitude position of geographically projected marks."
            case .latitude2: return "Latitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`."
            case .longitude: return "Longitude position of geographically projected marks."
            case .longitude2: return "Longitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`."
            case .opacity: return "Opacity of the marks.\n\n__Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity` property."
            case .order: return "Order of the marks.\n- For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).\n- For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{\"value\": null}` makes the line marks use the original order in the data sources.\n- Otherwise, this `order` channel encodes layer order of the marks.\n\n__Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping."
            case .radius: return "The outer radius in pixels of arc marks."
            case .radius2: return "The inner radius in pixels of arc marks."
            case .shape: return "Shape of the mark.\n\n1. For `point` marks the supported values include:   - plotting shapes: `\"circle\"`, `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, `\"triangle-down\"`, `\"triangle-right\"`, or `\"triangle-left\"`.   - the line symbol `\"stroke\"`   - centered directional shapes `\"arrow\"`, `\"wedge\"`, or `\"triangle\"`   - a custom [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct sizing, custom shape paths should be defined within a square bounding box with coordinates ranging from -1 to 1 along both the x and y dimensions.)\n\n2. For `geoshape` marks it should be a field definition of the geojson data\n\n__Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property. (`\"circle\"` if unset.)"
            case .size: return "Size of the mark.\n- For `\"point\"`, `\"square\"` and `\"circle\"`, – the symbol size, or pixel area of the mark.\n- For `\"bar\"` and `\"tick\"` – the bar and tick's size.\n- For `\"text\"` – the text's font size.\n- Size is unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`. (Use `\"trail\"` instead of line with varying size)"
            case .stroke: return "Stroke color of the marks. __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n\n_Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified."
            case .strokeDash: return "Stroke dash of the marks.\n\n__Default value:__ `[1,0]` (No dash)."
            case .strokeOpacity: return "Stroke opacity of the marks.\n\n__Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity` property."
            case .strokeWidth: return "Stroke width of the marks.\n\n__Default value:__ If undefined, the default stroke width depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth` property."
            case .text: return "Text of the `text` mark."
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .tooltip: return "The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite."
            case .url: return "The URL of an image mark."
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .xError: return "Error value of x coordinates for error specified `\"errorbar\"` and `\"errorband\"`."
            case .xError2: return "Secondary error value of x coordinates for error specified `\"errorbar\"` and `\"errorband\"`."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .yError: return "Error value of y coordinates for error specified `\"errorbar\"` and `\"errorband\"`."
            case .yError2: return "Secondary error value of y coordinates for error specified `\"errorbar\"` and `\"errorband\"`."
             } 
        }

        public typealias CodingOwner = Encoding
    }

    public struct AngleEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Angle

        public init(rawValue: Angle) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Angle) {
            self.rawValue = rawValue 
        }
    }

    public struct ColorEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Color

        public init(rawValue: Color) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Color) {
            self.rawValue = rawValue 
        }
    }

    public struct DescriptionEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: DescriptionChoice

        public init(rawValue: DescriptionChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: DescriptionChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct DetailEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: DetailChoice

        public init(rawValue: DetailChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: DetailChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct FillEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Fill

        public init(rawValue: Fill) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Fill) {
            self.rawValue = rawValue 
        }
    }

    public struct FillOpacityEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: FillOpacity

        public init(rawValue: FillOpacity) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: FillOpacity) {
            self.rawValue = rawValue 
        }
    }

    public struct HrefEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: HrefChoice

        public init(rawValue: HrefChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: HrefChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct KeyEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Key

        public init(rawValue: Key) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Key) {
            self.rawValue = rawValue 
        }
    }

    public struct Latitude2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Latitude2

        public init(rawValue: Latitude2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Latitude2) {
            self.rawValue = rawValue 
        }
    }

    public struct LatitudeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Latitude

        public init(rawValue: Latitude) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Latitude) {
            self.rawValue = rawValue 
        }
    }

    public struct Longitude2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Longitude2

        public init(rawValue: Longitude2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Longitude2) {
            self.rawValue = rawValue 
        }
    }

    public struct LongitudeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Longitude

        public init(rawValue: Longitude) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Longitude) {
            self.rawValue = rawValue 
        }
    }

    public struct OpacityEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Opacity

        public init(rawValue: Opacity) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Opacity) {
            self.rawValue = rawValue 
        }
    }

    public struct OrderEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: OrderChoice

        public init(rawValue: OrderChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: OrderChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct Radius2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Radius2

        public init(rawValue: Radius2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Radius2) {
            self.rawValue = rawValue 
        }
    }

    public struct RadiusEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Radius

        public init(rawValue: Radius) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Radius) {
            self.rawValue = rawValue 
        }
    }

    public struct ShapeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Shape

        public init(rawValue: Shape) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Shape) {
            self.rawValue = rawValue 
        }
    }

    public struct SizeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Size

        public init(rawValue: Size) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Size) {
            self.rawValue = rawValue 
        }
    }

    public struct StrokeDashEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: StrokeDash

        public init(rawValue: StrokeDash) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: StrokeDash) {
            self.rawValue = rawValue 
        }
    }

    public struct StrokeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Stroke

        public init(rawValue: Stroke) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Stroke) {
            self.rawValue = rawValue 
        }
    }

    public struct StrokeOpacityEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: StrokeOpacity

        public init(rawValue: StrokeOpacity) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: StrokeOpacity) {
            self.rawValue = rawValue 
        }
    }

    public struct StrokeWidthEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: StrokeWidth

        public init(rawValue: StrokeWidth) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: StrokeWidth) {
            self.rawValue = rawValue 
        }
    }

    public struct TextEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Text

        public init(rawValue: Text) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Text) {
            self.rawValue = rawValue 
        }
    }

    public struct Theta2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Theta2

        public init(rawValue: Theta2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Theta2) {
            self.rawValue = rawValue 
        }
    }

    public struct ThetaEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Theta

        public init(rawValue: Theta) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Theta) {
            self.rawValue = rawValue 
        }
    }

    public struct TooltipEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: TooltipChoice

        public init(rawValue: TooltipChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: TooltipChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct UrlEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: UrlChoice

        public init(rawValue: UrlChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: UrlChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct X2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: X2

        public init(rawValue: X2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: X2) {
            self.rawValue = rawValue 
        }
    }

    public struct XEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: X

        public init(rawValue: X) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: X) {
            self.rawValue = rawValue 
        }
    }

    public struct XError2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: XError2Choice

        public init(rawValue: XError2Choice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: XError2Choice) {
            self.rawValue = rawValue 
        }
    }

    public struct XErrorEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: XErrorChoice

        public init(rawValue: XErrorChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: XErrorChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct Y2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Y2

        public init(rawValue: Y2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Y2) {
            self.rawValue = rawValue 
        }
    }

    public struct YEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Y

        public init(rawValue: Y) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Y) {
            self.rawValue = rawValue 
        }
    }

    public struct YError2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: YError2Choice

        public init(rawValue: YError2Choice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: YError2Choice) {
            self.rawValue = rawValue 
        }
    }

    public struct YErrorEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: YErrorChoice

        public init(rawValue: YErrorChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: YErrorChoice) {
            self.rawValue = rawValue 
        }
    }
}

/// Generated by Curio
public struct EncodingChannelMap : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Rotation angle of point and text marks.
    public var angle: AngleEncoding?
    /// Color of the marks – either fill or stroke color based on  the `filled` property of mark definition. By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`, `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and `"point"`.
    /// __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.
    /// _Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified. 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
    public var color: ColorEncoding?
    /// A field definition for the horizontal facet of trellis plots.
    public var column: ColumnEncoding?
    /// A text description of this mark for ARIA accessibility (SVG output only). For SVG output the `"aria-label"` attribute will be set to this description.
    public var description: DescriptionEncoding?
    /// Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel.
    public var detail: DetailEncoding?
    /// A field definition for the (flexible) facet of trellis plots.
    /// If either `row` or `column` is specified, this channel will be ignored.
    public var facet: FacetEncoding?
    /// Fill color of the marks. __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.
    /// _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.
    public var fill: FillEncoding?
    /// Fill opacity of the marks.
    /// __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity` property.
    public var fillOpacity: FillOpacityEncoding?
    /// A URL to load upon mouse click.
    public var href: HrefEncoding?
    /// A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data.
    public var key: KeyEncoding?
    /// Latitude position of geographically projected marks.
    public var latitude: LatitudeEncoding?
    /// Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    public var latitude2: Latitude2Encoding?
    /// Longitude position of geographically projected marks.
    public var longitude: LongitudeEncoding?
    /// Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    public var longitude2: Longitude2Encoding?
    /// Opacity of the marks.
    /// __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity` property.
    public var opacity: OpacityEncoding?
    /// Order of the marks.
    /// - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).
    /// - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{"value": null}` makes the line marks use the original order in the data sources.
    /// - Otherwise, this `order` channel encodes layer order of the marks.
    /// __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.
    public var order: OrderEncoding?
    /// The outer radius in pixels of arc marks.
    public var radius: RadiusEncoding?
    /// The inner radius in pixels of arc marks.
    public var radius2: Radius2Encoding?
    /// A field definition for the vertical facet of trellis plots.
    public var row: RowEncoding?
    /// Shape of the mark.
    /// 1. For `point` marks the supported values include:   - plotting shapes: `"circle"`, `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, `"triangle-down"`, `"triangle-right"`, or `"triangle-left"`.   - the line symbol `"stroke"`   - centered directional shapes `"arrow"`, `"wedge"`, or `"triangle"`   - a custom [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct sizing, custom shape paths should be defined within a square bounding box with coordinates ranging from -1 to 1 along both the x and y dimensions.)
    /// 2. For `geoshape` marks it should be a field definition of the geojson data
    /// __Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property. (`"circle"` if unset.)
    public var shape: ShapeEncoding?
    /// Size of the mark.
    /// - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
    /// - For `"bar"` and `"tick"` – the bar and tick's size.
    /// - For `"text"` – the text's font size.
    /// - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of line with varying size)
    public var size: SizeEncoding?
    /// Stroke color of the marks. __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.
    /// _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.
    public var stroke: StrokeEncoding?
    /// Stroke dash of the marks.
    /// __Default value:__ `[1,0]` (No dash).
    public var strokeDash: StrokeDashEncoding?
    /// Stroke opacity of the marks.
    /// __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity` property.
    public var strokeOpacity: StrokeOpacityEncoding?
    /// Stroke width of the marks.
    /// __Default value:__ If undefined, the default stroke width depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth` property.
    public var strokeWidth: StrokeWidthEncoding?
    /// Text of the `text` mark.
    public var text: TextEncoding?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaEncoding?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Encoding?
    /// The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite.
    public var tooltip: TooltipEncoding?
    /// The URL of an image mark.
    public var url: UrlEncoding?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XEncoding?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Encoding?
    /// Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    public var xError: XErrorEncoding?
    /// Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    public var xError2: XError2Encoding?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YEncoding?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Encoding?
    /// Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    public var yError: YErrorEncoding?
    /// Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    public var yError2: YError2Encoding?
    public static let codingKeyPaths = (\Self.angle as KeyPath, \Self.color as KeyPath, \Self.column as KeyPath, \Self.description as KeyPath, \Self.detail as KeyPath, \Self.facet as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.href as KeyPath, \Self.key as KeyPath, \Self.latitude as KeyPath, \Self.latitude2 as KeyPath, \Self.longitude as KeyPath, \Self.longitude2 as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.row as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.stroke as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.xError as KeyPath, \Self.xError2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath, \Self.yError as KeyPath, \Self.yError2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.angle as KeyPath : CodingKeys.angle, \Self.color as KeyPath : CodingKeys.color, \Self.column as KeyPath : CodingKeys.column, \Self.description as KeyPath : CodingKeys.description, \Self.detail as KeyPath : CodingKeys.detail, \Self.facet as KeyPath : CodingKeys.facet, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.href as KeyPath : CodingKeys.href, \Self.key as KeyPath : CodingKeys.key, \Self.latitude as KeyPath : CodingKeys.latitude, \Self.latitude2 as KeyPath : CodingKeys.latitude2, \Self.longitude as KeyPath : CodingKeys.longitude, \Self.longitude2 as KeyPath : CodingKeys.longitude2, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.row as KeyPath : CodingKeys.row, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.xError as KeyPath : CodingKeys.xError, \Self.xError2 as KeyPath : CodingKeys.xError2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2, \Self.yError as KeyPath : CodingKeys.yError, \Self.yError2 as KeyPath : CodingKeys.yError2]

    public init(angle: AngleEncoding? = nil, color: ColorEncoding? = nil, column: ColumnEncoding? = nil, description: DescriptionEncoding? = nil, detail: DetailEncoding? = nil, facet: FacetEncoding? = nil, fill: FillEncoding? = nil, fillOpacity: FillOpacityEncoding? = nil, href: HrefEncoding? = nil, key: KeyEncoding? = nil, latitude: LatitudeEncoding? = nil, latitude2: Latitude2Encoding? = nil, longitude: LongitudeEncoding? = nil, longitude2: Longitude2Encoding? = nil, opacity: OpacityEncoding? = nil, order: OrderEncoding? = nil, radius: RadiusEncoding? = nil, radius2: Radius2Encoding? = nil, row: RowEncoding? = nil, shape: ShapeEncoding? = nil, size: SizeEncoding? = nil, stroke: StrokeEncoding? = nil, strokeDash: StrokeDashEncoding? = nil, strokeOpacity: StrokeOpacityEncoding? = nil, strokeWidth: StrokeWidthEncoding? = nil, text: TextEncoding? = nil, theta: ThetaEncoding? = nil, theta2: Theta2Encoding? = nil, tooltip: TooltipEncoding? = nil, url: UrlEncoding? = nil, x: XEncoding? = nil, x2: X2Encoding? = nil, xError: XErrorEncoding? = nil, xError2: XError2Encoding? = nil, y: YEncoding? = nil, y2: Y2Encoding? = nil, yError: YErrorEncoding? = nil, yError2: YError2Encoding? = nil) {
        self.angle = angle 
        self.color = color 
        self.column = column 
        self.description = description 
        self.detail = detail 
        self.facet = facet 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.href = href 
        self.key = key 
        self.latitude = latitude 
        self.latitude2 = latitude2 
        self.longitude = longitude 
        self.longitude2 = longitude2 
        self.opacity = opacity 
        self.order = order 
        self.radius = radius 
        self.radius2 = radius2 
        self.row = row 
        self.shape = shape 
        self.size = size 
        self.stroke = stroke 
        self.strokeDash = strokeDash 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.tooltip = tooltip 
        self.url = url 
        self.x = x 
        self.x2 = x2 
        self.xError = xError 
        self.xError2 = xError2 
        self.y = y 
        self.y2 = y2 
        self.yError = yError 
        self.yError2 = yError2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.angle = try values.decodeOptional(AngleEncoding.self, forKey: .angle) 
        self.color = try values.decodeOptional(ColorEncoding.self, forKey: .color) 
        self.column = try values.decodeOptional(ColumnEncoding.self, forKey: .column) 
        self.description = try values.decodeOptional(DescriptionEncoding.self, forKey: .description) 
        self.detail = try values.decodeOptional(DetailEncoding.self, forKey: .detail) 
        self.facet = try values.decodeOptional(FacetEncoding.self, forKey: .facet) 
        self.fill = try values.decodeOptional(FillEncoding.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityEncoding.self, forKey: .fillOpacity) 
        self.href = try values.decodeOptional(HrefEncoding.self, forKey: .href) 
        self.key = try values.decodeOptional(KeyEncoding.self, forKey: .key) 
        self.latitude = try values.decodeOptional(LatitudeEncoding.self, forKey: .latitude) 
        self.latitude2 = try values.decodeOptional(Latitude2Encoding.self, forKey: .latitude2) 
        self.longitude = try values.decodeOptional(LongitudeEncoding.self, forKey: .longitude) 
        self.longitude2 = try values.decodeOptional(Longitude2Encoding.self, forKey: .longitude2) 
        self.opacity = try values.decodeOptional(OpacityEncoding.self, forKey: .opacity) 
        self.order = try values.decodeOptional(OrderEncoding.self, forKey: .order) 
        self.radius = try values.decodeOptional(RadiusEncoding.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Encoding.self, forKey: .radius2) 
        self.row = try values.decodeOptional(RowEncoding.self, forKey: .row) 
        self.shape = try values.decodeOptional(ShapeEncoding.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeEncoding.self, forKey: .size) 
        self.stroke = try values.decodeOptional(StrokeEncoding.self, forKey: .stroke) 
        self.strokeDash = try values.decodeOptional(StrokeDashEncoding.self, forKey: .strokeDash) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityEncoding.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthEncoding.self, forKey: .strokeWidth) 
        self.text = try values.decodeOptional(TextEncoding.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaEncoding.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Encoding.self, forKey: .theta2) 
        self.tooltip = try values.decodeOptional(TooltipEncoding.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlEncoding.self, forKey: .url) 
        self.x = try values.decodeOptional(XEncoding.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Encoding.self, forKey: .x2) 
        self.xError = try values.decodeOptional(XErrorEncoding.self, forKey: .xError) 
        self.xError2 = try values.decodeOptional(XError2Encoding.self, forKey: .xError2) 
        self.y = try values.decodeOptional(YEncoding.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Encoding.self, forKey: .y2) 
        self.yError = try values.decodeOptional(YErrorEncoding.self, forKey: .yError) 
        self.yError2 = try values.decodeOptional(YError2Encoding.self, forKey: .yError2) 
    }

    public typealias Angle = NumericMarkPropDef

    public typealias Color = ColorDef

    public typealias Column = RowColumnEncodingFieldDef

    /// A text description of this mark for ARIA accessibility (SVG output only). For SVG output the `"aria-label"` attribute will be set to this description.
    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>

    /// Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel.
    /// Generated by Curio
    public typealias DetailChoice = OneOrMany<FieldDefWithoutScale>

    public typealias Facet = FacetEncodingFieldDef

    public typealias Fill = ColorDef

    public typealias FillOpacity = NumericMarkPropDef

    /// A URL to load upon mouse click.
    /// Generated by Curio
    public typealias HrefChoice = OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>

    public typealias Key = FieldDefWithoutScale

    public typealias Latitude = LatLongDef

    public typealias Latitude2 = Position2Def

    public typealias Longitude = LatLongDef

    public typealias Longitude2 = Position2Def

    public typealias Opacity = NumericMarkPropDef

    /// Order of the marks.
    /// - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).
    /// - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{"value": null}` makes the line marks use the original order in the data sources.
    /// - Otherwise, this `order` channel encodes layer order of the marks.
    /// __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.
    /// Generated by Curio
    public typealias OrderChoice = OneOf<OneOrMany<OrderFieldDef>>.Or<OrderValueDef>

    public typealias Radius = PolarDef

    public typealias Radius2 = Position2Def

    public typealias Row = RowColumnEncodingFieldDef

    public typealias Shape = ShapeDef

    public typealias Size = NumericMarkPropDef

    public typealias Stroke = ColorDef

    public typealias StrokeDash = NumericArrayMarkPropDef

    public typealias StrokeOpacity = NumericMarkPropDef

    public typealias StrokeWidth = NumericMarkPropDef

    public typealias Text = TextDef

    public typealias Theta = PolarDef

    public typealias Theta2 = Position2Def

    /// The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite.
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>.Or<[StringFieldDef]>>

    /// The URL of an image mark.
    /// Generated by Curio
    public typealias UrlChoice = OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>

    public typealias X = PositionDef

    public typealias X2 = Position2Def

    /// Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    /// Generated by Curio
    public typealias XError2Choice = OneOf<SecondaryFieldDef>.Or<ValueDefNumber>

    /// Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    /// Generated by Curio
    public typealias XErrorChoice = OneOf<SecondaryFieldDef>.Or<ValueDefNumber>

    public typealias Y = PositionDef

    public typealias Y2 = Position2Def

    /// Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    /// Generated by Curio
    public typealias YError2Choice = OneOf<SecondaryFieldDef>.Or<ValueDefNumber>

    /// Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    /// Generated by Curio
    public typealias YErrorChoice = OneOf<SecondaryFieldDef>.Or<ValueDefNumber>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case angle
        case color
        case column
        case description
        case detail
        case facet
        case fill
        case fillOpacity
        case href
        case key
        case latitude
        case latitude2
        case longitude
        case longitude2
        case opacity
        case order
        case radius
        case radius2
        case row
        case shape
        case size
        case stroke
        case strokeDash
        case strokeOpacity
        case strokeWidth
        case text
        case theta
        case theta2
        case tooltip
        case url
        case x
        case x2
        case xError
        case xError2
        case y
        case y2
        case yError
        case yError2
        public var keyDescription: String? {
            switch self {
            case .angle: return "Rotation angle of point and text marks."
            case .color: return "Color of the marks – either fill or stroke color based on  the `filled` property of mark definition. By default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`, `\"text\"`, `\"trail\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n\n__Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n\n_Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified. 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme)."
            case .column: return "A field definition for the horizontal facet of trellis plots."
            case .description: return "A text description of this mark for ARIA accessibility (SVG output only). For SVG output the `\"aria-label\"` attribute will be set to this description."
            case .detail: return "Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel."
            case .facet: return "A field definition for the (flexible) facet of trellis plots.\n\nIf either `row` or `column` is specified, this channel will be ignored."
            case .fill: return "Fill color of the marks. __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n\n_Note:_ The `fill` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified."
            case .fillOpacity: return "Fill opacity of the marks.\n\n__Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity` property."
            case .href: return "A URL to load upon mouse click."
            case .key: return "A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data."
            case .latitude: return "Latitude position of geographically projected marks."
            case .latitude2: return "Latitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`."
            case .longitude: return "Longitude position of geographically projected marks."
            case .longitude2: return "Longitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`."
            case .opacity: return "Opacity of the marks.\n\n__Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity` property."
            case .order: return "Order of the marks.\n- For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).\n- For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{\"value\": null}` makes the line marks use the original order in the data sources.\n- Otherwise, this `order` channel encodes layer order of the marks.\n\n__Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping."
            case .radius: return "The outer radius in pixels of arc marks."
            case .radius2: return "The inner radius in pixels of arc marks."
            case .row: return "A field definition for the vertical facet of trellis plots."
            case .shape: return "Shape of the mark.\n\n1. For `point` marks the supported values include:   - plotting shapes: `\"circle\"`, `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, `\"triangle-down\"`, `\"triangle-right\"`, or `\"triangle-left\"`.   - the line symbol `\"stroke\"`   - centered directional shapes `\"arrow\"`, `\"wedge\"`, or `\"triangle\"`   - a custom [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct sizing, custom shape paths should be defined within a square bounding box with coordinates ranging from -1 to 1 along both the x and y dimensions.)\n\n2. For `geoshape` marks it should be a field definition of the geojson data\n\n__Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property. (`\"circle\"` if unset.)"
            case .size: return "Size of the mark.\n- For `\"point\"`, `\"square\"` and `\"circle\"`, – the symbol size, or pixel area of the mark.\n- For `\"bar\"` and `\"tick\"` – the bar and tick's size.\n- For `\"text\"` – the text's font size.\n- Size is unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`. (Use `\"trail\"` instead of line with varying size)"
            case .stroke: return "Stroke color of the marks. __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n\n_Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified."
            case .strokeDash: return "Stroke dash of the marks.\n\n__Default value:__ `[1,0]` (No dash)."
            case .strokeOpacity: return "Stroke opacity of the marks.\n\n__Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity` property."
            case .strokeWidth: return "Stroke width of the marks.\n\n__Default value:__ If undefined, the default stroke width depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth` property."
            case .text: return "Text of the `text` mark."
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .tooltip: return "The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite."
            case .url: return "The URL of an image mark."
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .xError: return "Error value of x coordinates for error specified `\"errorbar\"` and `\"errorband\"`."
            case .xError2: return "Secondary error value of x coordinates for error specified `\"errorbar\"` and `\"errorband\"`."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .yError: return "Error value of y coordinates for error specified `\"errorbar\"` and `\"errorband\"`."
            case .yError2: return "Secondary error value of y coordinates for error specified `\"errorbar\"` and `\"errorband\"`."
             } 
        }

        public typealias CodingOwner = EncodingChannelMap
    }

    public struct AngleEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Angle

        public init(rawValue: Angle) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Angle) {
            self.rawValue = rawValue 
        }
    }

    public struct ColorEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Color

        public init(rawValue: Color) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Color) {
            self.rawValue = rawValue 
        }
    }

    public struct ColumnEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Column

        public init(rawValue: Column) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Column) {
            self.rawValue = rawValue 
        }
    }

    public struct DescriptionEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: DescriptionChoice

        public init(rawValue: DescriptionChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: DescriptionChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct DetailEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: DetailChoice

        public init(rawValue: DetailChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: DetailChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct FacetEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Facet

        public init(rawValue: Facet) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Facet) {
            self.rawValue = rawValue 
        }
    }

    public struct FillEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Fill

        public init(rawValue: Fill) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Fill) {
            self.rawValue = rawValue 
        }
    }

    public struct FillOpacityEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: FillOpacity

        public init(rawValue: FillOpacity) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: FillOpacity) {
            self.rawValue = rawValue 
        }
    }

    public struct HrefEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: HrefChoice

        public init(rawValue: HrefChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: HrefChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct KeyEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Key

        public init(rawValue: Key) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Key) {
            self.rawValue = rawValue 
        }
    }

    public struct Latitude2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Latitude2

        public init(rawValue: Latitude2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Latitude2) {
            self.rawValue = rawValue 
        }
    }

    public struct LatitudeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Latitude

        public init(rawValue: Latitude) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Latitude) {
            self.rawValue = rawValue 
        }
    }

    public struct Longitude2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Longitude2

        public init(rawValue: Longitude2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Longitude2) {
            self.rawValue = rawValue 
        }
    }

    public struct LongitudeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Longitude

        public init(rawValue: Longitude) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Longitude) {
            self.rawValue = rawValue 
        }
    }

    public struct OpacityEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Opacity

        public init(rawValue: Opacity) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Opacity) {
            self.rawValue = rawValue 
        }
    }

    public struct OrderEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: OrderChoice

        public init(rawValue: OrderChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: OrderChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct Radius2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Radius2

        public init(rawValue: Radius2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Radius2) {
            self.rawValue = rawValue 
        }
    }

    public struct RadiusEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Radius

        public init(rawValue: Radius) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Radius) {
            self.rawValue = rawValue 
        }
    }

    public struct RowEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Row

        public init(rawValue: Row) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Row) {
            self.rawValue = rawValue 
        }
    }

    public struct ShapeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Shape

        public init(rawValue: Shape) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Shape) {
            self.rawValue = rawValue 
        }
    }

    public struct SizeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Size

        public init(rawValue: Size) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Size) {
            self.rawValue = rawValue 
        }
    }

    public struct StrokeDashEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: StrokeDash

        public init(rawValue: StrokeDash) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: StrokeDash) {
            self.rawValue = rawValue 
        }
    }

    public struct StrokeEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Stroke

        public init(rawValue: Stroke) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Stroke) {
            self.rawValue = rawValue 
        }
    }

    public struct StrokeOpacityEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: StrokeOpacity

        public init(rawValue: StrokeOpacity) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: StrokeOpacity) {
            self.rawValue = rawValue 
        }
    }

    public struct StrokeWidthEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: StrokeWidth

        public init(rawValue: StrokeWidth) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: StrokeWidth) {
            self.rawValue = rawValue 
        }
    }

    public struct TextEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Text

        public init(rawValue: Text) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Text) {
            self.rawValue = rawValue 
        }
    }

    public struct Theta2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Theta2

        public init(rawValue: Theta2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Theta2) {
            self.rawValue = rawValue 
        }
    }

    public struct ThetaEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Theta

        public init(rawValue: Theta) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Theta) {
            self.rawValue = rawValue 
        }
    }

    public struct TooltipEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: TooltipChoice

        public init(rawValue: TooltipChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: TooltipChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct UrlEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: UrlChoice

        public init(rawValue: UrlChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: UrlChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct X2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: X2

        public init(rawValue: X2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: X2) {
            self.rawValue = rawValue 
        }
    }

    public struct XEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: X

        public init(rawValue: X) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: X) {
            self.rawValue = rawValue 
        }
    }

    public struct XError2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: XError2Choice

        public init(rawValue: XError2Choice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: XError2Choice) {
            self.rawValue = rawValue 
        }
    }

    public struct XErrorEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: XErrorChoice

        public init(rawValue: XErrorChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: XErrorChoice) {
            self.rawValue = rawValue 
        }
    }

    public struct Y2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Y2

        public init(rawValue: Y2) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Y2) {
            self.rawValue = rawValue 
        }
    }

    public struct YEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: Y

        public init(rawValue: Y) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: Y) {
            self.rawValue = rawValue 
        }
    }

    public struct YError2Encoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: YError2Choice

        public init(rawValue: YError2Choice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: YError2Choice) {
            self.rawValue = rawValue 
        }
    }

    public struct YErrorEncoding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
        public var rawValue: YErrorChoice

        public init(rawValue: YErrorChoice) {
            self.rawValue = rawValue 
        }

        public init(_ rawValue: YErrorChoice) {
            self.rawValue = rawValue 
        }
    }
}

/// A sort definition for sorting a discrete scale in an encoding field definition.
/// Generated by Curio
public struct EncodingSortField : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The data [field](https://vega.github.io/vega-lite/docs/field.html) to sort by.
    /// __Default value:__ If unspecified, defaults to the field specified in the outer data reference.
    public var field: SourceColumnRef?
    /// An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to perform on the field prior to sorting (e.g., `"count"`, `"mean"` and `"median"`). An aggregation is required when there are multiple values of the sort field for each encoded data field. The input data objects will be aggregated, grouped by the encoded data field.
    /// For a full list of operations, please see the documentation for [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
    /// __Default value:__ `"sum"` for stacked plots. Otherwise, `"min"`.
    public var op: NonArgAggregateOp?
    /// The sort order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
    public var order: OrderChoice?
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.op as KeyPath, \Self.order as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.op as KeyPath : CodingKeys.op, \Self.order as KeyPath : CodingKeys.order]

    public init(field: SourceColumnRef? = nil, op: NonArgAggregateOp? = nil, order: OrderChoice? = nil) {
        self.field = field 
        self.op = op 
        self.order = order 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.op = try values.decodeOptional(NonArgAggregateOp.self, forKey: .op) 
        self.order = try values.decodeOptional(OrderChoice.self, forKey: .order) 
    }

    /// The sort order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
    /// Generated by Curio
    public typealias OrderChoice = Nullable<SortOrder>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case op
        case order
        public var keyDescription: String? {
            switch self {
            case .field: return "The data [field](https://vega.github.io/vega-lite/docs/field.html) to sort by.\n\n__Default value:__ If unspecified, defaults to the field specified in the outer data reference."
            case .op: return "An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to perform on the field prior to sorting (e.g., `\"count\"`, `\"mean\"` and `\"median\"`). An aggregation is required when there are multiple values of the sort field for each encoded data field. The input data objects will be aggregated, grouped by the encoded data field.\n\nFor a full list of operations, please see the documentation for [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).\n\n__Default value:__ `\"sum\"` for stacked plots. Otherwise, `\"min\"`."
            case .order: return "The sort order. One of `\"ascending\"` (default), `\"descending\"`, or `null` (no not sort)."
             } 
        }

        public typealias CodingOwner = EncodingSortField
    }
}

/// Generated by Curio
public struct ErrorBandConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var band: BandChoice?
    public var borders: BordersChoice?
    /// The extent of the band. Available options include:
    /// - `"ci"`: Extend the band to the confidence interval of the mean.
    /// - `"stderr"`: The size of band are set to the value of standard error, extending from the mean.
    /// - `"stdev"`: The size of band are set to the value of standard deviation, extending from the mean.
    /// - `"iqr"`: Extend the band to the q1 and q3.
    /// __Default value:__ `"stderr"`.
    public var extent: ErrorBarExtent?
    /// The line interpolation method for the error band. One of the following:
    /// - `"linear"`: piecewise linear segments, as in a polyline.
    /// - `"linear-closed"`: close the linear segments to form a polygon.
    /// - `"step"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.
    /// - `"step-before"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.
    /// - `"step-after"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.
    /// - `"basis"`: a B-spline, with control point duplication on the ends.
    /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
    /// - `"basis-closed"`: a closed B-spline, as in a loop.
    /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
    /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
    /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
    /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
    /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
    public var interpolate: Interpolate?
    /// The tension parameter for the interpolation type of the error band.
    public var tension: Double?
    public static let codingKeyPaths = (\Self.band as KeyPath, \Self.borders as KeyPath, \Self.extent as KeyPath, \Self.interpolate as KeyPath, \Self.tension as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.band as KeyPath : CodingKeys.band, \Self.borders as KeyPath : CodingKeys.borders, \Self.extent as KeyPath : CodingKeys.extent, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.tension as KeyPath : CodingKeys.tension]

    public init(band: BandChoice? = nil, borders: BordersChoice? = nil, extent: ErrorBarExtent? = nil, interpolate: Interpolate? = nil, tension: Double? = nil) {
        self.band = band 
        self.borders = borders 
        self.extent = extent 
        self.interpolate = interpolate 
        self.tension = tension 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.band = try values.decodeOptional(BandChoice.self, forKey: .band) 
        self.borders = try values.decodeOptional(BordersChoice.self, forKey: .borders) 
        self.extent = try values.decodeOptional(ErrorBarExtent.self, forKey: .extent) 
        self.interpolate = try values.decodeOptional(Interpolate.self, forKey: .interpolate) 
        self.tension = try values.decodeOptional(Double.self, forKey: .tension) 
    }

    /// Generated by Curio
    public typealias BandChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias BordersChoice = OneOf<Bool>.Or<MarkConfig>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case band
        case borders
        case extent
        case interpolate
        case tension
        public var keyDescription: String? {
            switch self {
            case .band: return nil
            case .borders: return nil
            case .extent: return "The extent of the band. Available options include:\n- `\"ci\"`: Extend the band to the confidence interval of the mean.\n- `\"stderr\"`: The size of band are set to the value of standard error, extending from the mean.\n- `\"stdev\"`: The size of band are set to the value of standard deviation, extending from the mean.\n- `\"iqr\"`: Extend the band to the q1 and q3.\n\n__Default value:__ `\"stderr\"`."
            case .interpolate: return "The line interpolation method for the error band. One of the following:\n- `\"linear\"`: piecewise linear segments, as in a polyline.\n- `\"linear-closed\"`: close the linear segments to form a polygon.\n- `\"step\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.\n- `\"step-before\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.\n- `\"step-after\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.\n- `\"basis\"`: a B-spline, with control point duplication on the ends.\n- `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n- `\"basis-closed\"`: a closed B-spline, as in a loop.\n- `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n- `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n- `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n- `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n- `\"monotone\"`: cubic interpolation that preserves monotonicity in y."
            case .tension: return "The tension parameter for the interpolation type of the error band."
             } 
        }

        public typealias CodingOwner = ErrorBandConfig
    }
}

/// Generated by Curio
public struct ErrorBandDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var band: BandChoice?
    public var borders: BordersChoice?
    /// Whether a composite mark be clipped to the enclosing group’s width and height.
    public var clip: Bool?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    /// The extent of the band. Available options include:
    /// - `"ci"`: Extend the band to the confidence interval of the mean.
    /// - `"stderr"`: The size of band are set to the value of standard error, extending from the mean.
    /// - `"stdev"`: The size of band are set to the value of standard deviation, extending from the mean.
    /// - `"iqr"`: Extend the band to the q1 and q3.
    /// __Default value:__ `"stderr"`.
    public var extent: ErrorBarExtent?
    /// The line interpolation method for the error band. One of the following:
    /// - `"linear"`: piecewise linear segments, as in a polyline.
    /// - `"linear-closed"`: close the linear segments to form a polygon.
    /// - `"step"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.
    /// - `"step-before"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.
    /// - `"step-after"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.
    /// - `"basis"`: a B-spline, with control point duplication on the ends.
    /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
    /// - `"basis-closed"`: a closed B-spline, as in a loop.
    /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
    /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
    /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
    /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
    /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
    public var interpolate: Interpolate?
    /// The opacity (value between [0,1]) of the mark.
    public var opacity: Double?
    /// Orientation of the error band. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.
    public var orient: Orientation?
    /// The tension parameter for the interpolation type of the error band.
    public var tension: Double?
    /// The mark type. This could a primitive mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`, `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`) or a composite mark type (`"boxplot"`, `"errorband"`, `"errorbar"`).
    public var type: ErrorBandLiteral
    public static let codingKeyPaths = (\Self.band as KeyPath, \Self.borders as KeyPath, \Self.clip as KeyPath, \Self.color as KeyPath, \Self.extent as KeyPath, \Self.interpolate as KeyPath, \Self.opacity as KeyPath, \Self.orient as KeyPath, \Self.tension as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.band as KeyPath : CodingKeys.band, \Self.borders as KeyPath : CodingKeys.borders, \Self.clip as KeyPath : CodingKeys.clip, \Self.color as KeyPath : CodingKeys.color, \Self.extent as KeyPath : CodingKeys.extent, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.orient as KeyPath : CodingKeys.orient, \Self.tension as KeyPath : CodingKeys.tension, \Self.type as KeyPath : CodingKeys.type]

    public init(band: BandChoice? = nil, borders: BordersChoice? = nil, clip: Bool? = nil, color: ColorChoice? = nil, extent: ErrorBarExtent? = nil, interpolate: Interpolate? = nil, opacity: Double? = nil, orient: Orientation? = nil, tension: Double? = nil, type: ErrorBandLiteral) {
        self.band = band 
        self.borders = borders 
        self.clip = clip 
        self.color = color 
        self.extent = extent 
        self.interpolate = interpolate 
        self.opacity = opacity 
        self.orient = orient 
        self.tension = tension 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.band = try values.decodeOptional(BandChoice.self, forKey: .band) 
        self.borders = try values.decodeOptional(BordersChoice.self, forKey: .borders) 
        self.clip = try values.decodeOptional(Bool.self, forKey: .clip) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.extent = try values.decodeOptional(ErrorBarExtent.self, forKey: .extent) 
        self.interpolate = try values.decodeOptional(Interpolate.self, forKey: .interpolate) 
        self.opacity = try values.decodeOptional(Double.self, forKey: .opacity) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.tension = try values.decodeOptional(Double.self, forKey: .tension) 
        self.type = try values.decode(ErrorBandLiteral.self, forKey: .type) 
    }

    /// Generated by Curio
    public typealias BandChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias BordersChoice = OneOf<Bool>.Or<MarkConfig>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case band
        case borders
        case clip
        case color
        case extent
        case interpolate
        case opacity
        case orient
        case tension
        case type
        public var keyDescription: String? {
            switch self {
            case .band: return nil
            case .borders: return nil
            case .clip: return "Whether a composite mark be clipped to the enclosing group’s width and height."
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .extent: return "The extent of the band. Available options include:\n- `\"ci\"`: Extend the band to the confidence interval of the mean.\n- `\"stderr\"`: The size of band are set to the value of standard error, extending from the mean.\n- `\"stdev\"`: The size of band are set to the value of standard deviation, extending from the mean.\n- `\"iqr\"`: Extend the band to the q1 and q3.\n\n__Default value:__ `\"stderr\"`."
            case .interpolate: return "The line interpolation method for the error band. One of the following:\n- `\"linear\"`: piecewise linear segments, as in a polyline.\n- `\"linear-closed\"`: close the linear segments to form a polygon.\n- `\"step\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.\n- `\"step-before\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.\n- `\"step-after\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.\n- `\"basis\"`: a B-spline, with control point duplication on the ends.\n- `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n- `\"basis-closed\"`: a closed B-spline, as in a loop.\n- `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n- `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n- `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n- `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n- `\"monotone\"`: cubic interpolation that preserves monotonicity in y."
            case .opacity: return "The opacity (value between [0,1]) of the mark."
            case .orient: return "Orientation of the error band. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined."
            case .tension: return "The tension parameter for the interpolation type of the error band."
            case .type: return "The mark type. This could a primitive mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`, `\"area\"`, `\"point\"`, `\"geoshape\"`, `\"rule\"`, and `\"text\"`) or a composite mark type (`\"boxplot\"`, `\"errorband\"`, `\"errorbar\"`)."
             } 
        }

        public typealias CodingOwner = ErrorBandDef
    }
}

/// Generated by Curio
public struct ErrorBarConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The extent of the rule. Available options include:
    /// - `"ci"`: Extend the rule to the confidence interval of the mean.
    /// - `"stderr"`: The size of rule are set to the value of standard error, extending from the mean.
    /// - `"stdev"`: The size of rule are set to the value of standard deviation, extending from the mean.
    /// - `"iqr"`: Extend the rule to the q1 and q3.
    /// __Default value:__ `"stderr"`.
    public var extent: ErrorBarExtent?
    public var rule: RuleChoice?
    /// Size of the ticks of an error bar
    public var size: Double?
    /// Thickness of the ticks and the bar of an error bar
    public var thickness: Double?
    public var ticks: TicksChoice?
    public static let codingKeyPaths = (\Self.extent as KeyPath, \Self.rule as KeyPath, \Self.size as KeyPath, \Self.thickness as KeyPath, \Self.ticks as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.extent as KeyPath : CodingKeys.extent, \Self.rule as KeyPath : CodingKeys.rule, \Self.size as KeyPath : CodingKeys.size, \Self.thickness as KeyPath : CodingKeys.thickness, \Self.ticks as KeyPath : CodingKeys.ticks]

    public init(extent: ErrorBarExtent? = nil, rule: RuleChoice? = nil, size: Double? = nil, thickness: Double? = nil, ticks: TicksChoice? = nil) {
        self.extent = extent 
        self.rule = rule 
        self.size = size 
        self.thickness = thickness 
        self.ticks = ticks 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.extent = try values.decodeOptional(ErrorBarExtent.self, forKey: .extent) 
        self.rule = try values.decodeOptional(RuleChoice.self, forKey: .rule) 
        self.size = try values.decodeOptional(Double.self, forKey: .size) 
        self.thickness = try values.decodeOptional(Double.self, forKey: .thickness) 
        self.ticks = try values.decodeOptional(TicksChoice.self, forKey: .ticks) 
    }

    /// Generated by Curio
    public typealias RuleChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias TicksChoice = OneOf<Bool>.Or<MarkConfig>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case extent
        case rule
        case size
        case thickness
        case ticks
        public var keyDescription: String? {
            switch self {
            case .extent: return "The extent of the rule. Available options include:\n- `\"ci\"`: Extend the rule to the confidence interval of the mean.\n- `\"stderr\"`: The size of rule are set to the value of standard error, extending from the mean.\n- `\"stdev\"`: The size of rule are set to the value of standard deviation, extending from the mean.\n- `\"iqr\"`: Extend the rule to the q1 and q3.\n\n__Default value:__ `\"stderr\"`."
            case .rule: return nil
            case .size: return "Size of the ticks of an error bar"
            case .thickness: return "Thickness of the ticks and the bar of an error bar"
            case .ticks: return nil
             } 
        }

        public typealias CodingOwner = ErrorBarConfig
    }
}

/// Generated by Curio
public struct ErrorBarDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Whether a composite mark be clipped to the enclosing group’s width and height.
    public var clip: Bool?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    /// The extent of the rule. Available options include:
    /// - `"ci"`: Extend the rule to the confidence interval of the mean.
    /// - `"stderr"`: The size of rule are set to the value of standard error, extending from the mean.
    /// - `"stdev"`: The size of rule are set to the value of standard deviation, extending from the mean.
    /// - `"iqr"`: Extend the rule to the q1 and q3.
    /// __Default value:__ `"stderr"`.
    public var extent: ErrorBarExtent?
    /// The opacity (value between [0,1]) of the mark.
    public var opacity: Double?
    /// Orientation of the error bar. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.
    public var orient: Orientation?
    public var rule: RuleChoice?
    /// Size of the ticks of an error bar
    public var size: Double?
    /// Thickness of the ticks and the bar of an error bar
    public var thickness: Double?
    public var ticks: TicksChoice?
    /// The mark type. This could a primitive mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`, `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`) or a composite mark type (`"boxplot"`, `"errorband"`, `"errorbar"`).
    public var type: ErrorBarLiteral
    public static let codingKeyPaths = (\Self.clip as KeyPath, \Self.color as KeyPath, \Self.extent as KeyPath, \Self.opacity as KeyPath, \Self.orient as KeyPath, \Self.rule as KeyPath, \Self.size as KeyPath, \Self.thickness as KeyPath, \Self.ticks as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.clip as KeyPath : CodingKeys.clip, \Self.color as KeyPath : CodingKeys.color, \Self.extent as KeyPath : CodingKeys.extent, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.orient as KeyPath : CodingKeys.orient, \Self.rule as KeyPath : CodingKeys.rule, \Self.size as KeyPath : CodingKeys.size, \Self.thickness as KeyPath : CodingKeys.thickness, \Self.ticks as KeyPath : CodingKeys.ticks, \Self.type as KeyPath : CodingKeys.type]

    public init(clip: Bool? = nil, color: ColorChoice? = nil, extent: ErrorBarExtent? = nil, opacity: Double? = nil, orient: Orientation? = nil, rule: RuleChoice? = nil, size: Double? = nil, thickness: Double? = nil, ticks: TicksChoice? = nil, type: ErrorBarLiteral) {
        self.clip = clip 
        self.color = color 
        self.extent = extent 
        self.opacity = opacity 
        self.orient = orient 
        self.rule = rule 
        self.size = size 
        self.thickness = thickness 
        self.ticks = ticks 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.clip = try values.decodeOptional(Bool.self, forKey: .clip) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.extent = try values.decodeOptional(ErrorBarExtent.self, forKey: .extent) 
        self.opacity = try values.decodeOptional(Double.self, forKey: .opacity) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.rule = try values.decodeOptional(RuleChoice.self, forKey: .rule) 
        self.size = try values.decodeOptional(Double.self, forKey: .size) 
        self.thickness = try values.decodeOptional(Double.self, forKey: .thickness) 
        self.ticks = try values.decodeOptional(TicksChoice.self, forKey: .ticks) 
        self.type = try values.decode(ErrorBarLiteral.self, forKey: .type) 
    }

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias RuleChoice = OneOf<Bool>.Or<MarkConfig>

    /// Generated by Curio
    public typealias TicksChoice = OneOf<Bool>.Or<MarkConfig>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case clip
        case color
        case extent
        case opacity
        case orient
        case rule
        case size
        case thickness
        case ticks
        case type
        public var keyDescription: String? {
            switch self {
            case .clip: return "Whether a composite mark be clipped to the enclosing group’s width and height."
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .extent: return "The extent of the rule. Available options include:\n- `\"ci\"`: Extend the rule to the confidence interval of the mean.\n- `\"stderr\"`: The size of rule are set to the value of standard error, extending from the mean.\n- `\"stdev\"`: The size of rule are set to the value of standard deviation, extending from the mean.\n- `\"iqr\"`: Extend the rule to the q1 and q3.\n\n__Default value:__ `\"stderr\"`."
            case .opacity: return "The opacity (value between [0,1]) of the mark."
            case .orient: return "Orientation of the error bar. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined."
            case .rule: return nil
            case .size: return "Size of the ticks of an error bar"
            case .thickness: return "Thickness of the ticks and the bar of an error bar"
            case .ticks: return nil
            case .type: return "The mark type. This could a primitive mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`, `\"area\"`, `\"point\"`, `\"geoshape\"`, `\"rule\"`, and `\"text\"`) or a composite mark type (`\"boxplot\"`, `\"errorband\"`, `\"errorbar\"`)."
             } 
        }

        public typealias CodingOwner = ErrorBarDef
    }
}

public struct EventStream : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Type1>.Or<Type2>

    public init(rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct Type1 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var between: [Stream]?
        public var consume: Bool?
        public var debounce: Double?
        public var filter: FilterChoice?
        public var markname: String?
        public var marktype: VgMarkType?
        public var source: LiteralViewOrScope?
        public var throttle: Double?
        public var type: EventType
        public static let codingKeyPaths = (\Self.between as KeyPath, \Self.consume as KeyPath, \Self.debounce as KeyPath, \Self.filter as KeyPath, \Self.markname as KeyPath, \Self.marktype as KeyPath, \Self.source as KeyPath, \Self.throttle as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.between as KeyPath : CodingKeys.between, \Self.consume as KeyPath : CodingKeys.consume, \Self.debounce as KeyPath : CodingKeys.debounce, \Self.filter as KeyPath : CodingKeys.filter, \Self.markname as KeyPath : CodingKeys.markname, \Self.marktype as KeyPath : CodingKeys.marktype, \Self.source as KeyPath : CodingKeys.source, \Self.throttle as KeyPath : CodingKeys.throttle, \Self.type as KeyPath : CodingKeys.type]

        public init(between: [Stream]? = nil, consume: Bool? = nil, debounce: Double? = nil, filter: FilterChoice? = nil, markname: String? = nil, marktype: VgMarkType? = nil, source: LiteralViewOrScope? = nil, throttle: Double? = nil, type: EventType) {
            self.between = between 
            self.consume = consume 
            self.debounce = debounce 
            self.filter = filter 
            self.markname = markname 
            self.marktype = marktype 
            self.source = source 
            self.throttle = throttle 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.between = try values.decodeOptional([Stream].self, forKey: .between) 
            self.consume = try values.decodeOptional(Bool.self, forKey: .consume) 
            self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
            self.filter = try values.decodeOptional(FilterChoice.self, forKey: .filter) 
            self.markname = try values.decodeOptional(String.self, forKey: .markname) 
            self.marktype = try values.decodeOptional(VgMarkType.self, forKey: .marktype) 
            self.source = try values.decodeOptional(LiteralViewOrScope.self, forKey: .source) 
            self.throttle = try values.decodeOptional(Double.self, forKey: .throttle) 
            self.type = try values.decode(EventType.self, forKey: .type) 
        }

        /// Generated by Curio
        public typealias FilterChoice = OneOrMany<Expr>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case between
            case consume
            case debounce
            case filter
            case markname
            case marktype
            case source
            case throttle
            case type
            public var keyDescription: String? {
                switch self {
                case .between: return nil
                case .consume: return nil
                case .debounce: return nil
                case .filter: return nil
                case .markname: return nil
                case .marktype: return nil
                case .source: return nil
                case .throttle: return nil
                case .type: return nil
                 } 
            }

            public typealias CodingOwner = Type1
        }

        /// Generated by Curio
        public enum LiteralViewOrScope : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
            case view
            case scope
        }
    }

    /// Generated by Curio
    public struct Type2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var between: [Stream]?
        public var consume: Bool?
        public var debounce: Double?
        public var filter: FilterChoice?
        public var markname: String?
        public var marktype: VgMarkType?
        public var source: LiteralWindow
        public var throttle: Double?
        public var type: WindowEventType
        public static let codingKeyPaths = (\Self.between as KeyPath, \Self.consume as KeyPath, \Self.debounce as KeyPath, \Self.filter as KeyPath, \Self.markname as KeyPath, \Self.marktype as KeyPath, \Self.source as KeyPath, \Self.throttle as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.between as KeyPath : CodingKeys.between, \Self.consume as KeyPath : CodingKeys.consume, \Self.debounce as KeyPath : CodingKeys.debounce, \Self.filter as KeyPath : CodingKeys.filter, \Self.markname as KeyPath : CodingKeys.markname, \Self.marktype as KeyPath : CodingKeys.marktype, \Self.source as KeyPath : CodingKeys.source, \Self.throttle as KeyPath : CodingKeys.throttle, \Self.type as KeyPath : CodingKeys.type]

        public init(between: [Stream]? = nil, consume: Bool? = nil, debounce: Double? = nil, filter: FilterChoice? = nil, markname: String? = nil, marktype: VgMarkType? = nil, source: LiteralWindow = .window, throttle: Double? = nil, type: WindowEventType) {
            self.between = between 
            self.consume = consume 
            self.debounce = debounce 
            self.filter = filter 
            self.markname = markname 
            self.marktype = marktype 
            self.source = source 
            self.throttle = throttle 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.between = try values.decodeOptional([Stream].self, forKey: .between) 
            self.consume = try values.decodeOptional(Bool.self, forKey: .consume) 
            self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
            self.filter = try values.decodeOptional(FilterChoice.self, forKey: .filter) 
            self.markname = try values.decodeOptional(String.self, forKey: .markname) 
            self.marktype = try values.decodeOptional(VgMarkType.self, forKey: .marktype) 
            self.source = try values.decode(LiteralWindow.self, forKey: .source) 
            self.throttle = try values.decodeOptional(Double.self, forKey: .throttle) 
            self.type = try values.decode(WindowEventType.self, forKey: .type) 
        }

        /// Generated by Curio
        public typealias FilterChoice = OneOrMany<Expr>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case between
            case consume
            case debounce
            case filter
            case markname
            case marktype
            case source
            case throttle
            case type
            public var keyDescription: String? {
                switch self {
                case .between: return nil
                case .consume: return nil
                case .debounce: return nil
                case .filter: return nil
                case .markname: return nil
                case .marktype: return nil
                case .source: return nil
                case .throttle: return nil
                case .type: return nil
                 } 
            }

            public typealias CodingOwner = Type2
        }

        /// Generated by Curio
        public enum LiteralWindow : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
            case window
        }
    }
}

public struct Expr : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: String) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct ExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Vega expression (which can refer to Vega-Lite parameters).
    public var expr: Expr
    public static let codingKeyPaths = (\Self.expr as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.expr as KeyPath : CodingKeys.expr]

    public init(expr: Expr) {
        self.expr = expr 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.expr = try values.decode(Expr.self, forKey: .expr) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case expr
        public var keyDescription: String? {
            switch self {
            case .expr: return "Vega expression (which can refer to Vega-Lite parameters)."
             } 
        }

        public typealias CodingOwner = ExprRef
    }
}

/// Generated by Curio
public struct FacetEncodingFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// The number of columns to include in the view composition layout.
    /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
    /// __Note__:
    /// 1) This property is only for:
    /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
    /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
    /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
    public var columns: Double?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining properties of a facet's header.
    public var header: HeaderChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` is not supported for `row` and `column`.
    public var sort: SortChoice?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.align as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.field as KeyPath, \Self.header as KeyPath, \Self.sort as KeyPath, \Self.spacing as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.align as KeyPath : CodingKeys.align, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.field as KeyPath : CodingKeys.field, \Self.header as KeyPath : CodingKeys.header, \Self.sort as KeyPath : CodingKeys.sort, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, align: AlignChoice? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, field: SourceColumnRef? = nil, header: HeaderChoice? = nil, sort: SortChoice? = nil, spacing: SpacingChoice? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.align = align 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.bounds = bounds 
        self.center = center 
        self.columns = columns 
        self.field = field 
        self.header = header 
        self.sort = sort 
        self.spacing = spacing 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.header = try values.decodeOptional(HeaderChoice.self, forKey: .header) 
        self.sort = try values.decodeOptional(SortChoice.self, forKey: .sort) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object defining properties of a facet's header.
    /// Generated by Curio
    public typealias HeaderChoice = Nullable<HeaderDef>

    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` is not supported for `row` and `column`.
    /// Generated by Curio
    public typealias SortChoice = Nullable<OneOf<SortArray>.Or<SortOrder>.Or<EncodingSortField>>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case align
        case bandPosition
        case bin
        case bounds
        case center
        case columns
        case field
        case header
        case sort
        case spacing
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .header: return "An object defining properties of a facet's header."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` is not supported for `row` and `column`."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FacetEncodingFieldDef
    }
}

/// Generated by Curio
public struct FacetFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining properties of a facet's header.
    public var header: HeaderChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` is not supported for `row` and `column`.
    public var sort: SortChoice?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.header as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.header as KeyPath : CodingKeys.header, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, header: HeaderChoice? = nil, sort: SortChoice? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.header = header 
        self.sort = sort 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.header = try values.decodeOptional(HeaderChoice.self, forKey: .header) 
        self.sort = try values.decodeOptional(SortChoice.self, forKey: .sort) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

    /// An object defining properties of a facet's header.
    /// Generated by Curio
    public typealias HeaderChoice = Nullable<HeaderDef>

    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` is not supported for `row` and `column`.
    /// Generated by Curio
    public typealias SortChoice = Nullable<OneOf<SortArray>.Or<SortOrder>.Or<EncodingSortField>>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case field
        case header
        case sort
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .header: return "An object defining properties of a facet's header."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` is not supported for `row` and `column`."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FacetFieldDef
    }
}

/// Generated by Curio
public struct FacetMapping : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A field definition for the horizontal facet of trellis plots.
    public var column: FacetFieldDef?
    /// A field definition for the vertical facet of trellis plots.
    public var row: FacetFieldDef?
    public static let codingKeyPaths = (\Self.column as KeyPath, \Self.row as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.column as KeyPath : CodingKeys.column, \Self.row as KeyPath : CodingKeys.row]

    public init(column: FacetFieldDef? = nil, row: FacetFieldDef? = nil) {
        self.column = column 
        self.row = row 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.column = try values.decodeOptional(FacetFieldDef.self, forKey: .column) 
        self.row = try values.decodeOptional(FacetFieldDef.self, forKey: .row) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case column
        case row
        public var keyDescription: String? {
            switch self {
            case .column: return "A field definition for the horizontal facet of trellis plots."
            case .row: return "A field definition for the vertical facet of trellis plots."
             } 
        }

        public typealias CodingOwner = FacetMapping
    }
}

/// Base interface for a facet specification.
/// Generated by Curio
public struct FacetSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// The number of columns to include in the view composition layout.
    /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
    /// __Note__:
    /// 1) This property is only for:
    /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
    /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
    /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
    public var columns: Double?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// Definition for how to facet the data. One of: 1) [a field definition for faceting the plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An object that maps `row` and `column` channels to their field definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
    public var facet: FacetChoice
    /// Name of the visualization for later reference.
    public var name: String?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// A specification of the view that gets faceted.
    public var spec: SpecChoice
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.align as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.data as KeyPath, \Self.description as KeyPath, \Self.facet as KeyPath, \Self.name as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.spec as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.align as KeyPath : CodingKeys.align, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.facet as KeyPath : CodingKeys.facet, \Self.name as KeyPath : CodingKeys.name, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.spec as KeyPath : CodingKeys.spec, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform]

    public init(id: LayerId? = nil, align: AlignChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, data: DataChoice? = nil, description: String? = nil, facet: FacetChoice, name: String? = nil, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, spec: SpecChoice, title: TitleChoice? = nil, transform: [DataTransformation]? = nil) {
        self.id = id 
        self.align = align 
        self.bounds = bounds 
        self.center = center 
        self.columns = columns 
        self.data = data 
        self.description = description 
        self.facet = facet 
        self.name = name 
        self.resolve = resolve 
        self.spacing = spacing 
        self.spec = spec 
        self.title = title 
        self.transform = transform 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.facet = try values.decode(FacetChoice.self, forKey: .facet) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.spec = try values.decode(SpecChoice.self, forKey: .spec) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// Definition for how to facet the data. One of: 1) [a field definition for faceting the plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An object that maps `row` and `column` channels to their field definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
    /// Generated by Curio
    public typealias FacetChoice = OneOf<FacetFieldDef>.Or<FacetMapping>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// A specification of the view that gets faceted.
    /// Generated by Curio
    public typealias SpecChoice = OneOf<LayerSpec>.Or<FacetedUnitSpec>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case align
        case bounds
        case center
        case columns
        case data
        case description
        case facet
        case name
        case resolve
        case spacing
        case spec
        case title
        case transform
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .facet: return "Definition for how to facet the data. One of: 1) [a field definition for faceting the plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An object that maps `row` and `column` channels to their field definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)"
            case .name: return "Name of the visualization for later reference."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .spec: return "A specification of the view that gets faceted."
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
             } 
        }

        public typealias CodingOwner = FacetSpec
    }
}

/// Unit spec that can have a composite mark and row or column channels (shorthand for a facet spec).
/// Generated by Curio
public struct FacetedUnitSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// A key-value mapping between encoding channels and definition of fields.
    public var encoding: EncodingChannelMap?
    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var height: HeightChoice?
    /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    public var mark: AnyMark
    /// Name of the visualization for later reference.
    public var name: String?
    /// An array of parameters that may either be simple variables, or more complex selections that map user input to data queries.
    public var params: [ParamsItemChoice]?
    /// An object defining properties of geographic projection, which will be applied to `shape` path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other marks.
    public var projection: Projection?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// An object defining the view background's fill and stroke.
    /// __Default value:__ none (transparent)
    public var view: ViewBackground?
    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var width: WidthChoice?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.align as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.data as KeyPath, \Self.description as KeyPath, \Self.encoding as KeyPath, \Self.height as KeyPath, \Self.mark as KeyPath, \Self.name as KeyPath, \Self.params as KeyPath, \Self.projection as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.view as KeyPath, \Self.width as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.align as KeyPath : CodingKeys.align, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.encoding as KeyPath : CodingKeys.encoding, \Self.height as KeyPath : CodingKeys.height, \Self.mark as KeyPath : CodingKeys.mark, \Self.name as KeyPath : CodingKeys.name, \Self.params as KeyPath : CodingKeys.params, \Self.projection as KeyPath : CodingKeys.projection, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.view as KeyPath : CodingKeys.view, \Self.width as KeyPath : CodingKeys.width]

    public init(id: LayerId? = nil, align: AlignChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, data: DataChoice? = nil, description: String? = nil, encoding: EncodingChannelMap? = nil, height: HeightChoice? = nil, mark: AnyMark, name: String? = nil, params: [ParamsItemChoice]? = nil, projection: Projection? = nil, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, view: ViewBackground? = nil, width: WidthChoice? = nil) {
        self.id = id 
        self.align = align 
        self.bounds = bounds 
        self.center = center 
        self.data = data 
        self.description = description 
        self.encoding = encoding 
        self.height = height 
        self.mark = mark 
        self.name = name 
        self.params = params 
        self.projection = projection 
        self.resolve = resolve 
        self.spacing = spacing 
        self.title = title 
        self.transform = transform 
        self.view = view 
        self.width = width 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.encoding = try values.decodeOptional(EncodingChannelMap.self, forKey: .encoding) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.mark = try values.decode(AnyMark.self, forKey: .mark) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.projection = try values.decodeOptional(Projection.self, forKey: .projection) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.view = try values.decodeOptional(ViewBackground.self, forKey: .view) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<SelectionParameter>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case align
        case bounds
        case center
        case data
        case description
        case encoding
        case height
        case mark
        case name
        case params
        case projection
        case resolve
        case spacing
        case title
        case transform
        case view
        case width
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .encoding: return "A key-value mapping between encoding channels and definition of fields."
            case .height: return "The height of a visualization.\n\n- For a plot with a continuous y-field, height should be a number.\n- For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)\n- To enable responsive sizing on height, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation."
            case .mark: return "A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`, `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def)."
            case .name: return "Name of the visualization for later reference."
            case .params: return "An array of parameters that may either be simple variables, or more complex selections that map user input to data queries."
            case .projection: return "An object defining properties of geographic projection, which will be applied to `shape` path for `\"geoshape\"` marks and to `latitude` and `\"longitude\"` channels for other marks."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .view: return "An object defining the view background's fill and stroke.\n\n__Default value:__ none (transparent)"
            case .width: return "The width of a visualization.\n\n- For a plot with a continuous x-field, width should be a number.\n- For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)\n- To enable responsive sizing on width, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation."
             } 
        }

        public typealias CodingOwner = FacetedUnitSpec
    }
}

/// Generated by Curio
public struct FieldEqualPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The value that the field should be equal to.
    public var equal: EqualChoice
    /// Field to be tested.
    public var field: FieldName
    /// Time unit for the field to be tested.
    public var timeUnit: TimeUnitChoice?
    public static let codingKeyPaths = (\Self.equal as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.equal as KeyPath : CodingKeys.equal, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit]

    public init(equal: EqualChoice, field: FieldName, timeUnit: TimeUnitChoice? = nil) {
        self.equal = equal 
        self.field = field 
        self.timeUnit = timeUnit 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.equal = try values.decode(EqualChoice.self, forKey: .equal) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
    }

    /// The value that the field should be equal to.
    /// Generated by Curio
    public typealias EqualChoice = OneOf<String>.Or<Double>.Or<Bool>.Or<DateTime>.Or<ExprRef>

    /// Time unit for the field to be tested.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case equal
        case field
        case timeUnit
        public var keyDescription: String? {
            switch self {
            case .equal: return "The value that the field should be equal to."
            case .field: return "Field to be tested."
            case .timeUnit: return "Time unit for the field to be tested."
             } 
        }

        public typealias CodingOwner = FieldEqualPredicate
    }
}

/// Generated by Curio
public struct FieldGTEPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Field to be tested.
    public var field: FieldName
    /// The value that the field should be greater than or equals to.
    public var gte: GteChoice
    /// Time unit for the field to be tested.
    public var timeUnit: TimeUnitChoice?
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.gte as KeyPath, \Self.timeUnit as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.gte as KeyPath : CodingKeys.gte, \Self.timeUnit as KeyPath : CodingKeys.timeUnit]

    public init(field: FieldName, gte: GteChoice, timeUnit: TimeUnitChoice? = nil) {
        self.field = field 
        self.gte = gte 
        self.timeUnit = timeUnit 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.gte = try values.decode(GteChoice.self, forKey: .gte) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
    }

    /// The value that the field should be greater than or equals to.
    /// Generated by Curio
    public typealias GteChoice = OneOf<String>.Or<Double>.Or<DateTime>.Or<ExprRef>

    /// Time unit for the field to be tested.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case gte
        case timeUnit
        public var keyDescription: String? {
            switch self {
            case .field: return "Field to be tested."
            case .gte: return "The value that the field should be greater than or equals to."
            case .timeUnit: return "Time unit for the field to be tested."
             } 
        }

        public typealias CodingOwner = FieldGTEPredicate
    }
}

/// Generated by Curio
public struct FieldGTPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Field to be tested.
    public var field: FieldName
    /// The value that the field should be greater than.
    public var gt: GtChoice
    /// Time unit for the field to be tested.
    public var timeUnit: TimeUnitChoice?
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.gt as KeyPath, \Self.timeUnit as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.gt as KeyPath : CodingKeys.gt, \Self.timeUnit as KeyPath : CodingKeys.timeUnit]

    public init(field: FieldName, gt: GtChoice, timeUnit: TimeUnitChoice? = nil) {
        self.field = field 
        self.gt = gt 
        self.timeUnit = timeUnit 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.gt = try values.decode(GtChoice.self, forKey: .gt) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
    }

    /// The value that the field should be greater than.
    /// Generated by Curio
    public typealias GtChoice = OneOf<String>.Or<Double>.Or<DateTime>.Or<ExprRef>

    /// Time unit for the field to be tested.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case gt
        case timeUnit
        public var keyDescription: String? {
            switch self {
            case .field: return "Field to be tested."
            case .gt: return "The value that the field should be greater than."
            case .timeUnit: return "Time unit for the field to be tested."
             } 
        }

        public typealias CodingOwner = FieldGTPredicate
    }
}

/// Generated by Curio
public struct FieldLTEPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Field to be tested.
    public var field: FieldName
    /// The value that the field should be less than or equals to.
    public var lte: LteChoice
    /// Time unit for the field to be tested.
    public var timeUnit: TimeUnitChoice?
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.lte as KeyPath, \Self.timeUnit as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.lte as KeyPath : CodingKeys.lte, \Self.timeUnit as KeyPath : CodingKeys.timeUnit]

    public init(field: FieldName, lte: LteChoice, timeUnit: TimeUnitChoice? = nil) {
        self.field = field 
        self.lte = lte 
        self.timeUnit = timeUnit 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.lte = try values.decode(LteChoice.self, forKey: .lte) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
    }

    /// The value that the field should be less than or equals to.
    /// Generated by Curio
    public typealias LteChoice = OneOf<String>.Or<Double>.Or<DateTime>.Or<ExprRef>

    /// Time unit for the field to be tested.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case lte
        case timeUnit
        public var keyDescription: String? {
            switch self {
            case .field: return "Field to be tested."
            case .lte: return "The value that the field should be less than or equals to."
            case .timeUnit: return "Time unit for the field to be tested."
             } 
        }

        public typealias CodingOwner = FieldLTEPredicate
    }
}

/// Generated by Curio
public struct FieldLTPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Field to be tested.
    public var field: FieldName
    /// The value that the field should be less than.
    public var lt: LtChoice
    /// Time unit for the field to be tested.
    public var timeUnit: TimeUnitChoice?
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.lt as KeyPath, \Self.timeUnit as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.lt as KeyPath : CodingKeys.lt, \Self.timeUnit as KeyPath : CodingKeys.timeUnit]

    public init(field: FieldName, lt: LtChoice, timeUnit: TimeUnitChoice? = nil) {
        self.field = field 
        self.lt = lt 
        self.timeUnit = timeUnit 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.lt = try values.decode(LtChoice.self, forKey: .lt) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
    }

    /// The value that the field should be less than.
    /// Generated by Curio
    public typealias LtChoice = OneOf<String>.Or<Double>.Or<DateTime>.Or<ExprRef>

    /// Time unit for the field to be tested.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case lt
        case timeUnit
        public var keyDescription: String? {
            switch self {
            case .field: return "Field to be tested."
            case .lt: return "The value that the field should be less than."
            case .timeUnit: return "Time unit for the field to be tested."
             } 
        }

        public typealias CodingOwner = FieldLTPredicate
    }
}

public struct FieldName : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: String) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct FieldOneOfPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Field to be tested.
    public var field: FieldName
    /// A set of values that the `field`'s value should be a member of, for a data item included in the filtered data.
    public var oneOf: OneOfChoice
    /// Time unit for the field to be tested.
    public var timeUnit: TimeUnitChoice?
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.oneOf as KeyPath, \Self.timeUnit as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.oneOf as KeyPath : CodingKeys.oneOf, \Self.timeUnit as KeyPath : CodingKeys.timeUnit]

    public init(field: FieldName, oneOf: OneOfChoice, timeUnit: TimeUnitChoice? = nil) {
        self.field = field 
        self.oneOf = oneOf 
        self.timeUnit = timeUnit 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.oneOf = try values.decode(OneOfChoice.self, forKey: .oneOf) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
    }

    /// A set of values that the `field`'s value should be a member of, for a data item included in the filtered data.
    /// Generated by Curio
    public typealias OneOfChoice = OneOf<[String]>.Or<[Double]>.Or<[Bool]>.Or<[DateTime]>

    /// Time unit for the field to be tested.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case oneOf
        case timeUnit
        public var keyDescription: String? {
            switch self {
            case .field: return "Field to be tested."
            case .oneOf: return "A set of values that the `field`'s value should be a member of, for a data item included in the filtered data."
            case .timeUnit: return "Time unit for the field to be tested."
             } 
        }

        public typealias CodingOwner = FieldOneOfPredicate
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionDatumDefGradientStringNull : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// A constant value in data domain.
    public var datum: DatumChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: MeasureType?
    public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.type as KeyPath : CodingKeys.type]

    public init(bandPosition: Double? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, type: MeasureType? = nil) {
        self.bandPosition = bandPosition 
        self.condition = condition 
        self.datum = datum 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
        self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
    }

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefGradientStringNullExprRef>

    /// A constant value in data domain.
    /// Generated by Curio
    public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case bandPosition
        case condition
        case datum
        case type
        public var keyDescription: String? {
            switch self {
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .datum: return "A constant value in data domain."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionDatumDefGradientStringNull
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionDatumDefNumber : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// A constant value in data domain.
    public var datum: DatumChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: MeasureType?
    public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.type as KeyPath : CodingKeys.type]

    public init(bandPosition: Double? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, type: MeasureType? = nil) {
        self.bandPosition = bandPosition 
        self.condition = condition 
        self.datum = datum 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
        self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
    }

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefNumberExprRef>

    /// A constant value in data domain.
    /// Generated by Curio
    public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case bandPosition
        case condition
        case datum
        case type
        public var keyDescription: String? {
            switch self {
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .datum: return "A constant value in data domain."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionDatumDefNumber
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionDatumDefNumberArray : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// A constant value in data domain.
    public var datum: DatumChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: MeasureType?
    public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.type as KeyPath : CodingKeys.type]

    public init(bandPosition: Double? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, type: MeasureType? = nil) {
        self.bandPosition = bandPosition 
        self.condition = condition 
        self.datum = datum 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
        self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
    }

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefNumberArrayExprRef>

    /// A constant value in data domain.
    /// Generated by Curio
    public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case bandPosition
        case condition
        case datum
        case type
        public var keyDescription: String? {
            switch self {
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .datum: return "A constant value in data domain."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionDatumDefNumberArray
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionDatumDefStringNull : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// A constant value in data domain.
    public var datum: DatumChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: MeasureType?
    public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.type as KeyPath : CodingKeys.type]

    public init(bandPosition: Double? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, type: MeasureType? = nil) {
        self.bandPosition = bandPosition 
        self.condition = condition 
        self.datum = datum 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
        self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
    }

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefStringNullExprRef>

    /// A constant value in data domain.
    /// Generated by Curio
    public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case bandPosition
        case condition
        case datum
        case type
        public var keyDescription: String? {
            switch self {
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .datum: return "A constant value in data domain."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionDatumDefStringNull
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
    /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
    public var legend: LegendChoice?
    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    public var scale: ScaleChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
    /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
    public var sort: Sort?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.condition = condition 
        self.field = field 
        self.legend = legend 
        self.scale = scale 
        self.sort = sort 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefGradientStringNullExprRef>

    /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
    /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
    /// Generated by Curio
    public typealias LegendChoice = Nullable<LegendDef>

    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    /// Generated by Curio
    public typealias ScaleChoice = Nullable<ScaleDef>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case condition
        case field
        case legend
        case scale
        case sort
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
            case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionMarkPropFieldDefNumber : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
    /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
    public var legend: LegendChoice?
    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    public var scale: ScaleChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
    /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
    public var sort: Sort?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.condition = condition 
        self.field = field 
        self.legend = legend 
        self.scale = scale 
        self.sort = sort 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefNumberExprRef>

    /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
    /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
    /// Generated by Curio
    public typealias LegendChoice = Nullable<LegendDef>

    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    /// Generated by Curio
    public typealias ScaleChoice = Nullable<ScaleDef>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case condition
        case field
        case legend
        case scale
        case sort
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
            case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionMarkPropFieldDefNumber
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionMarkPropFieldDefNumberArray : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
    /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
    public var legend: LegendChoice?
    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    public var scale: ScaleChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
    /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
    public var sort: Sort?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.condition = condition 
        self.field = field 
        self.legend = legend 
        self.scale = scale 
        self.sort = sort 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefNumberArrayExprRef>

    /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
    /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
    /// Generated by Curio
    public typealias LegendChoice = Nullable<LegendDef>

    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    /// Generated by Curio
    public typealias ScaleChoice = Nullable<ScaleDef>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case condition
        case field
        case legend
        case scale
        case sort
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
            case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionMarkPropFieldDefNumberArray
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
    /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
    public var legend: LegendChoice?
    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    public var scale: ScaleChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
    /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
    public var sort: Sort?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: TypeForShape?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeForShape? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.condition = condition 
        self.field = field 
        self.legend = legend 
        self.scale = scale 
        self.sort = sort 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(TypeForShape.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefStringNullExprRef>

    /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
    /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
    /// Generated by Curio
    public typealias LegendChoice = Nullable<LegendDef>

    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    /// Generated by Curio
    public typealias ScaleChoice = Nullable<ScaleDef>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case condition
        case field
        case legend
        case scale
        case sort
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
            case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionStringDatumDefText : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// A constant value in data domain.
    public var datum: DatumChoice?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: MeasureType?
    public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.type as KeyPath : CodingKeys.type]

    public init(bandPosition: Double? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, format: FormatChoice? = nil, formatType: String? = nil, type: MeasureType? = nil) {
        self.bandPosition = bandPosition 
        self.condition = condition 
        self.datum = datum 
        self.format = format 
        self.formatType = formatType 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
    }

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefTextExprRef>

    /// A constant value in data domain.
    /// Generated by Curio
    public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case bandPosition
        case condition
        case datum
        case format
        case formatType
        case type
        public var keyDescription: String? {
            switch self {
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .datum: return "A constant value in data domain."
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionStringDatumDefText
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionStringFieldDefString : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.condition = condition 
        self.field = field 
        self.format = format 
        self.formatType = formatType 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefStringExprRef>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case condition
        case field
        case format
        case formatType
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionStringFieldDefString
    }
}

/// A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
/// Generated by Curio
public struct FieldOrDatumDefWithConditionStringFieldDefText : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.condition = condition 
        self.field = field 
        self.format = format 
        self.formatType = formatType 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefTextExprRef>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case condition
        case field
        case format
        case formatType
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = FieldOrDatumDefWithConditionStringFieldDefText
    }
}

/// Generated by Curio
public struct FieldRangePredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Field to be tested.
    public var field: FieldName
    /// An array of inclusive minimum and maximum values for a field value of a data item to be included in the filtered data.
    public var range: RangeChoice
    /// Time unit for the field to be tested.
    public var timeUnit: TimeUnitChoice?
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.range as KeyPath, \Self.timeUnit as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.range as KeyPath : CodingKeys.range, \Self.timeUnit as KeyPath : CodingKeys.timeUnit]

    public init(field: FieldName, range: RangeChoice, timeUnit: TimeUnitChoice? = nil) {
        self.field = field 
        self.range = range 
        self.timeUnit = timeUnit 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.range = try values.decode(RangeChoice.self, forKey: .range) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
    }

    /// An array of inclusive minimum and maximum values for a field value of a data item to be included in the filtered data.
    /// Generated by Curio
    public typealias RangeChoice = OneOf<[Nullable<OneOf<Double>.Or<DateTime>.Or<ExprRef>>]>.Or<ExprRef>

    /// Time unit for the field to be tested.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case range
        case timeUnit
        public var keyDescription: String? {
            switch self {
            case .field: return "Field to be tested."
            case .range: return "An array of inclusive minimum and maximum values for a field value of a data item to be included in the filtered data."
            case .timeUnit: return "Time unit for the field to be tested."
             } 
        }

        public typealias CodingOwner = FieldRangePredicate
    }
}

/// Generated by Curio
public struct FieldValidPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Field to be tested.
    public var field: FieldName
    /// Time unit for the field to be tested.
    public var timeUnit: TimeUnitChoice?
    /// If set to true the field's value has to be valid, meaning both not `null` and not [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).
    public var valid: Bool
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.valid as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.valid as KeyPath : CodingKeys.valid]

    public init(field: FieldName, timeUnit: TimeUnitChoice? = nil, valid: Bool) {
        self.field = field 
        self.timeUnit = timeUnit 
        self.valid = valid 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.valid = try values.decode(Bool.self, forKey: .valid) 
    }

    /// Time unit for the field to be tested.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case timeUnit
        case valid
        public var keyDescription: String? {
            switch self {
            case .field: return "Field to be tested."
            case .timeUnit: return "Time unit for the field to be tested."
            case .valid: return "If set to true the field's value has to be valid, meaning both not `null` and not [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN)."
             } 
        }

        public typealias CodingOwner = FieldValidPredicate
    }
}

/// Generated by Curio
public struct FilterTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The `filter` property must be a predication definition, which can take one of the following forms:
    /// 1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string, where `datum` can be used to refer to the current data object. For example, `{filter: "datum.b2 > 60"}` would make the output data includes only items that have values in the field `b2` over 60.
    /// 2) one of the [field predicates](https://vega.github.io/vega-lite/docs/predicate.html#field-predicate): [`equal`](https://vega.github.io/vega-lite/docs/predicate.html#field-equal-predicate), [`lt`](https://vega.github.io/vega-lite/docs/predicate.html#lt-predicate), [`lte`](https://vega.github.io/vega-lite/docs/predicate.html#lte-predicate), [`gt`](https://vega.github.io/vega-lite/docs/predicate.html#gt-predicate), [`gte`](https://vega.github.io/vega-lite/docs/predicate.html#gte-predicate), [`range`](https://vega.github.io/vega-lite/docs/predicate.html#range-predicate), [`oneOf`](https://vega.github.io/vega-lite/docs/predicate.html#one-of-predicate), or [`valid`](https://vega.github.io/vega-lite/docs/predicate.html#valid-predicate),
    /// 3) a [selection predicate](https://vega.github.io/vega-lite/docs/predicate.html#selection-predicate), which define the names of a selection that the data point should belong to (or a logical composition of selections).
    /// 4) a [logical composition](https://vega.github.io/vega-lite/docs/predicate.html#composition) of (1), (2), or (3).
    public var filter: PredicateComposition
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.filter as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.filter as KeyPath : CodingKeys.filter]

    public init(id: TransformId? = nil, filter: PredicateComposition) {
        self.id = id 
        self.filter = filter 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.filter = try values.decode(PredicateComposition.self, forKey: .filter) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case filter
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .filter: return "The `filter` property must be a predication definition, which can take one of the following forms:\n\n1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string, where `datum` can be used to refer to the current data object. For example, `{filter: \"datum.b2 > 60\"}` would make the output data includes only items that have values in the field `b2` over 60.\n\n2) one of the [field predicates](https://vega.github.io/vega-lite/docs/predicate.html#field-predicate): [`equal`](https://vega.github.io/vega-lite/docs/predicate.html#field-equal-predicate), [`lt`](https://vega.github.io/vega-lite/docs/predicate.html#lt-predicate), [`lte`](https://vega.github.io/vega-lite/docs/predicate.html#lte-predicate), [`gt`](https://vega.github.io/vega-lite/docs/predicate.html#gt-predicate), [`gte`](https://vega.github.io/vega-lite/docs/predicate.html#gte-predicate), [`range`](https://vega.github.io/vega-lite/docs/predicate.html#range-predicate), [`oneOf`](https://vega.github.io/vega-lite/docs/predicate.html#one-of-predicate), or [`valid`](https://vega.github.io/vega-lite/docs/predicate.html#valid-predicate),\n\n3) a [selection predicate](https://vega.github.io/vega-lite/docs/predicate.html#selection-predicate), which define the names of a selection that the data point should belong to (or a logical composition of selections).\n\n4) a [logical composition](https://vega.github.io/vega-lite/docs/predicate.html#composition) of (1), (2), or (3)."
             } 
        }

        public typealias CodingOwner = FilterTransform
    }
}

public struct Fit : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<GeoJsonFeature>.Or<GeoJsonFeatureCollection>.Or<[GeoJsonFeature]>

    public init(rawValue: OneOf<GeoJsonFeature>.Or<GeoJsonFeatureCollection>.Or<[GeoJsonFeature]>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<GeoJsonFeature>.Or<GeoJsonFeatureCollection>.Or<[GeoJsonFeature]>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct FlattenTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output field names for extracted array values.
    /// __Default value:__ The field name of the corresponding array field
    public var `as`: [FieldName]?
    /// An array of one or more data fields containing arrays to flatten. If multiple fields are specified, their array values should have a parallel structure, ideally with the same length. If the lengths of parallel arrays do not match, the longest array will be used with `null` values added for missing entries.
    public var flatten: [FieldName]
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.flatten as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.flatten as KeyPath : CodingKeys.flatten]

    public init(id: TransformId? = nil, `as`: [FieldName]? = nil, flatten: [FieldName] = []) {
        self.id = id 
        self.`as` = `as` 
        self.flatten = flatten 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decodeOptional([FieldName].self, forKey: .`as`) 
        self.flatten = try values.decode([FieldName].self, forKey: .flatten) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case flatten
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output field names for extracted array values.\n\n__Default value:__ The field name of the corresponding array field"
            case .flatten: return "An array of one or more data fields containing arrays to flatten. If multiple fields are specified, their array values should have a parallel structure, ideally with the same length. If the lengths of parallel arrays do not match, the longest array will be used with `null` values added for missing entries."
             } 
        }

        public typealias CodingOwner = FlattenTransform
    }
}

/// Generated by Curio
public struct FoldTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output field names for the key and value properties produced by the fold transform. __Default value:__ `["key", "value"]`
    public var `as`: [FieldName]?
    /// An array of data fields indicating the properties to fold.
    public var fold: [FieldName]
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.fold as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.fold as KeyPath : CodingKeys.fold]

    public init(id: TransformId? = nil, `as`: [FieldName]? = nil, fold: [FieldName] = []) {
        self.id = id 
        self.`as` = `as` 
        self.fold = fold 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decodeOptional([FieldName].self, forKey: .`as`) 
        self.fold = try values.decode([FieldName].self, forKey: .fold) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case fold
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output field names for the key and value properties produced by the fold transform. __Default value:__ `[\"key\", \"value\"]`"
            case .fold: return "An array of data fields indicating the properties to fold."
             } 
        }

        public typealias CodingOwner = FoldTransform
    }
}

public struct FontName : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: String) {
        self.rawValue = rawValue 
    }
}

public struct FontStyle : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: String) {
        self.rawValue = rawValue 
    }
}

public struct Generator : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<SequenceGenerator>.Or<SphereGenerator>.Or<GraticuleGenerator>

    public init(rawValue: OneOf<SequenceGenerator>.Or<SphereGenerator>.Or<GraticuleGenerator>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<SequenceGenerator>.Or<SphereGenerator>.Or<GraticuleGenerator>) {
        self.rawValue = rawValue 
    }
}

/// Base interface for a unit (single-view) specification.
/// Generated by Curio
public struct GenericUnitSpecEncodingAnyMark : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// A key-value mapping between encoding channels and definition of fields.
    public var encoding: Encoding?
    /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    public var mark: AnyMark
    /// Name of the visualization for later reference.
    public var name: String?
    /// An array of parameters that may either be simple variables, or more complex selections that map user input to data queries.
    public var params: [ParamsItemChoice]?
    /// An object defining properties of geographic projection, which will be applied to `shape` path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other marks.
    public var projection: Projection?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    public static let codingKeyPaths = (\Self.data as KeyPath, \Self.description as KeyPath, \Self.encoding as KeyPath, \Self.mark as KeyPath, \Self.name as KeyPath, \Self.params as KeyPath, \Self.projection as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.encoding as KeyPath : CodingKeys.encoding, \Self.mark as KeyPath : CodingKeys.mark, \Self.name as KeyPath : CodingKeys.name, \Self.params as KeyPath : CodingKeys.params, \Self.projection as KeyPath : CodingKeys.projection, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform]

    public init(data: DataChoice? = nil, description: String? = nil, encoding: Encoding? = nil, mark: AnyMark, name: String? = nil, params: [ParamsItemChoice]? = nil, projection: Projection? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil) {
        self.data = data 
        self.description = description 
        self.encoding = encoding 
        self.mark = mark 
        self.name = name 
        self.params = params 
        self.projection = projection 
        self.title = title 
        self.transform = transform 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.encoding = try values.decodeOptional(Encoding.self, forKey: .encoding) 
        self.mark = try values.decode(AnyMark.self, forKey: .mark) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.projection = try values.decodeOptional(Projection.self, forKey: .projection) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
    }

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<SelectionParameter>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case data
        case description
        case encoding
        case mark
        case name
        case params
        case projection
        case title
        case transform
        public var keyDescription: String? {
            switch self {
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .encoding: return "A key-value mapping between encoding channels and definition of fields."
            case .mark: return "A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`, `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def)."
            case .name: return "Name of the visualization for later reference."
            case .params: return "An array of parameters that may either be simple variables, or more complex selections that map user input to data queries."
            case .projection: return "An object defining properties of geographic projection, which will be applied to `shape` path for `\"geoshape\"` marks and to `latitude` and `\"longitude\"` channels for other marks."
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
             } 
        }

        public typealias CodingOwner = GenericUnitSpecEncodingAnyMark
    }
}

/// Generated by Curio
public struct GradientStop : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The color value at this point in the gradient.
    public var color: ColorLiteral
    /// The offset fraction for the color stop, indicating its position within the gradient.
    public var offset: Double
    public static let codingKeyPaths = (\Self.color as KeyPath, \Self.offset as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.color as KeyPath : CodingKeys.color, \Self.offset as KeyPath : CodingKeys.offset]

    public init(color: ColorLiteral, offset: Double) {
        self.color = color 
        self.offset = offset 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.color = try values.decode(ColorLiteral.self, forKey: .color) 
        self.offset = try values.decode(Double.self, forKey: .offset) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case color
        case offset
        public var keyDescription: String? {
            switch self {
            case .color: return "The color value at this point in the gradient."
            case .offset: return "The offset fraction for the color stop, indicating its position within the gradient."
             } 
        }

        public typealias CodingOwner = GradientStop
    }
}

/// Generated by Curio
public struct GraticuleGenerator : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Generate graticule GeoJSON data for geographic reference lines.
    public var graticule: GraticuleChoice
    /// Provide a placeholder name and bind data at runtime.
    public var name: String?
    public static let codingKeyPaths = (\Self.graticule as KeyPath, \Self.name as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.graticule as KeyPath : CodingKeys.graticule, \Self.name as KeyPath : CodingKeys.name]

    public init(graticule: GraticuleChoice, name: String? = nil) {
        self.graticule = graticule 
        self.name = name 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.graticule = try values.decode(GraticuleChoice.self, forKey: .graticule) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
    }

    /// Generate graticule GeoJSON data for geographic reference lines.
    /// Generated by Curio
    public typealias GraticuleChoice = OneOf<Bool>.Or<GraticuleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case graticule
        case name
        public var keyDescription: String? {
            switch self {
            case .graticule: return "Generate graticule GeoJSON data for geographic reference lines."
            case .name: return "Provide a placeholder name and bind data at runtime."
             } 
        }

        public typealias CodingOwner = GraticuleGenerator
    }
}

/// Generated by Curio
public struct GraticuleParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Sets both the major and minor extents to the same values.
    public var extent: Vector2Vector2Number?
    /// The major extent of the graticule as a two-element array of coordinates.
    public var extentMajor: Vector2Vector2Number?
    /// The minor extent of the graticule as a two-element array of coordinates.
    public var extentMinor: Vector2Vector2Number?
    /// The precision of the graticule in degrees.
    /// __Default value:__ `2.5`
    public var precision: Double?
    /// Sets both the major and minor step angles to the same values.
    public var step: Vector2Number?
    /// The major step angles of the graticule.
    /// __Default value:__ `[90, 360]`
    public var stepMajor: Vector2Number?
    /// The minor step angles of the graticule.
    /// __Default value:__ `[10, 10]`
    public var stepMinor: Vector2Number?
    public static let codingKeyPaths = (\Self.extent as KeyPath, \Self.extentMajor as KeyPath, \Self.extentMinor as KeyPath, \Self.precision as KeyPath, \Self.step as KeyPath, \Self.stepMajor as KeyPath, \Self.stepMinor as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.extent as KeyPath : CodingKeys.extent, \Self.extentMajor as KeyPath : CodingKeys.extentMajor, \Self.extentMinor as KeyPath : CodingKeys.extentMinor, \Self.precision as KeyPath : CodingKeys.precision, \Self.step as KeyPath : CodingKeys.step, \Self.stepMajor as KeyPath : CodingKeys.stepMajor, \Self.stepMinor as KeyPath : CodingKeys.stepMinor]

    public init(extent: Vector2Vector2Number? = nil, extentMajor: Vector2Vector2Number? = nil, extentMinor: Vector2Vector2Number? = nil, precision: Double? = nil, step: Vector2Number? = nil, stepMajor: Vector2Number? = nil, stepMinor: Vector2Number? = nil) {
        self.extent = extent 
        self.extentMajor = extentMajor 
        self.extentMinor = extentMinor 
        self.precision = precision 
        self.step = step 
        self.stepMajor = stepMajor 
        self.stepMinor = stepMinor 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.extent = try values.decodeOptional(Vector2Vector2Number.self, forKey: .extent) 
        self.extentMajor = try values.decodeOptional(Vector2Vector2Number.self, forKey: .extentMajor) 
        self.extentMinor = try values.decodeOptional(Vector2Vector2Number.self, forKey: .extentMinor) 
        self.precision = try values.decodeOptional(Double.self, forKey: .precision) 
        self.step = try values.decodeOptional(Vector2Number.self, forKey: .step) 
        self.stepMajor = try values.decodeOptional(Vector2Number.self, forKey: .stepMajor) 
        self.stepMinor = try values.decodeOptional(Vector2Number.self, forKey: .stepMinor) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case extent
        case extentMajor
        case extentMinor
        case precision
        case step
        case stepMajor
        case stepMinor
        public var keyDescription: String? {
            switch self {
            case .extent: return "Sets both the major and minor extents to the same values."
            case .extentMajor: return "The major extent of the graticule as a two-element array of coordinates."
            case .extentMinor: return "The minor extent of the graticule as a two-element array of coordinates."
            case .precision: return "The precision of the graticule in degrees.\n\n__Default value:__ `2.5`"
            case .step: return "Sets both the major and minor step angles to the same values."
            case .stepMajor: return "The major step angles of the graticule.\n\n\n__Default value:__ `[90, 360]`"
            case .stepMinor: return "The minor step angles of the graticule.\n\n__Default value:__ `[10, 10]`"
             } 
        }

        public typealias CodingOwner = GraticuleParams
    }
}

/// Base interface for a horizontal concatenation specification.
/// Generated by Curio
public struct HConcatSpecGenericSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// __Default value:__ `false`
    public var center: Bool?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// A list of views to be concatenated and put into a row.
    public var hconcat: [Spec]
    /// Name of the visualization for later reference.
    public var name: String?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the concat operator.
    /// __Default value__: `10`
    public var spacing: Double?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.data as KeyPath, \Self.description as KeyPath, \Self.hconcat as KeyPath, \Self.name as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.hconcat as KeyPath : CodingKeys.hconcat, \Self.name as KeyPath : CodingKeys.name, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform]

    public init(id: LayerId? = nil, bounds: LiteralFullOrFlush? = nil, center: Bool? = nil, data: DataChoice? = nil, description: String? = nil, hconcat: [Spec] = [], name: String? = nil, resolve: Resolve? = nil, spacing: Double? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil) {
        self.id = id 
        self.bounds = bounds 
        self.center = center 
        self.data = data 
        self.description = description 
        self.hconcat = hconcat 
        self.name = name 
        self.resolve = resolve 
        self.spacing = spacing 
        self.title = title 
        self.transform = transform 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(Bool.self, forKey: .center) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.hconcat = try values.decode([Spec].self, forKey: .hconcat) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(Double.self, forKey: .spacing) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
    }

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case bounds
        case center
        case data
        case description
        case hconcat
        case name
        case resolve
        case spacing
        case title
        case transform
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\n__Default value:__ `false`"
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .hconcat: return "A list of views to be concatenated and put into a row."
            case .name: return "Name of the visualization for later reference."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the concat operator.\n\n__Default value__: `10`"
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
             } 
        }

        public typealias CodingOwner = HConcatSpecGenericSpec
    }
}

/// Generated by Curio
public struct HeaderConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// Horizontal text alignment of header labels. One of `"left"`, `"center"`, or `"right"`.
    public var labelAlign: LabelAlignChoice?
    /// The anchor position for placing the labels. One of `"start"`, `"middle"`, or `"end"`. For example, with a label orientation of top these anchor positions map to a left-, center-, or right-aligned label.
    public var labelAnchor: TitleAnchor?
    /// The rotation angle of the header labels.
    /// __Default value:__ `0` for column header, `-90` for row header.
    public var labelAngle: Double?
    /// The vertical text baseline for the header labels. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.
    public var labelBaseline: LabelBaselineChoice?
    /// The color of the header label, can be in hex color code or regular color name.
    public var labelColor: LabelColorChoice?
    /// [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
    /// __Note:__ The label text and value can be assessed via the `label` and `value` properties of the header's backing `datum` object.
    public var labelExpr: Expr?
    /// The font of the header label.
    public var labelFont: FontName?
    /// The font size of the header label, in pixels.
    public var labelFontSize: LabelFontSizeChoice?
    /// The font style of the header label.
    public var labelFontStyle: LabelFontStyleChoice?
    /// The font weight of the header label.
    public var labelFontWeight: LabelFontWeightChoice?
    /// The maximum length of the header label in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.
    /// __Default value:__ `0`, indicating no limit
    public var labelLimit: LabelLimitChoice?
    /// Line height in pixels for multi-line header labels or title text with `"line-top"` or `"line-bottom"` baseline.
    public var labelLineHeight: LabelLineHeightChoice?
    /// The orientation of the header label. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
    public var labelOrient: Orient?
    /// The padding, in pixel, between facet header's label and the plot.
    /// __Default value:__ `10`
    public var labelPadding: LabelPaddingChoice?
    /// A boolean flag indicating if labels should be included as part of the header.
    /// __Default value:__ `true`.
    public var labels: Bool?
    /// Shortcut for setting both labelOrient and titleOrient.
    public var orient: Orient?
    /// Set to null to disable title for the axis, legend, or header.
    public var title: ExplicitNull?
    /// Horizontal text alignment (to the anchor) of header titles.
    public var titleAlign: TitleAlignChoice?
    /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.
    public var titleAnchor: TitleAnchor?
    /// The rotation angle of the header title.
    /// __Default value:__ `0`.
    public var titleAngle: Double?
    /// The vertical text baseline for the header title. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.
    /// __Default value:__ `"middle"`
    public var titleBaseline: TitleBaselineChoice?
    /// Color of the header title, can be in hex color code or regular color name.
    public var titleColor: TitleColorChoice?
    /// Font of the header title. (e.g., `"Helvetica Neue"`).
    public var titleFont: FontName?
    /// Font size of the header title.
    public var titleFontSize: TitleFontSizeChoice?
    /// The font style of the header title.
    public var titleFontStyle: TitleFontStyleChoice?
    /// Font weight of the header title. This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`, ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    public var titleFontWeight: TitleFontWeightChoice?
    /// The maximum length of the header title in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.
    /// __Default value:__ `0`, indicating no limit
    public var titleLimit: TitleLimitChoice?
    /// Line height in pixels for multi-line header title text or title text with `"line-top"` or `"line-bottom"` baseline.
    public var titleLineHeight: TitleLineHeightChoice?
    /// The orientation of the header title. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
    public var titleOrient: Orient?
    /// The padding, in pixel, between facet header's title and the label.
    /// __Default value:__ `10`
    public var titlePadding: TitlePaddingChoice?
    public static let codingKeyPaths = (\Self.format as KeyPath, \Self.formatType as KeyPath, \Self.labelAlign as KeyPath, \Self.labelAnchor as KeyPath, \Self.labelAngle as KeyPath, \Self.labelBaseline as KeyPath, \Self.labelColor as KeyPath, \Self.labelExpr as KeyPath, \Self.labelFont as KeyPath, \Self.labelFontSize as KeyPath, \Self.labelFontStyle as KeyPath, \Self.labelFontWeight as KeyPath, \Self.labelLimit as KeyPath, \Self.labelLineHeight as KeyPath, \Self.labelOrient as KeyPath, \Self.labelPadding as KeyPath, \Self.labels as KeyPath, \Self.orient as KeyPath, \Self.title as KeyPath, \Self.titleAlign as KeyPath, \Self.titleAnchor as KeyPath, \Self.titleAngle as KeyPath, \Self.titleBaseline as KeyPath, \Self.titleColor as KeyPath, \Self.titleFont as KeyPath, \Self.titleFontSize as KeyPath, \Self.titleFontStyle as KeyPath, \Self.titleFontWeight as KeyPath, \Self.titleLimit as KeyPath, \Self.titleLineHeight as KeyPath, \Self.titleOrient as KeyPath, \Self.titlePadding as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.labelAlign as KeyPath : CodingKeys.labelAlign, \Self.labelAnchor as KeyPath : CodingKeys.labelAnchor, \Self.labelAngle as KeyPath : CodingKeys.labelAngle, \Self.labelBaseline as KeyPath : CodingKeys.labelBaseline, \Self.labelColor as KeyPath : CodingKeys.labelColor, \Self.labelExpr as KeyPath : CodingKeys.labelExpr, \Self.labelFont as KeyPath : CodingKeys.labelFont, \Self.labelFontSize as KeyPath : CodingKeys.labelFontSize, \Self.labelFontStyle as KeyPath : CodingKeys.labelFontStyle, \Self.labelFontWeight as KeyPath : CodingKeys.labelFontWeight, \Self.labelLimit as KeyPath : CodingKeys.labelLimit, \Self.labelLineHeight as KeyPath : CodingKeys.labelLineHeight, \Self.labelOrient as KeyPath : CodingKeys.labelOrient, \Self.labelPadding as KeyPath : CodingKeys.labelPadding, \Self.labels as KeyPath : CodingKeys.labels, \Self.orient as KeyPath : CodingKeys.orient, \Self.title as KeyPath : CodingKeys.title, \Self.titleAlign as KeyPath : CodingKeys.titleAlign, \Self.titleAnchor as KeyPath : CodingKeys.titleAnchor, \Self.titleAngle as KeyPath : CodingKeys.titleAngle, \Self.titleBaseline as KeyPath : CodingKeys.titleBaseline, \Self.titleColor as KeyPath : CodingKeys.titleColor, \Self.titleFont as KeyPath : CodingKeys.titleFont, \Self.titleFontSize as KeyPath : CodingKeys.titleFontSize, \Self.titleFontStyle as KeyPath : CodingKeys.titleFontStyle, \Self.titleFontWeight as KeyPath : CodingKeys.titleFontWeight, \Self.titleLimit as KeyPath : CodingKeys.titleLimit, \Self.titleLineHeight as KeyPath : CodingKeys.titleLineHeight, \Self.titleOrient as KeyPath : CodingKeys.titleOrient, \Self.titlePadding as KeyPath : CodingKeys.titlePadding]

    public init(format: FormatChoice? = nil, formatType: String? = nil, labelAlign: LabelAlignChoice? = nil, labelAnchor: TitleAnchor? = nil, labelAngle: Double? = nil, labelBaseline: LabelBaselineChoice? = nil, labelColor: LabelColorChoice? = nil, labelExpr: Expr? = nil, labelFont: FontName? = nil, labelFontSize: LabelFontSizeChoice? = nil, labelFontStyle: LabelFontStyleChoice? = nil, labelFontWeight: LabelFontWeightChoice? = nil, labelLimit: LabelLimitChoice? = nil, labelLineHeight: LabelLineHeightChoice? = nil, labelOrient: Orient? = nil, labelPadding: LabelPaddingChoice? = nil, labels: Bool? = nil, orient: Orient? = nil, title: ExplicitNull? = nil, titleAlign: TitleAlignChoice? = nil, titleAnchor: TitleAnchor? = nil, titleAngle: Double? = nil, titleBaseline: TitleBaselineChoice? = nil, titleColor: TitleColorChoice? = nil, titleFont: FontName? = nil, titleFontSize: TitleFontSizeChoice? = nil, titleFontStyle: TitleFontStyleChoice? = nil, titleFontWeight: TitleFontWeightChoice? = nil, titleLimit: TitleLimitChoice? = nil, titleLineHeight: TitleLineHeightChoice? = nil, titleOrient: Orient? = nil, titlePadding: TitlePaddingChoice? = nil) {
        self.format = format 
        self.formatType = formatType 
        self.labelAlign = labelAlign 
        self.labelAnchor = labelAnchor 
        self.labelAngle = labelAngle 
        self.labelBaseline = labelBaseline 
        self.labelColor = labelColor 
        self.labelExpr = labelExpr 
        self.labelFont = labelFont 
        self.labelFontSize = labelFontSize 
        self.labelFontStyle = labelFontStyle 
        self.labelFontWeight = labelFontWeight 
        self.labelLimit = labelLimit 
        self.labelLineHeight = labelLineHeight 
        self.labelOrient = labelOrient 
        self.labelPadding = labelPadding 
        self.labels = labels 
        self.orient = orient 
        self.title = title 
        self.titleAlign = titleAlign 
        self.titleAnchor = titleAnchor 
        self.titleAngle = titleAngle 
        self.titleBaseline = titleBaseline 
        self.titleColor = titleColor 
        self.titleFont = titleFont 
        self.titleFontSize = titleFontSize 
        self.titleFontStyle = titleFontStyle 
        self.titleFontWeight = titleFontWeight 
        self.titleLimit = titleLimit 
        self.titleLineHeight = titleLineHeight 
        self.titleOrient = titleOrient 
        self.titlePadding = titlePadding 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.labelAlign = try values.decodeOptional(LabelAlignChoice.self, forKey: .labelAlign) 
        self.labelAnchor = try values.decodeOptional(TitleAnchor.self, forKey: .labelAnchor) 
        self.labelAngle = try values.decodeOptional(Double.self, forKey: .labelAngle) 
        self.labelBaseline = try values.decodeOptional(LabelBaselineChoice.self, forKey: .labelBaseline) 
        self.labelColor = try values.decodeOptional(LabelColorChoice.self, forKey: .labelColor) 
        self.labelExpr = try values.decodeOptional(Expr.self, forKey: .labelExpr) 
        self.labelFont = try values.decodeOptional(FontName.self, forKey: .labelFont) 
        self.labelFontSize = try values.decodeOptional(LabelFontSizeChoice.self, forKey: .labelFontSize) 
        self.labelFontStyle = try values.decodeOptional(LabelFontStyleChoice.self, forKey: .labelFontStyle) 
        self.labelFontWeight = try values.decodeOptional(LabelFontWeightChoice.self, forKey: .labelFontWeight) 
        self.labelLimit = try values.decodeOptional(LabelLimitChoice.self, forKey: .labelLimit) 
        self.labelLineHeight = try values.decodeOptional(LabelLineHeightChoice.self, forKey: .labelLineHeight) 
        self.labelOrient = try values.decodeOptional(Orient.self, forKey: .labelOrient) 
        self.labelPadding = try values.decodeOptional(LabelPaddingChoice.self, forKey: .labelPadding) 
        self.labels = try values.decodeOptional(Bool.self, forKey: .labels) 
        self.orient = try values.decodeOptional(Orient.self, forKey: .orient) 
        self.title = try values.decodeOptional(ExplicitNull.self, forKey: .title) 
        self.titleAlign = try values.decodeOptional(TitleAlignChoice.self, forKey: .titleAlign) 
        self.titleAnchor = try values.decodeOptional(TitleAnchor.self, forKey: .titleAnchor) 
        self.titleAngle = try values.decodeOptional(Double.self, forKey: .titleAngle) 
        self.titleBaseline = try values.decodeOptional(TitleBaselineChoice.self, forKey: .titleBaseline) 
        self.titleColor = try values.decodeOptional(TitleColorChoice.self, forKey: .titleColor) 
        self.titleFont = try values.decodeOptional(FontName.self, forKey: .titleFont) 
        self.titleFontSize = try values.decodeOptional(TitleFontSizeChoice.self, forKey: .titleFontSize) 
        self.titleFontStyle = try values.decodeOptional(TitleFontStyleChoice.self, forKey: .titleFontStyle) 
        self.titleFontWeight = try values.decodeOptional(TitleFontWeightChoice.self, forKey: .titleFontWeight) 
        self.titleLimit = try values.decodeOptional(TitleLimitChoice.self, forKey: .titleLimit) 
        self.titleLineHeight = try values.decodeOptional(TitleLineHeightChoice.self, forKey: .titleLineHeight) 
        self.titleOrient = try values.decodeOptional(Orient.self, forKey: .titleOrient) 
        self.titlePadding = try values.decodeOptional(TitlePaddingChoice.self, forKey: .titlePadding) 
    }

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Horizontal text alignment of header labels. One of `"left"`, `"center"`, or `"right"`.
    /// Generated by Curio
    public typealias LabelAlignChoice = OneOf<Align>.Or<ExprRef>

    /// The vertical text baseline for the header labels. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.
    /// Generated by Curio
    public typealias LabelBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// The color of the header label, can be in hex color code or regular color name.
    /// Generated by Curio
    public typealias LabelColorChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// The font size of the header label, in pixels.
    /// Generated by Curio
    public typealias LabelFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// The font style of the header label.
    /// Generated by Curio
    public typealias LabelFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// The font weight of the header label.
    /// Generated by Curio
    public typealias LabelFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// The maximum length of the header label in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.
    /// __Default value:__ `0`, indicating no limit
    /// Generated by Curio
    public typealias LabelLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Line height in pixels for multi-line header labels or title text with `"line-top"` or `"line-bottom"` baseline.
    /// Generated by Curio
    public typealias LabelLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The padding, in pixel, between facet header's label and the plot.
    /// __Default value:__ `10`
    /// Generated by Curio
    public typealias LabelPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Horizontal text alignment (to the anchor) of header titles.
    /// Generated by Curio
    public typealias TitleAlignChoice = OneOf<Align>.Or<ExprRef>

    /// The vertical text baseline for the header title. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.
    /// __Default value:__ `"middle"`
    /// Generated by Curio
    public typealias TitleBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Color of the header title, can be in hex color code or regular color name.
    /// Generated by Curio
    public typealias TitleColorChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// Font size of the header title.
    /// Generated by Curio
    public typealias TitleFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// The font style of the header title.
    /// Generated by Curio
    public typealias TitleFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Font weight of the header title. This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`, ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    /// Generated by Curio
    public typealias TitleFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// The maximum length of the header title in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.
    /// __Default value:__ `0`, indicating no limit
    /// Generated by Curio
    public typealias TitleLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Line height in pixels for multi-line header title text or title text with `"line-top"` or `"line-bottom"` baseline.
    /// Generated by Curio
    public typealias TitleLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The padding, in pixel, between facet header's title and the label.
    /// __Default value:__ `10`
    /// Generated by Curio
    public typealias TitlePaddingChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case format
        case formatType
        case labelAlign
        case labelAnchor
        case labelAngle
        case labelBaseline
        case labelColor
        case labelExpr
        case labelFont
        case labelFontSize
        case labelFontStyle
        case labelFontWeight
        case labelLimit
        case labelLineHeight
        case labelOrient
        case labelPadding
        case labels
        case orient
        case title
        case titleAlign
        case titleAnchor
        case titleAngle
        case titleBaseline
        case titleColor
        case titleFont
        case titleFontSize
        case titleFontStyle
        case titleFontWeight
        case titleLimit
        case titleLineHeight
        case titleOrient
        case titlePadding
        public var keyDescription: String? {
            switch self {
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .labelAlign: return "Horizontal text alignment of header labels. One of `\"left\"`, `\"center\"`, or `\"right\"`."
            case .labelAnchor: return "The anchor position for placing the labels. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with a label orientation of top these anchor positions map to a left-, center-, or right-aligned label."
            case .labelAngle: return "The rotation angle of the header labels.\n\n__Default value:__ `0` for column header, `-90` for row header."
            case .labelBaseline: return "The vertical text baseline for the header labels. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, or `\"line-bottom\"`. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone."
            case .labelColor: return "The color of the header label, can be in hex color code or regular color name."
            case .labelExpr: return "[Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.\n\n__Note:__ The label text and value can be assessed via the `label` and `value` properties of the header's backing `datum` object."
            case .labelFont: return "The font of the header label."
            case .labelFontSize: return "The font size of the header label, in pixels."
            case .labelFontStyle: return "The font style of the header label."
            case .labelFontWeight: return "The font weight of the header label."
            case .labelLimit: return "The maximum length of the header label in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.\n\n__Default value:__ `0`, indicating no limit"
            case .labelLineHeight: return "Line height in pixels for multi-line header labels or title text with `\"line-top\"` or `\"line-bottom\"` baseline."
            case .labelOrient: return "The orientation of the header label. One of `\"top\"`, `\"bottom\"`, `\"left\"` or `\"right\"`."
            case .labelPadding: return "The padding, in pixel, between facet header's label and the plot.\n\n__Default value:__ `10`"
            case .labels: return "A boolean flag indicating if labels should be included as part of the header.\n\n__Default value:__ `true`."
            case .orient: return "Shortcut for setting both labelOrient and titleOrient."
            case .title: return "Set to null to disable title for the axis, legend, or header."
            case .titleAlign: return "Horizontal text alignment (to the anchor) of header titles."
            case .titleAnchor: return "The anchor position for placing the title. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title."
            case .titleAngle: return "The rotation angle of the header title.\n\n__Default value:__ `0`."
            case .titleBaseline: return "The vertical text baseline for the header title. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, or `\"line-bottom\"`. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.\n\n__Default value:__ `\"middle\"`"
            case .titleColor: return "Color of the header title, can be in hex color code or regular color name."
            case .titleFont: return "Font of the header title. (e.g., `\"Helvetica Neue\"`)."
            case .titleFontSize: return "Font size of the header title."
            case .titleFontStyle: return "The font style of the header title."
            case .titleFontWeight: return "Font weight of the header title. This can be either a string (e.g `\"bold\"`, `\"normal\"`) or a number (`100`, `200`, `300`, ..., `900` where `\"normal\"` = `400` and `\"bold\"` = `700`)."
            case .titleLimit: return "The maximum length of the header title in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.\n\n__Default value:__ `0`, indicating no limit"
            case .titleLineHeight: return "Line height in pixels for multi-line header title text or title text with `\"line-top\"` or `\"line-bottom\"` baseline."
            case .titleOrient: return "The orientation of the header title. One of `\"top\"`, `\"bottom\"`, `\"left\"` or `\"right\"`."
            case .titlePadding: return "The padding, in pixel, between facet header's title and the label.\n\n__Default value:__ `10`"
             } 
        }

        public typealias CodingOwner = HeaderConfig
    }
}

/// Headers of row / column channels for faceted plots.
/// Generated by Curio
public struct HeaderDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// Horizontal text alignment of header labels. One of `"left"`, `"center"`, or `"right"`.
    public var labelAlign: LabelAlignChoice?
    /// The anchor position for placing the labels. One of `"start"`, `"middle"`, or `"end"`. For example, with a label orientation of top these anchor positions map to a left-, center-, or right-aligned label.
    public var labelAnchor: TitleAnchor?
    /// The rotation angle of the header labels.
    /// __Default value:__ `0` for column header, `-90` for row header.
    public var labelAngle: Double?
    /// The vertical text baseline for the header labels. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.
    public var labelBaseline: LabelBaselineChoice?
    /// The color of the header label, can be in hex color code or regular color name.
    public var labelColor: LabelColorChoice?
    /// [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
    /// __Note:__ The label text and value can be assessed via the `label` and `value` properties of the header's backing `datum` object.
    public var labelExpr: Expr?
    /// The font of the header label.
    public var labelFont: FontName?
    /// The font size of the header label, in pixels.
    public var labelFontSize: LabelFontSizeChoice?
    /// The font style of the header label.
    public var labelFontStyle: LabelFontStyleChoice?
    /// The font weight of the header label.
    public var labelFontWeight: LabelFontWeightChoice?
    /// The maximum length of the header label in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.
    /// __Default value:__ `0`, indicating no limit
    public var labelLimit: LabelLimitChoice?
    /// Line height in pixels for multi-line header labels or title text with `"line-top"` or `"line-bottom"` baseline.
    public var labelLineHeight: LabelLineHeightChoice?
    /// The orientation of the header label. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
    public var labelOrient: Orient?
    /// The padding, in pixel, between facet header's label and the plot.
    /// __Default value:__ `10`
    public var labelPadding: LabelPaddingChoice?
    /// A boolean flag indicating if labels should be included as part of the header.
    /// __Default value:__ `true`.
    public var labels: Bool?
    /// Shortcut for setting both labelOrient and titleOrient.
    public var orient: Orient?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// Horizontal text alignment (to the anchor) of header titles.
    public var titleAlign: TitleAlignChoice?
    /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.
    public var titleAnchor: TitleAnchor?
    /// The rotation angle of the header title.
    /// __Default value:__ `0`.
    public var titleAngle: Double?
    /// The vertical text baseline for the header title. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.
    /// __Default value:__ `"middle"`
    public var titleBaseline: TitleBaselineChoice?
    /// Color of the header title, can be in hex color code or regular color name.
    public var titleColor: TitleColorChoice?
    /// Font of the header title. (e.g., `"Helvetica Neue"`).
    public var titleFont: FontName?
    /// Font size of the header title.
    public var titleFontSize: TitleFontSizeChoice?
    /// The font style of the header title.
    public var titleFontStyle: TitleFontStyleChoice?
    /// Font weight of the header title. This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`, ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    public var titleFontWeight: TitleFontWeightChoice?
    /// The maximum length of the header title in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.
    /// __Default value:__ `0`, indicating no limit
    public var titleLimit: TitleLimitChoice?
    /// Line height in pixels for multi-line header title text or title text with `"line-top"` or `"line-bottom"` baseline.
    public var titleLineHeight: TitleLineHeightChoice?
    /// The orientation of the header title. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
    public var titleOrient: Orient?
    /// The padding, in pixel, between facet header's title and the label.
    /// __Default value:__ `10`
    public var titlePadding: TitlePaddingChoice?
    public static let codingKeyPaths = (\Self.format as KeyPath, \Self.formatType as KeyPath, \Self.labelAlign as KeyPath, \Self.labelAnchor as KeyPath, \Self.labelAngle as KeyPath, \Self.labelBaseline as KeyPath, \Self.labelColor as KeyPath, \Self.labelExpr as KeyPath, \Self.labelFont as KeyPath, \Self.labelFontSize as KeyPath, \Self.labelFontStyle as KeyPath, \Self.labelFontWeight as KeyPath, \Self.labelLimit as KeyPath, \Self.labelLineHeight as KeyPath, \Self.labelOrient as KeyPath, \Self.labelPadding as KeyPath, \Self.labels as KeyPath, \Self.orient as KeyPath, \Self.title as KeyPath, \Self.titleAlign as KeyPath, \Self.titleAnchor as KeyPath, \Self.titleAngle as KeyPath, \Self.titleBaseline as KeyPath, \Self.titleColor as KeyPath, \Self.titleFont as KeyPath, \Self.titleFontSize as KeyPath, \Self.titleFontStyle as KeyPath, \Self.titleFontWeight as KeyPath, \Self.titleLimit as KeyPath, \Self.titleLineHeight as KeyPath, \Self.titleOrient as KeyPath, \Self.titlePadding as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.labelAlign as KeyPath : CodingKeys.labelAlign, \Self.labelAnchor as KeyPath : CodingKeys.labelAnchor, \Self.labelAngle as KeyPath : CodingKeys.labelAngle, \Self.labelBaseline as KeyPath : CodingKeys.labelBaseline, \Self.labelColor as KeyPath : CodingKeys.labelColor, \Self.labelExpr as KeyPath : CodingKeys.labelExpr, \Self.labelFont as KeyPath : CodingKeys.labelFont, \Self.labelFontSize as KeyPath : CodingKeys.labelFontSize, \Self.labelFontStyle as KeyPath : CodingKeys.labelFontStyle, \Self.labelFontWeight as KeyPath : CodingKeys.labelFontWeight, \Self.labelLimit as KeyPath : CodingKeys.labelLimit, \Self.labelLineHeight as KeyPath : CodingKeys.labelLineHeight, \Self.labelOrient as KeyPath : CodingKeys.labelOrient, \Self.labelPadding as KeyPath : CodingKeys.labelPadding, \Self.labels as KeyPath : CodingKeys.labels, \Self.orient as KeyPath : CodingKeys.orient, \Self.title as KeyPath : CodingKeys.title, \Self.titleAlign as KeyPath : CodingKeys.titleAlign, \Self.titleAnchor as KeyPath : CodingKeys.titleAnchor, \Self.titleAngle as KeyPath : CodingKeys.titleAngle, \Self.titleBaseline as KeyPath : CodingKeys.titleBaseline, \Self.titleColor as KeyPath : CodingKeys.titleColor, \Self.titleFont as KeyPath : CodingKeys.titleFont, \Self.titleFontSize as KeyPath : CodingKeys.titleFontSize, \Self.titleFontStyle as KeyPath : CodingKeys.titleFontStyle, \Self.titleFontWeight as KeyPath : CodingKeys.titleFontWeight, \Self.titleLimit as KeyPath : CodingKeys.titleLimit, \Self.titleLineHeight as KeyPath : CodingKeys.titleLineHeight, \Self.titleOrient as KeyPath : CodingKeys.titleOrient, \Self.titlePadding as KeyPath : CodingKeys.titlePadding]

    public init(format: FormatChoice? = nil, formatType: String? = nil, labelAlign: LabelAlignChoice? = nil, labelAnchor: TitleAnchor? = nil, labelAngle: Double? = nil, labelBaseline: LabelBaselineChoice? = nil, labelColor: LabelColorChoice? = nil, labelExpr: Expr? = nil, labelFont: FontName? = nil, labelFontSize: LabelFontSizeChoice? = nil, labelFontStyle: LabelFontStyleChoice? = nil, labelFontWeight: LabelFontWeightChoice? = nil, labelLimit: LabelLimitChoice? = nil, labelLineHeight: LabelLineHeightChoice? = nil, labelOrient: Orient? = nil, labelPadding: LabelPaddingChoice? = nil, labels: Bool? = nil, orient: Orient? = nil, title: TitleChoice? = nil, titleAlign: TitleAlignChoice? = nil, titleAnchor: TitleAnchor? = nil, titleAngle: Double? = nil, titleBaseline: TitleBaselineChoice? = nil, titleColor: TitleColorChoice? = nil, titleFont: FontName? = nil, titleFontSize: TitleFontSizeChoice? = nil, titleFontStyle: TitleFontStyleChoice? = nil, titleFontWeight: TitleFontWeightChoice? = nil, titleLimit: TitleLimitChoice? = nil, titleLineHeight: TitleLineHeightChoice? = nil, titleOrient: Orient? = nil, titlePadding: TitlePaddingChoice? = nil) {
        self.format = format 
        self.formatType = formatType 
        self.labelAlign = labelAlign 
        self.labelAnchor = labelAnchor 
        self.labelAngle = labelAngle 
        self.labelBaseline = labelBaseline 
        self.labelColor = labelColor 
        self.labelExpr = labelExpr 
        self.labelFont = labelFont 
        self.labelFontSize = labelFontSize 
        self.labelFontStyle = labelFontStyle 
        self.labelFontWeight = labelFontWeight 
        self.labelLimit = labelLimit 
        self.labelLineHeight = labelLineHeight 
        self.labelOrient = labelOrient 
        self.labelPadding = labelPadding 
        self.labels = labels 
        self.orient = orient 
        self.title = title 
        self.titleAlign = titleAlign 
        self.titleAnchor = titleAnchor 
        self.titleAngle = titleAngle 
        self.titleBaseline = titleBaseline 
        self.titleColor = titleColor 
        self.titleFont = titleFont 
        self.titleFontSize = titleFontSize 
        self.titleFontStyle = titleFontStyle 
        self.titleFontWeight = titleFontWeight 
        self.titleLimit = titleLimit 
        self.titleLineHeight = titleLineHeight 
        self.titleOrient = titleOrient 
        self.titlePadding = titlePadding 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.labelAlign = try values.decodeOptional(LabelAlignChoice.self, forKey: .labelAlign) 
        self.labelAnchor = try values.decodeOptional(TitleAnchor.self, forKey: .labelAnchor) 
        self.labelAngle = try values.decodeOptional(Double.self, forKey: .labelAngle) 
        self.labelBaseline = try values.decodeOptional(LabelBaselineChoice.self, forKey: .labelBaseline) 
        self.labelColor = try values.decodeOptional(LabelColorChoice.self, forKey: .labelColor) 
        self.labelExpr = try values.decodeOptional(Expr.self, forKey: .labelExpr) 
        self.labelFont = try values.decodeOptional(FontName.self, forKey: .labelFont) 
        self.labelFontSize = try values.decodeOptional(LabelFontSizeChoice.self, forKey: .labelFontSize) 
        self.labelFontStyle = try values.decodeOptional(LabelFontStyleChoice.self, forKey: .labelFontStyle) 
        self.labelFontWeight = try values.decodeOptional(LabelFontWeightChoice.self, forKey: .labelFontWeight) 
        self.labelLimit = try values.decodeOptional(LabelLimitChoice.self, forKey: .labelLimit) 
        self.labelLineHeight = try values.decodeOptional(LabelLineHeightChoice.self, forKey: .labelLineHeight) 
        self.labelOrient = try values.decodeOptional(Orient.self, forKey: .labelOrient) 
        self.labelPadding = try values.decodeOptional(LabelPaddingChoice.self, forKey: .labelPadding) 
        self.labels = try values.decodeOptional(Bool.self, forKey: .labels) 
        self.orient = try values.decodeOptional(Orient.self, forKey: .orient) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.titleAlign = try values.decodeOptional(TitleAlignChoice.self, forKey: .titleAlign) 
        self.titleAnchor = try values.decodeOptional(TitleAnchor.self, forKey: .titleAnchor) 
        self.titleAngle = try values.decodeOptional(Double.self, forKey: .titleAngle) 
        self.titleBaseline = try values.decodeOptional(TitleBaselineChoice.self, forKey: .titleBaseline) 
        self.titleColor = try values.decodeOptional(TitleColorChoice.self, forKey: .titleColor) 
        self.titleFont = try values.decodeOptional(FontName.self, forKey: .titleFont) 
        self.titleFontSize = try values.decodeOptional(TitleFontSizeChoice.self, forKey: .titleFontSize) 
        self.titleFontStyle = try values.decodeOptional(TitleFontStyleChoice.self, forKey: .titleFontStyle) 
        self.titleFontWeight = try values.decodeOptional(TitleFontWeightChoice.self, forKey: .titleFontWeight) 
        self.titleLimit = try values.decodeOptional(TitleLimitChoice.self, forKey: .titleLimit) 
        self.titleLineHeight = try values.decodeOptional(TitleLineHeightChoice.self, forKey: .titleLineHeight) 
        self.titleOrient = try values.decodeOptional(Orient.self, forKey: .titleOrient) 
        self.titlePadding = try values.decodeOptional(TitlePaddingChoice.self, forKey: .titlePadding) 
    }

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Horizontal text alignment of header labels. One of `"left"`, `"center"`, or `"right"`.
    /// Generated by Curio
    public typealias LabelAlignChoice = OneOf<Align>.Or<ExprRef>

    /// The vertical text baseline for the header labels. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.
    /// Generated by Curio
    public typealias LabelBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// The color of the header label, can be in hex color code or regular color name.
    /// Generated by Curio
    public typealias LabelColorChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// The font size of the header label, in pixels.
    /// Generated by Curio
    public typealias LabelFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// The font style of the header label.
    /// Generated by Curio
    public typealias LabelFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// The font weight of the header label.
    /// Generated by Curio
    public typealias LabelFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// The maximum length of the header label in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.
    /// __Default value:__ `0`, indicating no limit
    /// Generated by Curio
    public typealias LabelLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Line height in pixels for multi-line header labels or title text with `"line-top"` or `"line-bottom"` baseline.
    /// Generated by Curio
    public typealias LabelLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The padding, in pixel, between facet header's label and the plot.
    /// __Default value:__ `10`
    /// Generated by Curio
    public typealias LabelPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Horizontal text alignment (to the anchor) of header titles.
    /// Generated by Curio
    public typealias TitleAlignChoice = OneOf<Align>.Or<ExprRef>

    /// The vertical text baseline for the header title. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.
    /// __Default value:__ `"middle"`
    /// Generated by Curio
    public typealias TitleBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    /// Color of the header title, can be in hex color code or regular color name.
    /// Generated by Curio
    public typealias TitleColorChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// Font size of the header title.
    /// Generated by Curio
    public typealias TitleFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// The font style of the header title.
    /// Generated by Curio
    public typealias TitleFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Font weight of the header title. This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`, ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    /// Generated by Curio
    public typealias TitleFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// The maximum length of the header title in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.
    /// __Default value:__ `0`, indicating no limit
    /// Generated by Curio
    public typealias TitleLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Line height in pixels for multi-line header title text or title text with `"line-top"` or `"line-bottom"` baseline.
    /// Generated by Curio
    public typealias TitleLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The padding, in pixel, between facet header's title and the label.
    /// __Default value:__ `10`
    /// Generated by Curio
    public typealias TitlePaddingChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case format
        case formatType
        case labelAlign
        case labelAnchor
        case labelAngle
        case labelBaseline
        case labelColor
        case labelExpr
        case labelFont
        case labelFontSize
        case labelFontStyle
        case labelFontWeight
        case labelLimit
        case labelLineHeight
        case labelOrient
        case labelPadding
        case labels
        case orient
        case title
        case titleAlign
        case titleAnchor
        case titleAngle
        case titleBaseline
        case titleColor
        case titleFont
        case titleFontSize
        case titleFontStyle
        case titleFontWeight
        case titleLimit
        case titleLineHeight
        case titleOrient
        case titlePadding
        public var keyDescription: String? {
            switch self {
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .labelAlign: return "Horizontal text alignment of header labels. One of `\"left\"`, `\"center\"`, or `\"right\"`."
            case .labelAnchor: return "The anchor position for placing the labels. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with a label orientation of top these anchor positions map to a left-, center-, or right-aligned label."
            case .labelAngle: return "The rotation angle of the header labels.\n\n__Default value:__ `0` for column header, `-90` for row header."
            case .labelBaseline: return "The vertical text baseline for the header labels. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, or `\"line-bottom\"`. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone."
            case .labelColor: return "The color of the header label, can be in hex color code or regular color name."
            case .labelExpr: return "[Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.\n\n__Note:__ The label text and value can be assessed via the `label` and `value` properties of the header's backing `datum` object."
            case .labelFont: return "The font of the header label."
            case .labelFontSize: return "The font size of the header label, in pixels."
            case .labelFontStyle: return "The font style of the header label."
            case .labelFontWeight: return "The font weight of the header label."
            case .labelLimit: return "The maximum length of the header label in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.\n\n__Default value:__ `0`, indicating no limit"
            case .labelLineHeight: return "Line height in pixels for multi-line header labels or title text with `\"line-top\"` or `\"line-bottom\"` baseline."
            case .labelOrient: return "The orientation of the header label. One of `\"top\"`, `\"bottom\"`, `\"left\"` or `\"right\"`."
            case .labelPadding: return "The padding, in pixel, between facet header's label and the plot.\n\n__Default value:__ `10`"
            case .labels: return "A boolean flag indicating if labels should be included as part of the header.\n\n__Default value:__ `true`."
            case .orient: return "Shortcut for setting both labelOrient and titleOrient."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .titleAlign: return "Horizontal text alignment (to the anchor) of header titles."
            case .titleAnchor: return "The anchor position for placing the title. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title."
            case .titleAngle: return "The rotation angle of the header title.\n\n__Default value:__ `0`."
            case .titleBaseline: return "The vertical text baseline for the header title. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, or `\"line-bottom\"`. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `titleLineHeight` rather than `titleFontSize` alone.\n\n__Default value:__ `\"middle\"`"
            case .titleColor: return "Color of the header title, can be in hex color code or regular color name."
            case .titleFont: return "Font of the header title. (e.g., `\"Helvetica Neue\"`)."
            case .titleFontSize: return "Font size of the header title."
            case .titleFontStyle: return "The font style of the header title."
            case .titleFontWeight: return "Font weight of the header title. This can be either a string (e.g `\"bold\"`, `\"normal\"`) or a number (`100`, `200`, `300`, ..., `900` where `\"normal\"` = `400` and `\"bold\"` = `700`)."
            case .titleLimit: return "The maximum length of the header title in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.\n\n__Default value:__ `0`, indicating no limit"
            case .titleLineHeight: return "Line height in pixels for multi-line header title text or title text with `\"line-top\"` or `\"line-bottom\"` baseline."
            case .titleOrient: return "The orientation of the header title. One of `\"top\"`, `\"bottom\"`, `\"left\"` or `\"right\"`."
            case .titlePadding: return "The padding, in pixel, between facet header's title and the label.\n\n__Default value:__ `10`"
             } 
        }

        public typealias CodingOwner = HeaderDef
    }
}

public struct HexColor : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: String) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct ImputeParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A frame specification as a two-element array used to control the window over which the specified method is applied. The array entries should either be a number indicating the offset from the current data object, or null to indicate unbounded rows preceding or following the current data object. For example, the value `[-5, 5]` indicates that the window should include five objects preceding and five objects following the current object.
    /// __Default value:__:  `[null, null]` indicating that the window includes all objects.
    public var frame: [FrameItemChoice]?
    /// Defines the key values that should be considered for imputation. An array of key values or an object defining a [number sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
    /// If provided, this will be used in addition to the key values observed within the input data. If not provided, the values will be derived from all unique values of the `key` field. For `impute` in `encoding`, the key field is the x-field if the y-field is imputed, or vice versa.
    /// If there is no impute grouping, this property _must_ be specified.
    public var keyvals: KeyvalsChoice?
    /// The imputation method to use for the field value of imputed data objects. One of `"value"`, `"mean"`, `"median"`, `"max"` or `"min"`.
    /// __Default value:__  `"value"`
    public var method: ImputeMethod?
    /// The field value to use when the imputation `method` is `"value"`.
    public var value: Value?
    public static let codingKeyPaths = (\Self.frame as KeyPath, \Self.keyvals as KeyPath, \Self.method as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.frame as KeyPath : CodingKeys.frame, \Self.keyvals as KeyPath : CodingKeys.keyvals, \Self.method as KeyPath : CodingKeys.method, \Self.value as KeyPath : CodingKeys.value]

    public init(frame: [FrameItemChoice]? = nil, keyvals: KeyvalsChoice? = nil, method: ImputeMethod? = nil, value: Value? = nil) {
        self.frame = frame 
        self.keyvals = keyvals 
        self.method = method 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.frame = try values.decodeOptional([FrameItemChoice].self, forKey: .frame) 
        self.keyvals = try values.decodeOptional(KeyvalsChoice.self, forKey: .keyvals) 
        self.method = try values.decodeOptional(ImputeMethod.self, forKey: .method) 
        self.value = try values.decodeOptional(Value.self, forKey: .value) 
    }

    /// Generated by Curio
    public typealias FrameItemChoice = Nullable<Double>

    /// Defines the key values that should be considered for imputation. An array of key values or an object defining a [number sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
    /// If provided, this will be used in addition to the key values observed within the input data. If not provided, the values will be derived from all unique values of the `key` field. For `impute` in `encoding`, the key field is the x-field if the y-field is imputed, or vice versa.
    /// If there is no impute grouping, this property _must_ be specified.
    /// Generated by Curio
    public typealias KeyvalsChoice = OneOf<[Bric]>.Or<ImputeSequence>

    public typealias Value = Bric

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case frame
        case keyvals
        case method
        case value
        public var keyDescription: String? {
            switch self {
            case .frame: return "A frame specification as a two-element array used to control the window over which the specified method is applied. The array entries should either be a number indicating the offset from the current data object, or null to indicate unbounded rows preceding or following the current data object. For example, the value `[-5, 5]` indicates that the window should include five objects preceding and five objects following the current object.\n\n__Default value:__:  `[null, null]` indicating that the window includes all objects."
            case .keyvals: return "Defines the key values that should be considered for imputation. An array of key values or an object defining a [number sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).\n\nIf provided, this will be used in addition to the key values observed within the input data. If not provided, the values will be derived from all unique values of the `key` field. For `impute` in `encoding`, the key field is the x-field if the y-field is imputed, or vice versa.\n\nIf there is no impute grouping, this property _must_ be specified."
            case .method: return "The imputation method to use for the field value of imputed data objects. One of `\"value\"`, `\"mean\"`, `\"median\"`, `\"max\"` or `\"min\"`.\n\n__Default value:__  `\"value\"`"
            case .value: return "The field value to use when the imputation `method` is `\"value\"`."
             } 
        }

        public typealias CodingOwner = ImputeParams
    }
}

/// Generated by Curio
public struct ImputeSequence : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The starting value of the sequence. __Default value:__ `0`
    public var start: Double?
    /// The step value between sequence entries. __Default value:__ `1` or `-1` if `stop < start`
    public var step: Double?
    /// The ending value(exclusive) of the sequence.
    public var stop: Double
    public static let codingKeyPaths = (\Self.start as KeyPath, \Self.step as KeyPath, \Self.stop as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.start as KeyPath : CodingKeys.start, \Self.step as KeyPath : CodingKeys.step, \Self.stop as KeyPath : CodingKeys.stop]

    public init(start: Double? = nil, step: Double? = nil, stop: Double) {
        self.start = start 
        self.step = step 
        self.stop = stop 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.start = try values.decodeOptional(Double.self, forKey: .start) 
        self.step = try values.decodeOptional(Double.self, forKey: .step) 
        self.stop = try values.decode(Double.self, forKey: .stop) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case start
        case step
        case stop
        public var keyDescription: String? {
            switch self {
            case .start: return "The starting value of the sequence. __Default value:__ `0`"
            case .step: return "The step value between sequence entries. __Default value:__ `1` or `-1` if `stop < start`"
            case .stop: return "The ending value(exclusive) of the sequence."
             } 
        }

        public typealias CodingOwner = ImputeSequence
    }
}

/// Generated by Curio
public struct ImputeTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// A frame specification as a two-element array used to control the window over which the specified method is applied. The array entries should either be a number indicating the offset from the current data object, or null to indicate unbounded rows preceding or following the current data object. For example, the value `[-5, 5]` indicates that the window should include five objects preceding and five objects following the current object.
    /// __Default value:__:  `[null, null]` indicating that the window includes all objects.
    public var frame: [FrameItemChoice]?
    /// An optional array of fields by which to group the values. Imputation will then be performed on a per-group basis.
    public var groupby: [FieldName]?
    /// The data field for which the missing values should be imputed.
    public var impute: FieldName
    /// A key field that uniquely identifies data objects within a group. Missing key values (those occurring in the data but not in the current group) will be imputed.
    public var key: FieldName
    /// Defines the key values that should be considered for imputation. An array of key values or an object defining a [number sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
    /// If provided, this will be used in addition to the key values observed within the input data. If not provided, the values will be derived from all unique values of the `key` field. For `impute` in `encoding`, the key field is the x-field if the y-field is imputed, or vice versa.
    /// If there is no impute grouping, this property _must_ be specified.
    public var keyvals: KeyvalsChoice?
    /// The imputation method to use for the field value of imputed data objects. One of `"value"`, `"mean"`, `"median"`, `"max"` or `"min"`.
    /// __Default value:__  `"value"`
    public var method: ImputeMethod?
    /// The field value to use when the imputation `method` is `"value"`.
    public var value: Value?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.frame as KeyPath, \Self.groupby as KeyPath, \Self.impute as KeyPath, \Self.key as KeyPath, \Self.keyvals as KeyPath, \Self.method as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.frame as KeyPath : CodingKeys.frame, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.impute as KeyPath : CodingKeys.impute, \Self.key as KeyPath : CodingKeys.key, \Self.keyvals as KeyPath : CodingKeys.keyvals, \Self.method as KeyPath : CodingKeys.method, \Self.value as KeyPath : CodingKeys.value]

    public init(id: TransformId? = nil, frame: [FrameItemChoice]? = nil, groupby: [FieldName]? = nil, impute: FieldName, key: FieldName, keyvals: KeyvalsChoice? = nil, method: ImputeMethod? = nil, value: Value? = nil) {
        self.id = id 
        self.frame = frame 
        self.groupby = groupby 
        self.impute = impute 
        self.key = key 
        self.keyvals = keyvals 
        self.method = method 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.frame = try values.decodeOptional([FrameItemChoice].self, forKey: .frame) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
        self.impute = try values.decode(FieldName.self, forKey: .impute) 
        self.key = try values.decode(FieldName.self, forKey: .key) 
        self.keyvals = try values.decodeOptional(KeyvalsChoice.self, forKey: .keyvals) 
        self.method = try values.decodeOptional(ImputeMethod.self, forKey: .method) 
        self.value = try values.decodeOptional(Value.self, forKey: .value) 
    }

    /// Generated by Curio
    public typealias FrameItemChoice = Nullable<Double>

    /// Defines the key values that should be considered for imputation. An array of key values or an object defining a [number sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
    /// If provided, this will be used in addition to the key values observed within the input data. If not provided, the values will be derived from all unique values of the `key` field. For `impute` in `encoding`, the key field is the x-field if the y-field is imputed, or vice versa.
    /// If there is no impute grouping, this property _must_ be specified.
    /// Generated by Curio
    public typealias KeyvalsChoice = OneOf<[Bric]>.Or<ImputeSequence>

    public typealias Value = Bric

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case frame
        case groupby
        case impute
        case key
        case keyvals
        case method
        case value
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .frame: return "A frame specification as a two-element array used to control the window over which the specified method is applied. The array entries should either be a number indicating the offset from the current data object, or null to indicate unbounded rows preceding or following the current data object. For example, the value `[-5, 5]` indicates that the window should include five objects preceding and five objects following the current object.\n\n__Default value:__:  `[null, null]` indicating that the window includes all objects."
            case .groupby: return "An optional array of fields by which to group the values. Imputation will then be performed on a per-group basis."
            case .impute: return "The data field for which the missing values should be imputed."
            case .key: return "A key field that uniquely identifies data objects within a group. Missing key values (those occurring in the data but not in the current group) will be imputed."
            case .keyvals: return "Defines the key values that should be considered for imputation. An array of key values or an object defining a [number sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).\n\nIf provided, this will be used in addition to the key values observed within the input data. If not provided, the values will be derived from all unique values of the `key` field. For `impute` in `encoding`, the key field is the x-field if the y-field is imputed, or vice versa.\n\nIf there is no impute grouping, this property _must_ be specified."
            case .method: return "The imputation method to use for the field value of imputed data objects. One of `\"value\"`, `\"mean\"`, `\"median\"`, `\"max\"` or `\"min\"`.\n\n__Default value:__  `\"value\"`"
            case .value: return "The field value to use when the imputation `method` is `\"value\"`."
             } 
        }

        public typealias CodingOwner = ImputeTransform
    }
}

/// Generated by Curio
public struct InlineData : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// An object that specifies the format for parsing the data.
    public var format: DataFormat?
    /// Provide a placeholder name and bind data at runtime.
    public var name: String?
    /// The full data set, included inline. This can be an array of objects or primitive values, an object, or a string. Arrays of primitive values are ingested as objects with a `data` property. Strings are parsed according to the specified format type.
    public var values: InlineDataset
    public static let codingKeyPaths = (\Self.format as KeyPath, \Self.name as KeyPath, \Self.values as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.format as KeyPath : CodingKeys.format, \Self.name as KeyPath : CodingKeys.name, \Self.values as KeyPath : CodingKeys.values]

    public init(format: DataFormat? = nil, name: String? = nil, values: InlineDataset) {
        self.format = format 
        self.name = name 
        self.values = values 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.format = try values.decodeOptional(DataFormat.self, forKey: .format) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.values = try values.decode(InlineDataset.self, forKey: .values) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case format
        case name
        case values
        public var keyDescription: String? {
            switch self {
            case .format: return "An object that specifies the format for parsing the data."
            case .name: return "Provide a placeholder name and bind data at runtime."
            case .values: return "The full data set, included inline. This can be an array of objects or primitive values, an object, or a string. Arrays of primitive values are ingested as objects with a `data` property. Strings are parsed according to the specified format type."
             } 
        }

        public typealias CodingOwner = InlineData
    }
}

public struct InlineDataset : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[Bric]>.Or<String>.Or<Bric>

    public init(rawValue: OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[Bric]>.Or<String>.Or<Bric>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[Bric]>.Or<String>.Or<Bric>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct IntervalSelectionConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
    /// __Default value:__ `dblclick`.
    /// __See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
    public var clear: ClearChoice?
    /// An array of encoding channels. The corresponding data field values must match for a data tuple to fall within the selection.
    /// __See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation.
    public var encodings: [SingleDefUnitChannel]?
    /// An array of field names whose values must match for a data tuple to fall within the selection.
    /// __See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation.
    public var fields: [FieldName]?
    /// An interval selection also adds a rectangle mark to depict the extents of the interval. The `mark` property can be used to customize the appearance of the mark.
    /// __See also:__ [`mark` examples](https://vega.github.io/vega-lite/docs/selection.html#mark) in the documentation.
    public var mark: BrushConfig?
    /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
    /// __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation.
    public var on: OnChoice?
    /// With layered and multi-view displays, a strategy that determines how selections' data queries are resolved when applied in a filter transform, conditional encoding rule, or scale domain.
    /// One of:
    /// - `"global"` -- only one brush exists for the entire SPLOM. When the user begins to drag, any previous brushes are cleared, and a new one is constructed.
    /// - `"union"` -- each cell contains its own brush, and points are highlighted if they lie within _any_ of these individual brushes.
    /// - `"intersect"` -- each cell contains its own brush, and points are highlighted only if they fall within _all_ of these individual brushes.
    /// __Default value:__ `global`.
    /// __See also:__ [`resolve` examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the documentation.
    public var resolve: SelectionResolution?
    /// When truthy, allows a user to interactively move an interval selection back-and-forth. Can be `true`, `false` (to disable panning), or a [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/) which must include a start and end event to trigger continuous panning. Discrete panning (e.g., pressing the left/right arrow keys) will be supported in future versions.
    /// __Default value:__ `true`, which corresponds to `[mousedown, window:mouseup] > window:mousemove!`. This default allows users to clicks and drags within an interval selection to reposition it.
    /// __See also:__ [`translate` examples](https://vega.github.io/vega-lite/docs/selection.html#translate) in the documentation.
    public var translate: Translate?
    /// Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:
    /// - `"point"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.
    /// - `"interval"` -- to select a continuous range of data values on `drag`.
    public var type: LiteralInterval
    /// When truthy, allows a user to interactively resize an interval selection. Can be `true`, `false` (to disable zooming), or a [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/). Currently, only `wheel` events are supported, but custom event streams can still be used to specify filters, debouncing, and throttling. Future versions will expand the set of events that can trigger this transformation.
    /// __Default value:__ `true`, which corresponds to `wheel!`. This default allows users to use the mouse wheel to resize an interval selection.
    /// __See also:__ [`zoom` examples](https://vega.github.io/vega-lite/docs/selection.html#zoom) in the documentation.
    public var zoom: Zoom?
    public static let codingKeyPaths = (\Self.clear as KeyPath, \Self.encodings as KeyPath, \Self.fields as KeyPath, \Self.mark as KeyPath, \Self.on as KeyPath, \Self.resolve as KeyPath, \Self.translate as KeyPath, \Self.type as KeyPath, \Self.zoom as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.clear as KeyPath : CodingKeys.clear, \Self.encodings as KeyPath : CodingKeys.encodings, \Self.fields as KeyPath : CodingKeys.fields, \Self.mark as KeyPath : CodingKeys.mark, \Self.on as KeyPath : CodingKeys.on, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.translate as KeyPath : CodingKeys.translate, \Self.type as KeyPath : CodingKeys.type, \Self.zoom as KeyPath : CodingKeys.zoom]

    public init(clear: ClearChoice? = nil, encodings: [SingleDefUnitChannel]? = nil, fields: [FieldName]? = nil, mark: BrushConfig? = nil, on: OnChoice? = nil, resolve: SelectionResolution? = nil, translate: Translate? = nil, type: LiteralInterval = .interval, zoom: Zoom? = nil) {
        self.clear = clear 
        self.encodings = encodings 
        self.fields = fields 
        self.mark = mark 
        self.on = on 
        self.resolve = resolve 
        self.translate = translate 
        self.type = type 
        self.zoom = zoom 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.clear = try values.decodeOptional(ClearChoice.self, forKey: .clear) 
        self.encodings = try values.decodeOptional([SingleDefUnitChannel].self, forKey: .encodings) 
        self.fields = try values.decodeOptional([FieldName].self, forKey: .fields) 
        self.mark = try values.decodeOptional(BrushConfig.self, forKey: .mark) 
        self.on = try values.decodeOptional(OnChoice.self, forKey: .on) 
        self.resolve = try values.decodeOptional(SelectionResolution.self, forKey: .resolve) 
        self.translate = try values.decodeOptional(Translate.self, forKey: .translate) 
        self.type = try values.decode(LiteralInterval.self, forKey: .type) 
        self.zoom = try values.decodeOptional(Zoom.self, forKey: .zoom) 
    }

    /// Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
    /// __Default value:__ `dblclick`.
    /// __See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
    /// Generated by Curio
    public typealias ClearChoice = OneOf<Stream>.Or<String>.Or<Bool>

    /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
    /// __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation.
    /// Generated by Curio
    public typealias OnChoice = OneOf<Stream>.Or<String>

    /// Generated by Curio
    public typealias Translate = OneOf<String>.Or<Bool>

    /// Generated by Curio
    public typealias Zoom = OneOf<String>.Or<Bool>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case clear
        case encodings
        case fields
        case mark
        case on
        case resolve
        case translate
        case type
        case zoom
        public var keyDescription: String? {
            switch self {
            case .clear: return "Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.\n\n__Default value:__ `dblclick`.\n\n__See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation."
            case .encodings: return "An array of encoding channels. The corresponding data field values must match for a data tuple to fall within the selection.\n\n__See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation."
            case .fields: return "An array of field names whose values must match for a data tuple to fall within the selection.\n\n__See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation."
            case .mark: return "An interval selection also adds a rectangle mark to depict the extents of the interval. The `mark` property can be used to customize the appearance of the mark.\n\n__See also:__ [`mark` examples](https://vega.github.io/vega-lite/docs/selection.html#mark) in the documentation."
            case .on: return "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).\n\n__See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation."
            case .resolve: return "With layered and multi-view displays, a strategy that determines how selections' data queries are resolved when applied in a filter transform, conditional encoding rule, or scale domain.\n\nOne of:\n- `\"global\"` -- only one brush exists for the entire SPLOM. When the user begins to drag, any previous brushes are cleared, and a new one is constructed.\n- `\"union\"` -- each cell contains its own brush, and points are highlighted if they lie within _any_ of these individual brushes.\n- `\"intersect\"` -- each cell contains its own brush, and points are highlighted only if they fall within _all_ of these individual brushes.\n\n__Default value:__ `global`.\n\n__See also:__ [`resolve` examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the documentation."
            case .translate: return "When truthy, allows a user to interactively move an interval selection back-and-forth. Can be `true`, `false` (to disable panning), or a [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/) which must include a start and end event to trigger continuous panning. Discrete panning (e.g., pressing the left/right arrow keys) will be supported in future versions.\n\n__Default value:__ `true`, which corresponds to `[mousedown, window:mouseup] > window:mousemove!`. This default allows users to clicks and drags within an interval selection to reposition it.\n\n__See also:__ [`translate` examples](https://vega.github.io/vega-lite/docs/selection.html#translate) in the documentation."
            case .type: return "Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:\n\n- `\"point\"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.\n- `\"interval\"` -- to select a continuous range of data values on `drag`."
            case .zoom: return "When truthy, allows a user to interactively resize an interval selection. Can be `true`, `false` (to disable zooming), or a [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/). Currently, only `wheel` events are supported, but custom event streams can still be used to specify filters, debouncing, and throttling. Future versions will expand the set of events that can trigger this transformation.\n\n__Default value:__ `true`, which corresponds to `wheel!`. This default allows users to use the mouse wheel to resize an interval selection.\n\n__See also:__ [`zoom` examples](https://vega.github.io/vega-lite/docs/selection.html#zoom) in the documentation."
             } 
        }

        public typealias CodingOwner = IntervalSelectionConfig
    }

    /// Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:
    /// - `"point"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.
    /// - `"interval"` -- to select a continuous range of data values on `drag`.
    /// Generated by Curio
    public enum LiteralInterval : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case interval
    }
}

/// Generated by Curio
public struct IntervalSelectionConfigWithoutType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
    /// __Default value:__ `dblclick`.
    /// __See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
    public var clear: ClearChoice?
    /// An array of encoding channels. The corresponding data field values must match for a data tuple to fall within the selection.
    /// __See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation.
    public var encodings: [SingleDefUnitChannel]?
    /// An array of field names whose values must match for a data tuple to fall within the selection.
    /// __See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation.
    public var fields: [FieldName]?
    /// An interval selection also adds a rectangle mark to depict the extents of the interval. The `mark` property can be used to customize the appearance of the mark.
    /// __See also:__ [`mark` examples](https://vega.github.io/vega-lite/docs/selection.html#mark) in the documentation.
    public var mark: BrushConfig?
    /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
    /// __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation.
    public var on: OnChoice?
    /// With layered and multi-view displays, a strategy that determines how selections' data queries are resolved when applied in a filter transform, conditional encoding rule, or scale domain.
    /// One of:
    /// - `"global"` -- only one brush exists for the entire SPLOM. When the user begins to drag, any previous brushes are cleared, and a new one is constructed.
    /// - `"union"` -- each cell contains its own brush, and points are highlighted if they lie within _any_ of these individual brushes.
    /// - `"intersect"` -- each cell contains its own brush, and points are highlighted only if they fall within _all_ of these individual brushes.
    /// __Default value:__ `global`.
    /// __See also:__ [`resolve` examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the documentation.
    public var resolve: SelectionResolution?
    /// When truthy, allows a user to interactively move an interval selection back-and-forth. Can be `true`, `false` (to disable panning), or a [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/) which must include a start and end event to trigger continuous panning. Discrete panning (e.g., pressing the left/right arrow keys) will be supported in future versions.
    /// __Default value:__ `true`, which corresponds to `[mousedown, window:mouseup] > window:mousemove!`. This default allows users to clicks and drags within an interval selection to reposition it.
    /// __See also:__ [`translate` examples](https://vega.github.io/vega-lite/docs/selection.html#translate) in the documentation.
    public var translate: Translate?
    /// When truthy, allows a user to interactively resize an interval selection. Can be `true`, `false` (to disable zooming), or a [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/). Currently, only `wheel` events are supported, but custom event streams can still be used to specify filters, debouncing, and throttling. Future versions will expand the set of events that can trigger this transformation.
    /// __Default value:__ `true`, which corresponds to `wheel!`. This default allows users to use the mouse wheel to resize an interval selection.
    /// __See also:__ [`zoom` examples](https://vega.github.io/vega-lite/docs/selection.html#zoom) in the documentation.
    public var zoom: Zoom?
    public static let codingKeyPaths = (\Self.clear as KeyPath, \Self.encodings as KeyPath, \Self.fields as KeyPath, \Self.mark as KeyPath, \Self.on as KeyPath, \Self.resolve as KeyPath, \Self.translate as KeyPath, \Self.zoom as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.clear as KeyPath : CodingKeys.clear, \Self.encodings as KeyPath : CodingKeys.encodings, \Self.fields as KeyPath : CodingKeys.fields, \Self.mark as KeyPath : CodingKeys.mark, \Self.on as KeyPath : CodingKeys.on, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.translate as KeyPath : CodingKeys.translate, \Self.zoom as KeyPath : CodingKeys.zoom]

    public init(clear: ClearChoice? = nil, encodings: [SingleDefUnitChannel]? = nil, fields: [FieldName]? = nil, mark: BrushConfig? = nil, on: OnChoice? = nil, resolve: SelectionResolution? = nil, translate: Translate? = nil, zoom: Zoom? = nil) {
        self.clear = clear 
        self.encodings = encodings 
        self.fields = fields 
        self.mark = mark 
        self.on = on 
        self.resolve = resolve 
        self.translate = translate 
        self.zoom = zoom 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.clear = try values.decodeOptional(ClearChoice.self, forKey: .clear) 
        self.encodings = try values.decodeOptional([SingleDefUnitChannel].self, forKey: .encodings) 
        self.fields = try values.decodeOptional([FieldName].self, forKey: .fields) 
        self.mark = try values.decodeOptional(BrushConfig.self, forKey: .mark) 
        self.on = try values.decodeOptional(OnChoice.self, forKey: .on) 
        self.resolve = try values.decodeOptional(SelectionResolution.self, forKey: .resolve) 
        self.translate = try values.decodeOptional(Translate.self, forKey: .translate) 
        self.zoom = try values.decodeOptional(Zoom.self, forKey: .zoom) 
    }

    /// Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
    /// __Default value:__ `dblclick`.
    /// __See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
    /// Generated by Curio
    public typealias ClearChoice = OneOf<Stream>.Or<String>.Or<Bool>

    /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
    /// __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation.
    /// Generated by Curio
    public typealias OnChoice = OneOf<Stream>.Or<String>

    /// Generated by Curio
    public typealias Translate = OneOf<String>.Or<Bool>

    /// Generated by Curio
    public typealias Zoom = OneOf<String>.Or<Bool>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case clear
        case encodings
        case fields
        case mark
        case on
        case resolve
        case translate
        case zoom
        public var keyDescription: String? {
            switch self {
            case .clear: return "Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.\n\n__Default value:__ `dblclick`.\n\n__See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation."
            case .encodings: return "An array of encoding channels. The corresponding data field values must match for a data tuple to fall within the selection.\n\n__See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation."
            case .fields: return "An array of field names whose values must match for a data tuple to fall within the selection.\n\n__See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation."
            case .mark: return "An interval selection also adds a rectangle mark to depict the extents of the interval. The `mark` property can be used to customize the appearance of the mark.\n\n__See also:__ [`mark` examples](https://vega.github.io/vega-lite/docs/selection.html#mark) in the documentation."
            case .on: return "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).\n\n__See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation."
            case .resolve: return "With layered and multi-view displays, a strategy that determines how selections' data queries are resolved when applied in a filter transform, conditional encoding rule, or scale domain.\n\nOne of:\n- `\"global\"` -- only one brush exists for the entire SPLOM. When the user begins to drag, any previous brushes are cleared, and a new one is constructed.\n- `\"union\"` -- each cell contains its own brush, and points are highlighted if they lie within _any_ of these individual brushes.\n- `\"intersect\"` -- each cell contains its own brush, and points are highlighted only if they fall within _all_ of these individual brushes.\n\n__Default value:__ `global`.\n\n__See also:__ [`resolve` examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the documentation."
            case .translate: return "When truthy, allows a user to interactively move an interval selection back-and-forth. Can be `true`, `false` (to disable panning), or a [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/) which must include a start and end event to trigger continuous panning. Discrete panning (e.g., pressing the left/right arrow keys) will be supported in future versions.\n\n__Default value:__ `true`, which corresponds to `[mousedown, window:mouseup] > window:mousemove!`. This default allows users to clicks and drags within an interval selection to reposition it.\n\n__See also:__ [`translate` examples](https://vega.github.io/vega-lite/docs/selection.html#translate) in the documentation."
            case .zoom: return "When truthy, allows a user to interactively resize an interval selection. Can be `true`, `false` (to disable zooming), or a [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/). Currently, only `wheel` events are supported, but custom event streams can still be used to specify filters, debouncing, and throttling. Future versions will expand the set of events that can trigger this transformation.\n\n__Default value:__ `true`, which corresponds to `wheel!`. This default allows users to use the mouse wheel to resize an interval selection.\n\n__See also:__ [`zoom` examples](https://vega.github.io/vega-lite/docs/selection.html#zoom) in the documentation."
             } 
        }

        public typealias CodingOwner = IntervalSelectionConfigWithoutType
    }
}

/// Generated by Curio
public struct JoinAggregateFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The output name for the join aggregate operation.
    public var `as`: FieldName
    /// The data field for which to compute the aggregate function. This can be omitted for functions that do not operate over a field such as `"count"`.
    public var field: FieldName?
    /// The aggregation operation to apply (e.g., `"sum"`, `"average"` or `"count"`). See the list of all supported operations [here](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
    public var op: AggregateOp
    public static let codingKeyPaths = (\Self.`as` as KeyPath, \Self.field as KeyPath, \Self.op as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.`as` as KeyPath : CodingKeys.`as`, \Self.field as KeyPath : CodingKeys.field, \Self.op as KeyPath : CodingKeys.op]

    public init(`as`: FieldName, field: FieldName? = nil, op: AggregateOp) {
        self.`as` = `as` 
        self.field = field 
        self.op = op 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.`as` = try values.decode(FieldName.self, forKey: .`as`) 
        self.field = try values.decodeOptional(FieldName.self, forKey: .field) 
        self.op = try values.decode(AggregateOp.self, forKey: .op) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case `as`
        case field
        case op
        public var keyDescription: String? {
            switch self {
            case .`as`: return "The output name for the join aggregate operation."
            case .field: return "The data field for which to compute the aggregate function. This can be omitted for functions that do not operate over a field such as `\"count\"`."
            case .op: return "The aggregation operation to apply (e.g., `\"sum\"`, `\"average\"` or `\"count\"`). See the list of all supported operations [here](https://vega.github.io/vega-lite/docs/aggregate.html#ops)."
             } 
        }

        public typealias CodingOwner = JoinAggregateFieldDef
    }
}

/// Generated by Curio
public struct JoinAggregateTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The data fields for partitioning the data objects into separate groups. If unspecified, all data points will be in a single group.
    public var groupby: [FieldName]?
    /// The definition of the fields in the join aggregate, and what calculations to use.
    public var joinaggregate: [JoinAggregateFieldDef]
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.groupby as KeyPath, \Self.joinaggregate as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.joinaggregate as KeyPath : CodingKeys.joinaggregate]

    public init(id: TransformId? = nil, groupby: [FieldName]? = nil, joinaggregate: [JoinAggregateFieldDef] = []) {
        self.id = id 
        self.groupby = groupby 
        self.joinaggregate = joinaggregate 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
        self.joinaggregate = try values.decode([JoinAggregateFieldDef].self, forKey: .joinaggregate) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case groupby
        case joinaggregate
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .groupby: return "The data fields for partitioning the data objects into separate groups. If unspecified, all data points will be in a single group."
            case .joinaggregate: return "The definition of the fields in the join aggregate, and what calculations to use."
             } 
        }

        public typealias CodingOwner = JoinAggregateTransform
    }
}

/// Generated by Curio
public struct JsonDataFormat : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
    /// For `"date"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
    public var parse: ParseChoice?
    /// The JSON property containing the desired data. This parameter can be used when the loaded JSON file may have surrounding structure or meta-data. For example `"property": "values.features"` is equivalent to retrieving `json.values.features` from the loaded JSON object.
    public var property: String?
    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// __Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `"json"` will be used by default.
    public var type: LiteralJson?
    public static let codingKeyPaths = (\Self.parse as KeyPath, \Self.property as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.parse as KeyPath : CodingKeys.parse, \Self.property as KeyPath : CodingKeys.property, \Self.type as KeyPath : CodingKeys.type]

    public init(parse: ParseChoice? = nil, property: String? = nil, type: LiteralJson? = nil) {
        self.parse = parse 
        self.property = property 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.parse = try values.decodeOptional(ParseChoice.self, forKey: .parse) 
        self.property = try values.decodeOptional(String.self, forKey: .property) 
        self.type = try values.decodeOptional(LiteralJson.self, forKey: .type) 
    }

    /// If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
    /// For `"date"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
    /// Generated by Curio
    public typealias ParseChoice = Nullable<Parse>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case parse
        case property
        case type
        public var keyDescription: String? {
            switch self {
            case .parse: return "If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"`, `\"date\"`, or null (do not parse the field)). For example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n\nFor `\"date\"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: \"date:'%m%d%Y'\"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: \"utc:'%m%d%Y'\"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)"
            case .property: return "The JSON property containing the desired data. This parameter can be used when the loaded JSON file may have surrounding structure or meta-data. For example `\"property\": \"values.features\"` is equivalent to retrieving `json.values.features` from the loaded JSON object."
            case .type: return "Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n\n__Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `\"json\"` will be used by default."
             } 
        }

        public typealias CodingOwner = JsonDataFormat
    }

    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// __Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `"json"` will be used by default.
    /// Generated by Curio
    public enum LiteralJson : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case json
    }
}

public struct LabelOverlap : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Bool>.Or<LiteralParity>.Or<LiteralGreedy>

    public init(rawValue: OneOf<Bool>.Or<LiteralParity>.Or<LiteralGreedy>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Bool>.Or<LiteralParity>.Or<LiteralGreedy>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public enum LiteralGreedy : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case greedy
    }

    /// Generated by Curio
    public enum LiteralParity : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case parity
    }
}

public struct LatLongDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<LatLongFieldDef>.Or<DatumDef>

    public init(rawValue: OneOf<LatLongFieldDef>.Or<DatumDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<LatLongFieldDef>.Or<DatumDef>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct LatLongFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: ExplicitNull?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: LiteralQuantitative?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: LiteralQuantitative? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(LiteralQuantitative.self, forKey: .type) 
    }

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case field
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = LatLongFieldDef
    }
}

public struct LayerId : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: UUID

    public init(rawValue: UUID) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: UUID) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct LayerRepeatMapping : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// An array of fields to be repeated horizontally.
    public var column: [FieldName]?
    /// An array of fields to be repeated as layers.
    public var layer: [FieldName]
    /// An array of fields to be repeated vertically.
    public var row: [FieldName]?
    public static let codingKeyPaths = (\Self.column as KeyPath, \Self.layer as KeyPath, \Self.row as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.column as KeyPath : CodingKeys.column, \Self.layer as KeyPath : CodingKeys.layer, \Self.row as KeyPath : CodingKeys.row]

    public init(column: [FieldName]? = nil, layer: [FieldName], row: [FieldName]? = nil) {
        self.column = column 
        self.layer = layer 
        self.row = row 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.column = try values.decodeOptional([FieldName].self, forKey: .column) 
        self.layer = try values.decode([FieldName].self, forKey: .layer) 
        self.row = try values.decodeOptional([FieldName].self, forKey: .row) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case column
        case layer
        case row
        public var keyDescription: String? {
            switch self {
            case .column: return "An array of fields to be repeated horizontally."
            case .layer: return "An array of fields to be repeated as layers."
            case .row: return "An array of fields to be repeated vertically."
             } 
        }

        public typealias CodingOwner = LayerRepeatMapping
    }
}

/// Generated by Curio
public struct LayerRepeatSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// The number of columns to include in the view composition layout.
    /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
    /// __Note__:
    /// 1) This property is only for:
    /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
    /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
    /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
    public var columns: Double?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// Name of the visualization for later reference.
    public var name: String?
    /// Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed fields to be repeated along the particular orientations. The objects `{"repeat": "row"}` and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
    public var `repeat`: LayerRepeatMapping
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// A specification of the view that gets repeated.
    public var spec: SpecChoice
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.align as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.data as KeyPath, \Self.description as KeyPath, \Self.name as KeyPath, \Self.`repeat` as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.spec as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.align as KeyPath : CodingKeys.align, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.name as KeyPath : CodingKeys.name, \Self.`repeat` as KeyPath : CodingKeys.`repeat`, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.spec as KeyPath : CodingKeys.spec, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform]

    public init(id: LayerId? = nil, align: AlignChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, data: DataChoice? = nil, description: String? = nil, name: String? = nil, `repeat`: LayerRepeatMapping, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, spec: SpecChoice, title: TitleChoice? = nil, transform: [DataTransformation]? = nil) {
        self.id = id 
        self.align = align 
        self.bounds = bounds 
        self.center = center 
        self.columns = columns 
        self.data = data 
        self.description = description 
        self.name = name 
        self.`repeat` = `repeat` 
        self.resolve = resolve 
        self.spacing = spacing 
        self.spec = spec 
        self.title = title 
        self.transform = transform 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.`repeat` = try values.decode(LayerRepeatMapping.self, forKey: .`repeat`) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.spec = try values.decode(SpecChoice.self, forKey: .spec) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// A specification of the view that gets repeated.
    /// Generated by Curio
    public typealias SpecChoice = OneOf<LayerSpec>.Or<UnitSpec>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case align
        case bounds
        case center
        case columns
        case data
        case description
        case name
        case `repeat`
        case resolve
        case spacing
        case spec
        case title
        case transform
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .name: return "Name of the visualization for later reference."
            case .`repeat`: return "Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `\"repeat\"` is an array, the field can be referred to as `{\"repeat\": \"repeat\"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `\"row\"` and/or `\"column\"` to the listed fields to be repeated along the particular orientations. The objects `{\"repeat\": \"row\"}` and `{\"repeat\": \"column\"}` can be used to refer to the repeated field respectively."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .spec: return "A specification of the view that gets repeated."
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
             } 
        }

        public typealias CodingOwner = LayerRepeatSpec
    }
}

/// A full layered plot specification, which may contains `encoding` and `projection` properties that will be applied to underlying unit (single-view) specifications.
/// Generated by Curio
public struct LayerSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// A shared key-value mapping between encoding channels and definition of fields in the underlying layers.
    public var encoding: SharedEncoding?
    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var height: HeightChoice?
    /// Layer or single view specifications to be layered.
    /// __Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed. Instead, use the [facet operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a facet.
    public var layer: [LayerItemChoice]
    /// Name of the visualization for later reference.
    public var name: String?
    /// An object defining properties of the geographic projection shared by underlying layers.
    public var projection: Projection?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// An object defining the view background's fill and stroke.
    /// __Default value:__ none (transparent)
    public var view: ViewBackground?
    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var width: WidthChoice?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.data as KeyPath, \Self.description as KeyPath, \Self.encoding as KeyPath, \Self.height as KeyPath, \Self.layer as KeyPath, \Self.name as KeyPath, \Self.projection as KeyPath, \Self.resolve as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.view as KeyPath, \Self.width as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.encoding as KeyPath : CodingKeys.encoding, \Self.height as KeyPath : CodingKeys.height, \Self.layer as KeyPath : CodingKeys.layer, \Self.name as KeyPath : CodingKeys.name, \Self.projection as KeyPath : CodingKeys.projection, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.view as KeyPath : CodingKeys.view, \Self.width as KeyPath : CodingKeys.width]

    public init(id: LayerId? = nil, data: DataChoice? = nil, description: String? = nil, encoding: SharedEncoding? = nil, height: HeightChoice? = nil, layer: [LayerItemChoice] = [], name: String? = nil, projection: Projection? = nil, resolve: Resolve? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, view: ViewBackground? = nil, width: WidthChoice? = nil) {
        self.id = id 
        self.data = data 
        self.description = description 
        self.encoding = encoding 
        self.height = height 
        self.layer = layer 
        self.name = name 
        self.projection = projection 
        self.resolve = resolve 
        self.title = title 
        self.transform = transform 
        self.view = view 
        self.width = width 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.encoding = try values.decodeOptional(SharedEncoding.self, forKey: .encoding) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.layer = try values.decode([LayerItemChoice].self, forKey: .layer) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.projection = try values.decodeOptional(Projection.self, forKey: .projection) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.view = try values.decodeOptional(ViewBackground.self, forKey: .view) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
    }

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    /// Generated by Curio
    public typealias LayerItemChoice = OneOf<LayerSpec>.Or<UnitSpec>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case data
        case description
        case encoding
        case height
        case layer
        case name
        case projection
        case resolve
        case title
        case transform
        case view
        case width
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .encoding: return "A shared key-value mapping between encoding channels and definition of fields in the underlying layers."
            case .height: return "The height of a visualization.\n\n- For a plot with a continuous y-field, height should be a number.\n- For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)\n- To enable responsive sizing on height, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation."
            case .layer: return "Layer or single view specifications to be layered.\n\n__Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed. Instead, use the [facet operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a facet."
            case .name: return "Name of the visualization for later reference."
            case .projection: return "An object defining properties of the geographic projection shared by underlying layers."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .view: return "An object defining the view background's fill and stroke.\n\n__Default value:__ none (transparent)"
            case .width: return "The width of a visualization.\n\n- For a plot with a continuous x-field, width should be a number.\n- For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)\n- To enable responsive sizing on width, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation."
             } 
        }

        public typealias CodingOwner = LayerSpec
    }
}

public struct LegendBinding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<LiteralLegend>.Or<LegendStreamBinding>

    public init(rawValue: OneOf<LiteralLegend>.Or<LegendStreamBinding>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<LiteralLegend>.Or<LegendStreamBinding>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public enum LiteralLegend : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case legend
    }
}

/// Generated by Curio
public struct LegendConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var aria: AriaChoice?
    public var clipHeight: ClipHeightChoice?
    public var columnPadding: ColumnPaddingChoice?
    public var columns: ColumnsChoice?
    public var cornerRadius: CornerRadiusChoice?
    public var description: DescriptionChoice?
    /// The direction of the legend, one of `"vertical"` or `"horizontal"`.
    /// __Default value:__
    /// - For top-/bottom-`orient`ed legends, `"horizontal"`
    /// - For left-/right-`orient`ed legends, `"vertical"`
    /// - For top/bottom-left/right-`orient`ed legends, `"horizontal"` for gradient legends and `"vertical"` for symbol legends.
    public var direction: Orientation?
    /// Disable legend by default
    public var disable: Bool?
    public var fillColor: FillColorChoice?
    public var gradientDirection: GradientDirectionChoice?
    /// Max legend length for a horizontal gradient when `config.legend.gradientLength` is undefined.
    /// __Default value:__ `200`
    public var gradientHorizontalMaxLength: Double?
    /// Min legend length for a horizontal gradient when `config.legend.gradientLength` is undefined.
    /// __Default value:__ `100`
    public var gradientHorizontalMinLength: Double?
    public var gradientLabelLimit: GradientLabelLimitChoice?
    public var gradientLabelOffset: GradientLabelOffsetChoice?
    public var gradientLength: GradientLengthChoice?
    public var gradientOpacity: GradientOpacityChoice?
    public var gradientStrokeColor: GradientStrokeColorChoice?
    public var gradientStrokeWidth: GradientStrokeWidthChoice?
    public var gradientThickness: GradientThicknessChoice?
    /// Max legend length for a vertical gradient when `config.legend.gradientLength` is undefined.
    /// __Default value:__ `200`
    public var gradientVerticalMaxLength: Double?
    /// Min legend length for a vertical gradient when `config.legend.gradientLength` is undefined.
    /// __Default value:__ `100`
    public var gradientVerticalMinLength: Double?
    public var gridAlign: GridAlignChoice?
    public var labelAlign: LabelAlignChoice?
    public var labelBaseline: LabelBaselineChoice?
    public var labelColor: LabelColorChoice?
    public var labelFont: FontName?
    public var labelFontSize: LabelFontSizeChoice?
    public var labelFontStyle: LabelFontStyleChoice?
    public var labelFontWeight: LabelFontWeightChoice?
    public var labelLimit: LabelLimitChoice?
    public var labelOffset: LabelOffsetChoice?
    public var labelOpacity: LabelOpacityChoice?
    /// The strategy to use for resolving overlap of labels in gradient legends. If `false`, no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used. If set to `"greedy"`, a linear scan of the labels is performed, removing any label that overlaps with the last visible label (this often works better for log-scaled axes).
    /// __Default value:__ `"greedy"` for `log scales otherwise `true`.
    public var labelOverlap: LabelOverlapChoice?
    public var labelPadding: LabelPaddingChoice?
    public var labelSeparation: LabelSeparationChoice?
    public var layout: ExprRef?
    public var legendX: LegendXChoice?
    public var legendY: LegendYChoice?
    public var offset: OffsetChoice?
    /// The orientation of the legend, which determines how the legend is positioned within the scene. One of `"left"`, `"right"`, `"top"`, `"bottom"`, `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`, `"none"`.
    /// __Default value:__ `"right"`
    public var orient: LegendOrient?
    public var padding: PaddingChoice?
    public var rowPadding: RowPaddingChoice?
    public var strokeColor: StrokeColorChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeWidth: StrokeWidthChoice?
    public var symbolBaseFillColor: SymbolBaseFillColorChoice?
    public var symbolBaseStrokeColor: SymbolBaseStrokeColorChoice?
    public var symbolDash: SymbolDashChoice?
    public var symbolDashOffset: SymbolDashOffsetChoice?
    public var symbolDirection: SymbolDirectionChoice?
    public var symbolFillColor: SymbolFillColorChoice?
    public var symbolLimit: SymbolLimitChoice?
    public var symbolOffset: SymbolOffsetChoice?
    public var symbolOpacity: SymbolOpacityChoice?
    public var symbolSize: SymbolSizeChoice?
    public var symbolStrokeColor: SymbolStrokeColorChoice?
    public var symbolStrokeWidth: SymbolStrokeWidthChoice?
    public var symbolType: SymbolTypeChoice?
    public var tickCount: TickCountChoice?
    /// Set to null to disable title for the axis, legend, or header.
    public var title: ExplicitNull?
    public var titleAlign: TitleAlignChoice?
    public var titleAnchor: TitleAnchorChoice?
    public var titleBaseline: TitleBaselineChoice?
    public var titleColor: TitleColorChoice?
    public var titleFont: FontName?
    public var titleFontSize: TitleFontSizeChoice?
    public var titleFontStyle: TitleFontStyleChoice?
    public var titleFontWeight: TitleFontWeightChoice?
    public var titleLimit: TitleLimitChoice?
    public var titleLineHeight: TitleLineHeightChoice?
    public var titleOpacity: TitleOpacityChoice?
    public var titleOrient: TitleOrientChoice?
    public var titlePadding: TitlePaddingChoice?
    /// The opacity of unselected legend entries.
    /// __Default value:__ 0.35.
    public var unselectedOpacity: Double?
    public var zindex: ZindexChoice?
    public static let codingKeyPaths = (\Self.aria as KeyPath, \Self.clipHeight as KeyPath, \Self.columnPadding as KeyPath, \Self.columns as KeyPath, \Self.cornerRadius as KeyPath, \Self.description as KeyPath, \Self.direction as KeyPath, \Self.disable as KeyPath, \Self.fillColor as KeyPath, \Self.gradientDirection as KeyPath, \Self.gradientHorizontalMaxLength as KeyPath, \Self.gradientHorizontalMinLength as KeyPath, \Self.gradientLabelLimit as KeyPath, \Self.gradientLabelOffset as KeyPath, \Self.gradientLength as KeyPath, \Self.gradientOpacity as KeyPath, \Self.gradientStrokeColor as KeyPath, \Self.gradientStrokeWidth as KeyPath, \Self.gradientThickness as KeyPath, \Self.gradientVerticalMaxLength as KeyPath, \Self.gradientVerticalMinLength as KeyPath, \Self.gridAlign as KeyPath, \Self.labelAlign as KeyPath, \Self.labelBaseline as KeyPath, \Self.labelColor as KeyPath, \Self.labelFont as KeyPath, \Self.labelFontSize as KeyPath, \Self.labelFontStyle as KeyPath, \Self.labelFontWeight as KeyPath, \Self.labelLimit as KeyPath, \Self.labelOffset as KeyPath, \Self.labelOpacity as KeyPath, \Self.labelOverlap as KeyPath, \Self.labelPadding as KeyPath, \Self.labelSeparation as KeyPath, \Self.layout as KeyPath, \Self.legendX as KeyPath, \Self.legendY as KeyPath, \Self.offset as KeyPath, \Self.orient as KeyPath, \Self.padding as KeyPath, \Self.rowPadding as KeyPath, \Self.strokeColor as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeWidth as KeyPath, \Self.symbolBaseFillColor as KeyPath, \Self.symbolBaseStrokeColor as KeyPath, \Self.symbolDash as KeyPath, \Self.symbolDashOffset as KeyPath, \Self.symbolDirection as KeyPath, \Self.symbolFillColor as KeyPath, \Self.symbolLimit as KeyPath, \Self.symbolOffset as KeyPath, \Self.symbolOpacity as KeyPath, \Self.symbolSize as KeyPath, \Self.symbolStrokeColor as KeyPath, \Self.symbolStrokeWidth as KeyPath, \Self.symbolType as KeyPath, \Self.tickCount as KeyPath, \Self.title as KeyPath, \Self.titleAlign as KeyPath, \Self.titleAnchor as KeyPath, \Self.titleBaseline as KeyPath, \Self.titleColor as KeyPath, \Self.titleFont as KeyPath, \Self.titleFontSize as KeyPath, \Self.titleFontStyle as KeyPath, \Self.titleFontWeight as KeyPath, \Self.titleLimit as KeyPath, \Self.titleLineHeight as KeyPath, \Self.titleOpacity as KeyPath, \Self.titleOrient as KeyPath, \Self.titlePadding as KeyPath, \Self.unselectedOpacity as KeyPath, \Self.zindex as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aria as KeyPath : CodingKeys.aria, \Self.clipHeight as KeyPath : CodingKeys.clipHeight, \Self.columnPadding as KeyPath : CodingKeys.columnPadding, \Self.columns as KeyPath : CodingKeys.columns, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.description as KeyPath : CodingKeys.description, \Self.direction as KeyPath : CodingKeys.direction, \Self.disable as KeyPath : CodingKeys.disable, \Self.fillColor as KeyPath : CodingKeys.fillColor, \Self.gradientDirection as KeyPath : CodingKeys.gradientDirection, \Self.gradientHorizontalMaxLength as KeyPath : CodingKeys.gradientHorizontalMaxLength, \Self.gradientHorizontalMinLength as KeyPath : CodingKeys.gradientHorizontalMinLength, \Self.gradientLabelLimit as KeyPath : CodingKeys.gradientLabelLimit, \Self.gradientLabelOffset as KeyPath : CodingKeys.gradientLabelOffset, \Self.gradientLength as KeyPath : CodingKeys.gradientLength, \Self.gradientOpacity as KeyPath : CodingKeys.gradientOpacity, \Self.gradientStrokeColor as KeyPath : CodingKeys.gradientStrokeColor, \Self.gradientStrokeWidth as KeyPath : CodingKeys.gradientStrokeWidth, \Self.gradientThickness as KeyPath : CodingKeys.gradientThickness, \Self.gradientVerticalMaxLength as KeyPath : CodingKeys.gradientVerticalMaxLength, \Self.gradientVerticalMinLength as KeyPath : CodingKeys.gradientVerticalMinLength, \Self.gridAlign as KeyPath : CodingKeys.gridAlign, \Self.labelAlign as KeyPath : CodingKeys.labelAlign, \Self.labelBaseline as KeyPath : CodingKeys.labelBaseline, \Self.labelColor as KeyPath : CodingKeys.labelColor, \Self.labelFont as KeyPath : CodingKeys.labelFont, \Self.labelFontSize as KeyPath : CodingKeys.labelFontSize, \Self.labelFontStyle as KeyPath : CodingKeys.labelFontStyle, \Self.labelFontWeight as KeyPath : CodingKeys.labelFontWeight, \Self.labelLimit as KeyPath : CodingKeys.labelLimit, \Self.labelOffset as KeyPath : CodingKeys.labelOffset, \Self.labelOpacity as KeyPath : CodingKeys.labelOpacity, \Self.labelOverlap as KeyPath : CodingKeys.labelOverlap, \Self.labelPadding as KeyPath : CodingKeys.labelPadding, \Self.labelSeparation as KeyPath : CodingKeys.labelSeparation, \Self.layout as KeyPath : CodingKeys.layout, \Self.legendX as KeyPath : CodingKeys.legendX, \Self.legendY as KeyPath : CodingKeys.legendY, \Self.offset as KeyPath : CodingKeys.offset, \Self.orient as KeyPath : CodingKeys.orient, \Self.padding as KeyPath : CodingKeys.padding, \Self.rowPadding as KeyPath : CodingKeys.rowPadding, \Self.strokeColor as KeyPath : CodingKeys.strokeColor, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.symbolBaseFillColor as KeyPath : CodingKeys.symbolBaseFillColor, \Self.symbolBaseStrokeColor as KeyPath : CodingKeys.symbolBaseStrokeColor, \Self.symbolDash as KeyPath : CodingKeys.symbolDash, \Self.symbolDashOffset as KeyPath : CodingKeys.symbolDashOffset, \Self.symbolDirection as KeyPath : CodingKeys.symbolDirection, \Self.symbolFillColor as KeyPath : CodingKeys.symbolFillColor, \Self.symbolLimit as KeyPath : CodingKeys.symbolLimit, \Self.symbolOffset as KeyPath : CodingKeys.symbolOffset, \Self.symbolOpacity as KeyPath : CodingKeys.symbolOpacity, \Self.symbolSize as KeyPath : CodingKeys.symbolSize, \Self.symbolStrokeColor as KeyPath : CodingKeys.symbolStrokeColor, \Self.symbolStrokeWidth as KeyPath : CodingKeys.symbolStrokeWidth, \Self.symbolType as KeyPath : CodingKeys.symbolType, \Self.tickCount as KeyPath : CodingKeys.tickCount, \Self.title as KeyPath : CodingKeys.title, \Self.titleAlign as KeyPath : CodingKeys.titleAlign, \Self.titleAnchor as KeyPath : CodingKeys.titleAnchor, \Self.titleBaseline as KeyPath : CodingKeys.titleBaseline, \Self.titleColor as KeyPath : CodingKeys.titleColor, \Self.titleFont as KeyPath : CodingKeys.titleFont, \Self.titleFontSize as KeyPath : CodingKeys.titleFontSize, \Self.titleFontStyle as KeyPath : CodingKeys.titleFontStyle, \Self.titleFontWeight as KeyPath : CodingKeys.titleFontWeight, \Self.titleLimit as KeyPath : CodingKeys.titleLimit, \Self.titleLineHeight as KeyPath : CodingKeys.titleLineHeight, \Self.titleOpacity as KeyPath : CodingKeys.titleOpacity, \Self.titleOrient as KeyPath : CodingKeys.titleOrient, \Self.titlePadding as KeyPath : CodingKeys.titlePadding, \Self.unselectedOpacity as KeyPath : CodingKeys.unselectedOpacity, \Self.zindex as KeyPath : CodingKeys.zindex]

    public init(aria: AriaChoice? = nil, clipHeight: ClipHeightChoice? = nil, columnPadding: ColumnPaddingChoice? = nil, columns: ColumnsChoice? = nil, cornerRadius: CornerRadiusChoice? = nil, description: DescriptionChoice? = nil, direction: Orientation? = nil, disable: Bool? = nil, fillColor: FillColorChoice? = nil, gradientDirection: GradientDirectionChoice? = nil, gradientHorizontalMaxLength: Double? = nil, gradientHorizontalMinLength: Double? = nil, gradientLabelLimit: GradientLabelLimitChoice? = nil, gradientLabelOffset: GradientLabelOffsetChoice? = nil, gradientLength: GradientLengthChoice? = nil, gradientOpacity: GradientOpacityChoice? = nil, gradientStrokeColor: GradientStrokeColorChoice? = nil, gradientStrokeWidth: GradientStrokeWidthChoice? = nil, gradientThickness: GradientThicknessChoice? = nil, gradientVerticalMaxLength: Double? = nil, gradientVerticalMinLength: Double? = nil, gridAlign: GridAlignChoice? = nil, labelAlign: LabelAlignChoice? = nil, labelBaseline: LabelBaselineChoice? = nil, labelColor: LabelColorChoice? = nil, labelFont: FontName? = nil, labelFontSize: LabelFontSizeChoice? = nil, labelFontStyle: LabelFontStyleChoice? = nil, labelFontWeight: LabelFontWeightChoice? = nil, labelLimit: LabelLimitChoice? = nil, labelOffset: LabelOffsetChoice? = nil, labelOpacity: LabelOpacityChoice? = nil, labelOverlap: LabelOverlapChoice? = nil, labelPadding: LabelPaddingChoice? = nil, labelSeparation: LabelSeparationChoice? = nil, layout: ExprRef? = nil, legendX: LegendXChoice? = nil, legendY: LegendYChoice? = nil, offset: OffsetChoice? = nil, orient: LegendOrient? = nil, padding: PaddingChoice? = nil, rowPadding: RowPaddingChoice? = nil, strokeColor: StrokeColorChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, symbolBaseFillColor: SymbolBaseFillColorChoice? = nil, symbolBaseStrokeColor: SymbolBaseStrokeColorChoice? = nil, symbolDash: SymbolDashChoice? = nil, symbolDashOffset: SymbolDashOffsetChoice? = nil, symbolDirection: SymbolDirectionChoice? = nil, symbolFillColor: SymbolFillColorChoice? = nil, symbolLimit: SymbolLimitChoice? = nil, symbolOffset: SymbolOffsetChoice? = nil, symbolOpacity: SymbolOpacityChoice? = nil, symbolSize: SymbolSizeChoice? = nil, symbolStrokeColor: SymbolStrokeColorChoice? = nil, symbolStrokeWidth: SymbolStrokeWidthChoice? = nil, symbolType: SymbolTypeChoice? = nil, tickCount: TickCountChoice? = nil, title: ExplicitNull? = nil, titleAlign: TitleAlignChoice? = nil, titleAnchor: TitleAnchorChoice? = nil, titleBaseline: TitleBaselineChoice? = nil, titleColor: TitleColorChoice? = nil, titleFont: FontName? = nil, titleFontSize: TitleFontSizeChoice? = nil, titleFontStyle: TitleFontStyleChoice? = nil, titleFontWeight: TitleFontWeightChoice? = nil, titleLimit: TitleLimitChoice? = nil, titleLineHeight: TitleLineHeightChoice? = nil, titleOpacity: TitleOpacityChoice? = nil, titleOrient: TitleOrientChoice? = nil, titlePadding: TitlePaddingChoice? = nil, unselectedOpacity: Double? = nil, zindex: ZindexChoice? = nil) {
        self.aria = aria 
        self.clipHeight = clipHeight 
        self.columnPadding = columnPadding 
        self.columns = columns 
        self.cornerRadius = cornerRadius 
        self.description = description 
        self.direction = direction 
        self.disable = disable 
        self.fillColor = fillColor 
        self.gradientDirection = gradientDirection 
        self.gradientHorizontalMaxLength = gradientHorizontalMaxLength 
        self.gradientHorizontalMinLength = gradientHorizontalMinLength 
        self.gradientLabelLimit = gradientLabelLimit 
        self.gradientLabelOffset = gradientLabelOffset 
        self.gradientLength = gradientLength 
        self.gradientOpacity = gradientOpacity 
        self.gradientStrokeColor = gradientStrokeColor 
        self.gradientStrokeWidth = gradientStrokeWidth 
        self.gradientThickness = gradientThickness 
        self.gradientVerticalMaxLength = gradientVerticalMaxLength 
        self.gradientVerticalMinLength = gradientVerticalMinLength 
        self.gridAlign = gridAlign 
        self.labelAlign = labelAlign 
        self.labelBaseline = labelBaseline 
        self.labelColor = labelColor 
        self.labelFont = labelFont 
        self.labelFontSize = labelFontSize 
        self.labelFontStyle = labelFontStyle 
        self.labelFontWeight = labelFontWeight 
        self.labelLimit = labelLimit 
        self.labelOffset = labelOffset 
        self.labelOpacity = labelOpacity 
        self.labelOverlap = labelOverlap 
        self.labelPadding = labelPadding 
        self.labelSeparation = labelSeparation 
        self.layout = layout 
        self.legendX = legendX 
        self.legendY = legendY 
        self.offset = offset 
        self.orient = orient 
        self.padding = padding 
        self.rowPadding = rowPadding 
        self.strokeColor = strokeColor 
        self.strokeDash = strokeDash 
        self.strokeWidth = strokeWidth 
        self.symbolBaseFillColor = symbolBaseFillColor 
        self.symbolBaseStrokeColor = symbolBaseStrokeColor 
        self.symbolDash = symbolDash 
        self.symbolDashOffset = symbolDashOffset 
        self.symbolDirection = symbolDirection 
        self.symbolFillColor = symbolFillColor 
        self.symbolLimit = symbolLimit 
        self.symbolOffset = symbolOffset 
        self.symbolOpacity = symbolOpacity 
        self.symbolSize = symbolSize 
        self.symbolStrokeColor = symbolStrokeColor 
        self.symbolStrokeWidth = symbolStrokeWidth 
        self.symbolType = symbolType 
        self.tickCount = tickCount 
        self.title = title 
        self.titleAlign = titleAlign 
        self.titleAnchor = titleAnchor 
        self.titleBaseline = titleBaseline 
        self.titleColor = titleColor 
        self.titleFont = titleFont 
        self.titleFontSize = titleFontSize 
        self.titleFontStyle = titleFontStyle 
        self.titleFontWeight = titleFontWeight 
        self.titleLimit = titleLimit 
        self.titleLineHeight = titleLineHeight 
        self.titleOpacity = titleOpacity 
        self.titleOrient = titleOrient 
        self.titlePadding = titlePadding 
        self.unselectedOpacity = unselectedOpacity 
        self.zindex = zindex 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.clipHeight = try values.decodeOptional(ClipHeightChoice.self, forKey: .clipHeight) 
        self.columnPadding = try values.decodeOptional(ColumnPaddingChoice.self, forKey: .columnPadding) 
        self.columns = try values.decodeOptional(ColumnsChoice.self, forKey: .columns) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.direction = try values.decodeOptional(Orientation.self, forKey: .direction) 
        self.disable = try values.decodeOptional(Bool.self, forKey: .disable) 
        self.fillColor = try values.decodeOptional(FillColorChoice.self, forKey: .fillColor) 
        self.gradientDirection = try values.decodeOptional(GradientDirectionChoice.self, forKey: .gradientDirection) 
        self.gradientHorizontalMaxLength = try values.decodeOptional(Double.self, forKey: .gradientHorizontalMaxLength) 
        self.gradientHorizontalMinLength = try values.decodeOptional(Double.self, forKey: .gradientHorizontalMinLength) 
        self.gradientLabelLimit = try values.decodeOptional(GradientLabelLimitChoice.self, forKey: .gradientLabelLimit) 
        self.gradientLabelOffset = try values.decodeOptional(GradientLabelOffsetChoice.self, forKey: .gradientLabelOffset) 
        self.gradientLength = try values.decodeOptional(GradientLengthChoice.self, forKey: .gradientLength) 
        self.gradientOpacity = try values.decodeOptional(GradientOpacityChoice.self, forKey: .gradientOpacity) 
        self.gradientStrokeColor = try values.decodeOptional(GradientStrokeColorChoice.self, forKey: .gradientStrokeColor) 
        self.gradientStrokeWidth = try values.decodeOptional(GradientStrokeWidthChoice.self, forKey: .gradientStrokeWidth) 
        self.gradientThickness = try values.decodeOptional(GradientThicknessChoice.self, forKey: .gradientThickness) 
        self.gradientVerticalMaxLength = try values.decodeOptional(Double.self, forKey: .gradientVerticalMaxLength) 
        self.gradientVerticalMinLength = try values.decodeOptional(Double.self, forKey: .gradientVerticalMinLength) 
        self.gridAlign = try values.decodeOptional(GridAlignChoice.self, forKey: .gridAlign) 
        self.labelAlign = try values.decodeOptional(LabelAlignChoice.self, forKey: .labelAlign) 
        self.labelBaseline = try values.decodeOptional(LabelBaselineChoice.self, forKey: .labelBaseline) 
        self.labelColor = try values.decodeOptional(LabelColorChoice.self, forKey: .labelColor) 
        self.labelFont = try values.decodeOptional(FontName.self, forKey: .labelFont) 
        self.labelFontSize = try values.decodeOptional(LabelFontSizeChoice.self, forKey: .labelFontSize) 
        self.labelFontStyle = try values.decodeOptional(LabelFontStyleChoice.self, forKey: .labelFontStyle) 
        self.labelFontWeight = try values.decodeOptional(LabelFontWeightChoice.self, forKey: .labelFontWeight) 
        self.labelLimit = try values.decodeOptional(LabelLimitChoice.self, forKey: .labelLimit) 
        self.labelOffset = try values.decodeOptional(LabelOffsetChoice.self, forKey: .labelOffset) 
        self.labelOpacity = try values.decodeOptional(LabelOpacityChoice.self, forKey: .labelOpacity) 
        self.labelOverlap = try values.decodeOptional(LabelOverlapChoice.self, forKey: .labelOverlap) 
        self.labelPadding = try values.decodeOptional(LabelPaddingChoice.self, forKey: .labelPadding) 
        self.labelSeparation = try values.decodeOptional(LabelSeparationChoice.self, forKey: .labelSeparation) 
        self.layout = try values.decodeOptional(ExprRef.self, forKey: .layout) 
        self.legendX = try values.decodeOptional(LegendXChoice.self, forKey: .legendX) 
        self.legendY = try values.decodeOptional(LegendYChoice.self, forKey: .legendY) 
        self.offset = try values.decodeOptional(OffsetChoice.self, forKey: .offset) 
        self.orient = try values.decodeOptional(LegendOrient.self, forKey: .orient) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.rowPadding = try values.decodeOptional(RowPaddingChoice.self, forKey: .rowPadding) 
        self.strokeColor = try values.decodeOptional(StrokeColorChoice.self, forKey: .strokeColor) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.symbolBaseFillColor = try values.decodeOptional(SymbolBaseFillColorChoice.self, forKey: .symbolBaseFillColor) 
        self.symbolBaseStrokeColor = try values.decodeOptional(SymbolBaseStrokeColorChoice.self, forKey: .symbolBaseStrokeColor) 
        self.symbolDash = try values.decodeOptional(SymbolDashChoice.self, forKey: .symbolDash) 
        self.symbolDashOffset = try values.decodeOptional(SymbolDashOffsetChoice.self, forKey: .symbolDashOffset) 
        self.symbolDirection = try values.decodeOptional(SymbolDirectionChoice.self, forKey: .symbolDirection) 
        self.symbolFillColor = try values.decodeOptional(SymbolFillColorChoice.self, forKey: .symbolFillColor) 
        self.symbolLimit = try values.decodeOptional(SymbolLimitChoice.self, forKey: .symbolLimit) 
        self.symbolOffset = try values.decodeOptional(SymbolOffsetChoice.self, forKey: .symbolOffset) 
        self.symbolOpacity = try values.decodeOptional(SymbolOpacityChoice.self, forKey: .symbolOpacity) 
        self.symbolSize = try values.decodeOptional(SymbolSizeChoice.self, forKey: .symbolSize) 
        self.symbolStrokeColor = try values.decodeOptional(SymbolStrokeColorChoice.self, forKey: .symbolStrokeColor) 
        self.symbolStrokeWidth = try values.decodeOptional(SymbolStrokeWidthChoice.self, forKey: .symbolStrokeWidth) 
        self.symbolType = try values.decodeOptional(SymbolTypeChoice.self, forKey: .symbolType) 
        self.tickCount = try values.decodeOptional(TickCountChoice.self, forKey: .tickCount) 
        self.title = try values.decodeOptional(ExplicitNull.self, forKey: .title) 
        self.titleAlign = try values.decodeOptional(TitleAlignChoice.self, forKey: .titleAlign) 
        self.titleAnchor = try values.decodeOptional(TitleAnchorChoice.self, forKey: .titleAnchor) 
        self.titleBaseline = try values.decodeOptional(TitleBaselineChoice.self, forKey: .titleBaseline) 
        self.titleColor = try values.decodeOptional(TitleColorChoice.self, forKey: .titleColor) 
        self.titleFont = try values.decodeOptional(FontName.self, forKey: .titleFont) 
        self.titleFontSize = try values.decodeOptional(TitleFontSizeChoice.self, forKey: .titleFontSize) 
        self.titleFontStyle = try values.decodeOptional(TitleFontStyleChoice.self, forKey: .titleFontStyle) 
        self.titleFontWeight = try values.decodeOptional(TitleFontWeightChoice.self, forKey: .titleFontWeight) 
        self.titleLimit = try values.decodeOptional(TitleLimitChoice.self, forKey: .titleLimit) 
        self.titleLineHeight = try values.decodeOptional(TitleLineHeightChoice.self, forKey: .titleLineHeight) 
        self.titleOpacity = try values.decodeOptional(TitleOpacityChoice.self, forKey: .titleOpacity) 
        self.titleOrient = try values.decodeOptional(TitleOrientChoice.self, forKey: .titleOrient) 
        self.titlePadding = try values.decodeOptional(TitlePaddingChoice.self, forKey: .titlePadding) 
        self.unselectedOpacity = try values.decodeOptional(Double.self, forKey: .unselectedOpacity) 
        self.zindex = try values.decodeOptional(ZindexChoice.self, forKey: .zindex) 
    }

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias ClipHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ColumnPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ColumnsChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias FillColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientDirectionChoice = OneOf<Orientation>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientLabelLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientLabelOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientLengthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientStrokeColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientStrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientThicknessChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GridAlignChoice = OneOf<LayoutAlign>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelAlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// The strategy to use for resolving overlap of labels in gradient legends. If `false`, no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used. If set to `"greedy"`, a linear scan of the labels is performed, removing any label that overlaps with the last visible label (this often works better for log-scaled axes).
    /// __Default value:__ `"greedy"` for `log scales otherwise `true`.
    /// Generated by Curio
    public typealias LabelOverlapChoice = OneOf<LabelOverlap>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelSeparationChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LegendXChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LegendYChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias RowPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolBaseFillColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolBaseStrokeColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolDirectionChoice = OneOf<Orientation>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolFillColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolStrokeColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolStrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolTypeChoice = OneOf<SymbolShape>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickCountChoice = OneOf<TickCount>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleAlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleAnchorChoice = OneOf<TitleAnchor>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleOrientChoice = OneOf<Orient>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitlePaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ZindexChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aria
        case clipHeight
        case columnPadding
        case columns
        case cornerRadius
        case description
        case direction
        case disable
        case fillColor
        case gradientDirection
        case gradientHorizontalMaxLength
        case gradientHorizontalMinLength
        case gradientLabelLimit
        case gradientLabelOffset
        case gradientLength
        case gradientOpacity
        case gradientStrokeColor
        case gradientStrokeWidth
        case gradientThickness
        case gradientVerticalMaxLength
        case gradientVerticalMinLength
        case gridAlign
        case labelAlign
        case labelBaseline
        case labelColor
        case labelFont
        case labelFontSize
        case labelFontStyle
        case labelFontWeight
        case labelLimit
        case labelOffset
        case labelOpacity
        case labelOverlap
        case labelPadding
        case labelSeparation
        case layout
        case legendX
        case legendY
        case offset
        case orient
        case padding
        case rowPadding
        case strokeColor
        case strokeDash
        case strokeWidth
        case symbolBaseFillColor
        case symbolBaseStrokeColor
        case symbolDash
        case symbolDashOffset
        case symbolDirection
        case symbolFillColor
        case symbolLimit
        case symbolOffset
        case symbolOpacity
        case symbolSize
        case symbolStrokeColor
        case symbolStrokeWidth
        case symbolType
        case tickCount
        case title
        case titleAlign
        case titleAnchor
        case titleBaseline
        case titleColor
        case titleFont
        case titleFontSize
        case titleFontStyle
        case titleFontWeight
        case titleLimit
        case titleLineHeight
        case titleOpacity
        case titleOrient
        case titlePadding
        case unselectedOpacity
        case zindex
        public var keyDescription: String? {
            switch self {
            case .aria: return nil
            case .clipHeight: return nil
            case .columnPadding: return nil
            case .columns: return nil
            case .cornerRadius: return nil
            case .description: return nil
            case .direction: return "The direction of the legend, one of `\"vertical\"` or `\"horizontal\"`.\n\n__Default value:__\n- For top-/bottom-`orient`ed legends, `\"horizontal\"`\n- For left-/right-`orient`ed legends, `\"vertical\"`\n- For top/bottom-left/right-`orient`ed legends, `\"horizontal\"` for gradient legends and `\"vertical\"` for symbol legends."
            case .disable: return "Disable legend by default"
            case .fillColor: return nil
            case .gradientDirection: return nil
            case .gradientHorizontalMaxLength: return "Max legend length for a horizontal gradient when `config.legend.gradientLength` is undefined.\n\n__Default value:__ `200`"
            case .gradientHorizontalMinLength: return "Min legend length for a horizontal gradient when `config.legend.gradientLength` is undefined.\n\n__Default value:__ `100`"
            case .gradientLabelLimit: return nil
            case .gradientLabelOffset: return nil
            case .gradientLength: return nil
            case .gradientOpacity: return nil
            case .gradientStrokeColor: return nil
            case .gradientStrokeWidth: return nil
            case .gradientThickness: return nil
            case .gradientVerticalMaxLength: return "Max legend length for a vertical gradient when `config.legend.gradientLength` is undefined.\n\n__Default value:__ `200`"
            case .gradientVerticalMinLength: return "Min legend length for a vertical gradient when `config.legend.gradientLength` is undefined.\n\n__Default value:__ `100`"
            case .gridAlign: return nil
            case .labelAlign: return nil
            case .labelBaseline: return nil
            case .labelColor: return nil
            case .labelFont: return nil
            case .labelFontSize: return nil
            case .labelFontStyle: return nil
            case .labelFontWeight: return nil
            case .labelLimit: return nil
            case .labelOffset: return nil
            case .labelOpacity: return nil
            case .labelOverlap: return "The strategy to use for resolving overlap of labels in gradient legends. If `false`, no overlap reduction is attempted. If set to `true` or `\"parity\"`, a strategy of removing every other label is used. If set to `\"greedy\"`, a linear scan of the labels is performed, removing any label that overlaps with the last visible label (this often works better for log-scaled axes).\n\n__Default value:__ `\"greedy\"` for `log scales otherwise `true`."
            case .labelPadding: return nil
            case .labelSeparation: return nil
            case .layout: return nil
            case .legendX: return nil
            case .legendY: return nil
            case .offset: return nil
            case .orient: return "The orientation of the legend, which determines how the legend is positioned within the scene. One of `\"left\"`, `\"right\"`, `\"top\"`, `\"bottom\"`, `\"top-left\"`, `\"top-right\"`, `\"bottom-left\"`, `\"bottom-right\"`, `\"none\"`.\n\n__Default value:__ `\"right\"`"
            case .padding: return nil
            case .rowPadding: return nil
            case .strokeColor: return nil
            case .strokeDash: return nil
            case .strokeWidth: return nil
            case .symbolBaseFillColor: return nil
            case .symbolBaseStrokeColor: return nil
            case .symbolDash: return nil
            case .symbolDashOffset: return nil
            case .symbolDirection: return nil
            case .symbolFillColor: return nil
            case .symbolLimit: return nil
            case .symbolOffset: return nil
            case .symbolOpacity: return nil
            case .symbolSize: return nil
            case .symbolStrokeColor: return nil
            case .symbolStrokeWidth: return nil
            case .symbolType: return nil
            case .tickCount: return nil
            case .title: return "Set to null to disable title for the axis, legend, or header."
            case .titleAlign: return nil
            case .titleAnchor: return nil
            case .titleBaseline: return nil
            case .titleColor: return nil
            case .titleFont: return nil
            case .titleFontSize: return nil
            case .titleFontStyle: return nil
            case .titleFontWeight: return nil
            case .titleLimit: return nil
            case .titleLineHeight: return nil
            case .titleOpacity: return nil
            case .titleOrient: return nil
            case .titlePadding: return nil
            case .unselectedOpacity: return "The opacity of unselected legend entries.\n\n__Default value:__ 0.35."
            case .zindex: return nil
             } 
        }

        public typealias CodingOwner = LegendConfig
    }
}

/// Properties of a legend or boolean flag for determining whether to show it.
/// Generated by Curio
public struct LegendDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var aria: AriaChoice?
    public var clipHeight: ClipHeightChoice?
    public var columnPadding: ColumnPaddingChoice?
    public var columns: ColumnsChoice?
    public var cornerRadius: CornerRadiusChoice?
    public var description: DescriptionChoice?
    /// The direction of the legend, one of `"vertical"` or `"horizontal"`.
    /// __Default value:__
    /// - For top-/bottom-`orient`ed legends, `"horizontal"`
    /// - For left-/right-`orient`ed legends, `"vertical"`
    /// - For top/bottom-left/right-`orient`ed legends, `"horizontal"` for gradient legends and `"vertical"` for symbol legends.
    public var direction: Orientation?
    public var fillColor: FillColorChoice?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    public var gradientLength: GradientLengthChoice?
    public var gradientOpacity: GradientOpacityChoice?
    public var gradientStrokeColor: GradientStrokeColorChoice?
    public var gradientStrokeWidth: GradientStrokeWidthChoice?
    public var gradientThickness: GradientThicknessChoice?
    public var gridAlign: GridAlignChoice?
    public var labelAlign: LabelAlignChoice?
    public var labelBaseline: LabelBaselineChoice?
    public var labelColor: LabelColorChoice?
    /// [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
    /// __Note:__ The label text and value can be assessed via the `label` and `value` properties of the legend's backing `datum` object.
    public var labelExpr: Expr?
    public var labelFont: FontName?
    public var labelFontSize: LabelFontSizeChoice?
    public var labelFontStyle: LabelFontStyleChoice?
    public var labelFontWeight: LabelFontWeightChoice?
    public var labelLimit: LabelLimitChoice?
    public var labelOffset: LabelOffsetChoice?
    public var labelOpacity: LabelOpacityChoice?
    public var labelOverlap: LabelOverlapChoice?
    public var labelPadding: LabelPaddingChoice?
    public var labelSeparation: LabelSeparationChoice?
    public var legendX: LegendXChoice?
    public var legendY: LegendYChoice?
    public var offset: OffsetChoice?
    /// The orientation of the legend, which determines how the legend is positioned within the scene. One of `"left"`, `"right"`, `"top"`, `"bottom"`, `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`, `"none"`.
    /// __Default value:__ `"right"`
    public var orient: LegendOrient?
    public var padding: PaddingChoice?
    public var rowPadding: RowPaddingChoice?
    public var strokeColor: StrokeColorChoice?
    public var symbolDash: SymbolDashChoice?
    public var symbolDashOffset: SymbolDashOffsetChoice?
    public var symbolFillColor: SymbolFillColorChoice?
    public var symbolLimit: SymbolLimitChoice?
    public var symbolOffset: SymbolOffsetChoice?
    public var symbolOpacity: SymbolOpacityChoice?
    public var symbolSize: SymbolSizeChoice?
    public var symbolStrokeColor: SymbolStrokeColorChoice?
    public var symbolStrokeWidth: SymbolStrokeWidthChoice?
    public var symbolType: SymbolTypeChoice?
    public var tickCount: TickCountChoice?
    /// The minimum desired step between legend ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value.
    /// __Default value__: `undefined`
    public var tickMinStep: TickMinStepChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    public var titleAlign: TitleAlignChoice?
    public var titleAnchor: TitleAnchorChoice?
    public var titleBaseline: TitleBaselineChoice?
    public var titleColor: TitleColorChoice?
    public var titleFont: FontName?
    public var titleFontSize: TitleFontSizeChoice?
    public var titleFontStyle: TitleFontStyleChoice?
    public var titleFontWeight: TitleFontWeightChoice?
    public var titleLimit: TitleLimitChoice?
    public var titleLineHeight: TitleLineHeightChoice?
    public var titleOpacity: TitleOpacityChoice?
    public var titleOrient: TitleOrientChoice?
    public var titlePadding: TitlePaddingChoice?
    /// The type of the legend. Use `"symbol"` to create a discrete legend and `"gradient"` for a continuous color gradient.
    /// __Default value:__ `"gradient"` for non-binned quantitative fields and temporal fields; `"symbol"` otherwise.
    public var type: LiteralSymbolOrGradient?
    /// Explicitly set the visible legend values.
    public var values: ValuesChoice?
    /// A non-negative integer indicating the z-index of the legend. If zindex is 0, legend should be drawn behind all chart elements. To put them in front, use zindex = 1.
    public var zindex: Double?
    public static let codingKeyPaths = (\Self.aria as KeyPath, \Self.clipHeight as KeyPath, \Self.columnPadding as KeyPath, \Self.columns as KeyPath, \Self.cornerRadius as KeyPath, \Self.description as KeyPath, \Self.direction as KeyPath, \Self.fillColor as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.gradientLength as KeyPath, \Self.gradientOpacity as KeyPath, \Self.gradientStrokeColor as KeyPath, \Self.gradientStrokeWidth as KeyPath, \Self.gradientThickness as KeyPath, \Self.gridAlign as KeyPath, \Self.labelAlign as KeyPath, \Self.labelBaseline as KeyPath, \Self.labelColor as KeyPath, \Self.labelExpr as KeyPath, \Self.labelFont as KeyPath, \Self.labelFontSize as KeyPath, \Self.labelFontStyle as KeyPath, \Self.labelFontWeight as KeyPath, \Self.labelLimit as KeyPath, \Self.labelOffset as KeyPath, \Self.labelOpacity as KeyPath, \Self.labelOverlap as KeyPath, \Self.labelPadding as KeyPath, \Self.labelSeparation as KeyPath, \Self.legendX as KeyPath, \Self.legendY as KeyPath, \Self.offset as KeyPath, \Self.orient as KeyPath, \Self.padding as KeyPath, \Self.rowPadding as KeyPath, \Self.strokeColor as KeyPath, \Self.symbolDash as KeyPath, \Self.symbolDashOffset as KeyPath, \Self.symbolFillColor as KeyPath, \Self.symbolLimit as KeyPath, \Self.symbolOffset as KeyPath, \Self.symbolOpacity as KeyPath, \Self.symbolSize as KeyPath, \Self.symbolStrokeColor as KeyPath, \Self.symbolStrokeWidth as KeyPath, \Self.symbolType as KeyPath, \Self.tickCount as KeyPath, \Self.tickMinStep as KeyPath, \Self.title as KeyPath, \Self.titleAlign as KeyPath, \Self.titleAnchor as KeyPath, \Self.titleBaseline as KeyPath, \Self.titleColor as KeyPath, \Self.titleFont as KeyPath, \Self.titleFontSize as KeyPath, \Self.titleFontStyle as KeyPath, \Self.titleFontWeight as KeyPath, \Self.titleLimit as KeyPath, \Self.titleLineHeight as KeyPath, \Self.titleOpacity as KeyPath, \Self.titleOrient as KeyPath, \Self.titlePadding as KeyPath, \Self.type as KeyPath, \Self.values as KeyPath, \Self.zindex as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aria as KeyPath : CodingKeys.aria, \Self.clipHeight as KeyPath : CodingKeys.clipHeight, \Self.columnPadding as KeyPath : CodingKeys.columnPadding, \Self.columns as KeyPath : CodingKeys.columns, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.description as KeyPath : CodingKeys.description, \Self.direction as KeyPath : CodingKeys.direction, \Self.fillColor as KeyPath : CodingKeys.fillColor, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.gradientLength as KeyPath : CodingKeys.gradientLength, \Self.gradientOpacity as KeyPath : CodingKeys.gradientOpacity, \Self.gradientStrokeColor as KeyPath : CodingKeys.gradientStrokeColor, \Self.gradientStrokeWidth as KeyPath : CodingKeys.gradientStrokeWidth, \Self.gradientThickness as KeyPath : CodingKeys.gradientThickness, \Self.gridAlign as KeyPath : CodingKeys.gridAlign, \Self.labelAlign as KeyPath : CodingKeys.labelAlign, \Self.labelBaseline as KeyPath : CodingKeys.labelBaseline, \Self.labelColor as KeyPath : CodingKeys.labelColor, \Self.labelExpr as KeyPath : CodingKeys.labelExpr, \Self.labelFont as KeyPath : CodingKeys.labelFont, \Self.labelFontSize as KeyPath : CodingKeys.labelFontSize, \Self.labelFontStyle as KeyPath : CodingKeys.labelFontStyle, \Self.labelFontWeight as KeyPath : CodingKeys.labelFontWeight, \Self.labelLimit as KeyPath : CodingKeys.labelLimit, \Self.labelOffset as KeyPath : CodingKeys.labelOffset, \Self.labelOpacity as KeyPath : CodingKeys.labelOpacity, \Self.labelOverlap as KeyPath : CodingKeys.labelOverlap, \Self.labelPadding as KeyPath : CodingKeys.labelPadding, \Self.labelSeparation as KeyPath : CodingKeys.labelSeparation, \Self.legendX as KeyPath : CodingKeys.legendX, \Self.legendY as KeyPath : CodingKeys.legendY, \Self.offset as KeyPath : CodingKeys.offset, \Self.orient as KeyPath : CodingKeys.orient, \Self.padding as KeyPath : CodingKeys.padding, \Self.rowPadding as KeyPath : CodingKeys.rowPadding, \Self.strokeColor as KeyPath : CodingKeys.strokeColor, \Self.symbolDash as KeyPath : CodingKeys.symbolDash, \Self.symbolDashOffset as KeyPath : CodingKeys.symbolDashOffset, \Self.symbolFillColor as KeyPath : CodingKeys.symbolFillColor, \Self.symbolLimit as KeyPath : CodingKeys.symbolLimit, \Self.symbolOffset as KeyPath : CodingKeys.symbolOffset, \Self.symbolOpacity as KeyPath : CodingKeys.symbolOpacity, \Self.symbolSize as KeyPath : CodingKeys.symbolSize, \Self.symbolStrokeColor as KeyPath : CodingKeys.symbolStrokeColor, \Self.symbolStrokeWidth as KeyPath : CodingKeys.symbolStrokeWidth, \Self.symbolType as KeyPath : CodingKeys.symbolType, \Self.tickCount as KeyPath : CodingKeys.tickCount, \Self.tickMinStep as KeyPath : CodingKeys.tickMinStep, \Self.title as KeyPath : CodingKeys.title, \Self.titleAlign as KeyPath : CodingKeys.titleAlign, \Self.titleAnchor as KeyPath : CodingKeys.titleAnchor, \Self.titleBaseline as KeyPath : CodingKeys.titleBaseline, \Self.titleColor as KeyPath : CodingKeys.titleColor, \Self.titleFont as KeyPath : CodingKeys.titleFont, \Self.titleFontSize as KeyPath : CodingKeys.titleFontSize, \Self.titleFontStyle as KeyPath : CodingKeys.titleFontStyle, \Self.titleFontWeight as KeyPath : CodingKeys.titleFontWeight, \Self.titleLimit as KeyPath : CodingKeys.titleLimit, \Self.titleLineHeight as KeyPath : CodingKeys.titleLineHeight, \Self.titleOpacity as KeyPath : CodingKeys.titleOpacity, \Self.titleOrient as KeyPath : CodingKeys.titleOrient, \Self.titlePadding as KeyPath : CodingKeys.titlePadding, \Self.type as KeyPath : CodingKeys.type, \Self.values as KeyPath : CodingKeys.values, \Self.zindex as KeyPath : CodingKeys.zindex]

    public init(aria: AriaChoice? = nil, clipHeight: ClipHeightChoice? = nil, columnPadding: ColumnPaddingChoice? = nil, columns: ColumnsChoice? = nil, cornerRadius: CornerRadiusChoice? = nil, description: DescriptionChoice? = nil, direction: Orientation? = nil, fillColor: FillColorChoice? = nil, format: FormatChoice? = nil, formatType: String? = nil, gradientLength: GradientLengthChoice? = nil, gradientOpacity: GradientOpacityChoice? = nil, gradientStrokeColor: GradientStrokeColorChoice? = nil, gradientStrokeWidth: GradientStrokeWidthChoice? = nil, gradientThickness: GradientThicknessChoice? = nil, gridAlign: GridAlignChoice? = nil, labelAlign: LabelAlignChoice? = nil, labelBaseline: LabelBaselineChoice? = nil, labelColor: LabelColorChoice? = nil, labelExpr: Expr? = nil, labelFont: FontName? = nil, labelFontSize: LabelFontSizeChoice? = nil, labelFontStyle: LabelFontStyleChoice? = nil, labelFontWeight: LabelFontWeightChoice? = nil, labelLimit: LabelLimitChoice? = nil, labelOffset: LabelOffsetChoice? = nil, labelOpacity: LabelOpacityChoice? = nil, labelOverlap: LabelOverlapChoice? = nil, labelPadding: LabelPaddingChoice? = nil, labelSeparation: LabelSeparationChoice? = nil, legendX: LegendXChoice? = nil, legendY: LegendYChoice? = nil, offset: OffsetChoice? = nil, orient: LegendOrient? = nil, padding: PaddingChoice? = nil, rowPadding: RowPaddingChoice? = nil, strokeColor: StrokeColorChoice? = nil, symbolDash: SymbolDashChoice? = nil, symbolDashOffset: SymbolDashOffsetChoice? = nil, symbolFillColor: SymbolFillColorChoice? = nil, symbolLimit: SymbolLimitChoice? = nil, symbolOffset: SymbolOffsetChoice? = nil, symbolOpacity: SymbolOpacityChoice? = nil, symbolSize: SymbolSizeChoice? = nil, symbolStrokeColor: SymbolStrokeColorChoice? = nil, symbolStrokeWidth: SymbolStrokeWidthChoice? = nil, symbolType: SymbolTypeChoice? = nil, tickCount: TickCountChoice? = nil, tickMinStep: TickMinStepChoice? = nil, title: TitleChoice? = nil, titleAlign: TitleAlignChoice? = nil, titleAnchor: TitleAnchorChoice? = nil, titleBaseline: TitleBaselineChoice? = nil, titleColor: TitleColorChoice? = nil, titleFont: FontName? = nil, titleFontSize: TitleFontSizeChoice? = nil, titleFontStyle: TitleFontStyleChoice? = nil, titleFontWeight: TitleFontWeightChoice? = nil, titleLimit: TitleLimitChoice? = nil, titleLineHeight: TitleLineHeightChoice? = nil, titleOpacity: TitleOpacityChoice? = nil, titleOrient: TitleOrientChoice? = nil, titlePadding: TitlePaddingChoice? = nil, type: LiteralSymbolOrGradient? = nil, values: ValuesChoice? = nil, zindex: Double? = nil) {
        self.aria = aria 
        self.clipHeight = clipHeight 
        self.columnPadding = columnPadding 
        self.columns = columns 
        self.cornerRadius = cornerRadius 
        self.description = description 
        self.direction = direction 
        self.fillColor = fillColor 
        self.format = format 
        self.formatType = formatType 
        self.gradientLength = gradientLength 
        self.gradientOpacity = gradientOpacity 
        self.gradientStrokeColor = gradientStrokeColor 
        self.gradientStrokeWidth = gradientStrokeWidth 
        self.gradientThickness = gradientThickness 
        self.gridAlign = gridAlign 
        self.labelAlign = labelAlign 
        self.labelBaseline = labelBaseline 
        self.labelColor = labelColor 
        self.labelExpr = labelExpr 
        self.labelFont = labelFont 
        self.labelFontSize = labelFontSize 
        self.labelFontStyle = labelFontStyle 
        self.labelFontWeight = labelFontWeight 
        self.labelLimit = labelLimit 
        self.labelOffset = labelOffset 
        self.labelOpacity = labelOpacity 
        self.labelOverlap = labelOverlap 
        self.labelPadding = labelPadding 
        self.labelSeparation = labelSeparation 
        self.legendX = legendX 
        self.legendY = legendY 
        self.offset = offset 
        self.orient = orient 
        self.padding = padding 
        self.rowPadding = rowPadding 
        self.strokeColor = strokeColor 
        self.symbolDash = symbolDash 
        self.symbolDashOffset = symbolDashOffset 
        self.symbolFillColor = symbolFillColor 
        self.symbolLimit = symbolLimit 
        self.symbolOffset = symbolOffset 
        self.symbolOpacity = symbolOpacity 
        self.symbolSize = symbolSize 
        self.symbolStrokeColor = symbolStrokeColor 
        self.symbolStrokeWidth = symbolStrokeWidth 
        self.symbolType = symbolType 
        self.tickCount = tickCount 
        self.tickMinStep = tickMinStep 
        self.title = title 
        self.titleAlign = titleAlign 
        self.titleAnchor = titleAnchor 
        self.titleBaseline = titleBaseline 
        self.titleColor = titleColor 
        self.titleFont = titleFont 
        self.titleFontSize = titleFontSize 
        self.titleFontStyle = titleFontStyle 
        self.titleFontWeight = titleFontWeight 
        self.titleLimit = titleLimit 
        self.titleLineHeight = titleLineHeight 
        self.titleOpacity = titleOpacity 
        self.titleOrient = titleOrient 
        self.titlePadding = titlePadding 
        self.type = type 
        self.values = values 
        self.zindex = zindex 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.clipHeight = try values.decodeOptional(ClipHeightChoice.self, forKey: .clipHeight) 
        self.columnPadding = try values.decodeOptional(ColumnPaddingChoice.self, forKey: .columnPadding) 
        self.columns = try values.decodeOptional(ColumnsChoice.self, forKey: .columns) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.direction = try values.decodeOptional(Orientation.self, forKey: .direction) 
        self.fillColor = try values.decodeOptional(FillColorChoice.self, forKey: .fillColor) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.gradientLength = try values.decodeOptional(GradientLengthChoice.self, forKey: .gradientLength) 
        self.gradientOpacity = try values.decodeOptional(GradientOpacityChoice.self, forKey: .gradientOpacity) 
        self.gradientStrokeColor = try values.decodeOptional(GradientStrokeColorChoice.self, forKey: .gradientStrokeColor) 
        self.gradientStrokeWidth = try values.decodeOptional(GradientStrokeWidthChoice.self, forKey: .gradientStrokeWidth) 
        self.gradientThickness = try values.decodeOptional(GradientThicknessChoice.self, forKey: .gradientThickness) 
        self.gridAlign = try values.decodeOptional(GridAlignChoice.self, forKey: .gridAlign) 
        self.labelAlign = try values.decodeOptional(LabelAlignChoice.self, forKey: .labelAlign) 
        self.labelBaseline = try values.decodeOptional(LabelBaselineChoice.self, forKey: .labelBaseline) 
        self.labelColor = try values.decodeOptional(LabelColorChoice.self, forKey: .labelColor) 
        self.labelExpr = try values.decodeOptional(Expr.self, forKey: .labelExpr) 
        self.labelFont = try values.decodeOptional(FontName.self, forKey: .labelFont) 
        self.labelFontSize = try values.decodeOptional(LabelFontSizeChoice.self, forKey: .labelFontSize) 
        self.labelFontStyle = try values.decodeOptional(LabelFontStyleChoice.self, forKey: .labelFontStyle) 
        self.labelFontWeight = try values.decodeOptional(LabelFontWeightChoice.self, forKey: .labelFontWeight) 
        self.labelLimit = try values.decodeOptional(LabelLimitChoice.self, forKey: .labelLimit) 
        self.labelOffset = try values.decodeOptional(LabelOffsetChoice.self, forKey: .labelOffset) 
        self.labelOpacity = try values.decodeOptional(LabelOpacityChoice.self, forKey: .labelOpacity) 
        self.labelOverlap = try values.decodeOptional(LabelOverlapChoice.self, forKey: .labelOverlap) 
        self.labelPadding = try values.decodeOptional(LabelPaddingChoice.self, forKey: .labelPadding) 
        self.labelSeparation = try values.decodeOptional(LabelSeparationChoice.self, forKey: .labelSeparation) 
        self.legendX = try values.decodeOptional(LegendXChoice.self, forKey: .legendX) 
        self.legendY = try values.decodeOptional(LegendYChoice.self, forKey: .legendY) 
        self.offset = try values.decodeOptional(OffsetChoice.self, forKey: .offset) 
        self.orient = try values.decodeOptional(LegendOrient.self, forKey: .orient) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.rowPadding = try values.decodeOptional(RowPaddingChoice.self, forKey: .rowPadding) 
        self.strokeColor = try values.decodeOptional(StrokeColorChoice.self, forKey: .strokeColor) 
        self.symbolDash = try values.decodeOptional(SymbolDashChoice.self, forKey: .symbolDash) 
        self.symbolDashOffset = try values.decodeOptional(SymbolDashOffsetChoice.self, forKey: .symbolDashOffset) 
        self.symbolFillColor = try values.decodeOptional(SymbolFillColorChoice.self, forKey: .symbolFillColor) 
        self.symbolLimit = try values.decodeOptional(SymbolLimitChoice.self, forKey: .symbolLimit) 
        self.symbolOffset = try values.decodeOptional(SymbolOffsetChoice.self, forKey: .symbolOffset) 
        self.symbolOpacity = try values.decodeOptional(SymbolOpacityChoice.self, forKey: .symbolOpacity) 
        self.symbolSize = try values.decodeOptional(SymbolSizeChoice.self, forKey: .symbolSize) 
        self.symbolStrokeColor = try values.decodeOptional(SymbolStrokeColorChoice.self, forKey: .symbolStrokeColor) 
        self.symbolStrokeWidth = try values.decodeOptional(SymbolStrokeWidthChoice.self, forKey: .symbolStrokeWidth) 
        self.symbolType = try values.decodeOptional(SymbolTypeChoice.self, forKey: .symbolType) 
        self.tickCount = try values.decodeOptional(TickCountChoice.self, forKey: .tickCount) 
        self.tickMinStep = try values.decodeOptional(TickMinStepChoice.self, forKey: .tickMinStep) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.titleAlign = try values.decodeOptional(TitleAlignChoice.self, forKey: .titleAlign) 
        self.titleAnchor = try values.decodeOptional(TitleAnchorChoice.self, forKey: .titleAnchor) 
        self.titleBaseline = try values.decodeOptional(TitleBaselineChoice.self, forKey: .titleBaseline) 
        self.titleColor = try values.decodeOptional(TitleColorChoice.self, forKey: .titleColor) 
        self.titleFont = try values.decodeOptional(FontName.self, forKey: .titleFont) 
        self.titleFontSize = try values.decodeOptional(TitleFontSizeChoice.self, forKey: .titleFontSize) 
        self.titleFontStyle = try values.decodeOptional(TitleFontStyleChoice.self, forKey: .titleFontStyle) 
        self.titleFontWeight = try values.decodeOptional(TitleFontWeightChoice.self, forKey: .titleFontWeight) 
        self.titleLimit = try values.decodeOptional(TitleLimitChoice.self, forKey: .titleLimit) 
        self.titleLineHeight = try values.decodeOptional(TitleLineHeightChoice.self, forKey: .titleLineHeight) 
        self.titleOpacity = try values.decodeOptional(TitleOpacityChoice.self, forKey: .titleOpacity) 
        self.titleOrient = try values.decodeOptional(TitleOrientChoice.self, forKey: .titleOrient) 
        self.titlePadding = try values.decodeOptional(TitlePaddingChoice.self, forKey: .titlePadding) 
        self.type = try values.decodeOptional(LiteralSymbolOrGradient.self, forKey: .type) 
        self.values = try values.decodeOptional(ValuesChoice.self, forKey: .values) 
        self.zindex = try values.decodeOptional(Double.self, forKey: .zindex) 
    }

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias ClipHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ColumnPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ColumnsChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias FillColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Generated by Curio
    public typealias GradientLengthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientStrokeColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientStrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GradientThicknessChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias GridAlignChoice = OneOf<LayoutAlign>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelAlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelOverlapChoice = OneOf<LabelOverlap>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LabelSeparationChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LegendXChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LegendYChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias RowPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolFillColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolStrokeColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolStrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SymbolTypeChoice = OneOf<SymbolShape>.Or<ExprRef>

    /// Generated by Curio
    public typealias TickCountChoice = OneOf<TickCount>.Or<ExprRef>

    /// The minimum desired step between legend ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value.
    /// __Default value__: `undefined`
    /// Generated by Curio
    public typealias TickMinStepChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleAlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleAnchorChoice = OneOf<TitleAnchor>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleBaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    /// Generated by Curio
    public typealias TitleColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitleOrientChoice = OneOf<Orient>.Or<ExprRef>

    /// Generated by Curio
    public typealias TitlePaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Explicitly set the visible legend values.
    /// Generated by Curio
    public typealias ValuesChoice = OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[DateTime]>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aria
        case clipHeight
        case columnPadding
        case columns
        case cornerRadius
        case description
        case direction
        case fillColor
        case format
        case formatType
        case gradientLength
        case gradientOpacity
        case gradientStrokeColor
        case gradientStrokeWidth
        case gradientThickness
        case gridAlign
        case labelAlign
        case labelBaseline
        case labelColor
        case labelExpr
        case labelFont
        case labelFontSize
        case labelFontStyle
        case labelFontWeight
        case labelLimit
        case labelOffset
        case labelOpacity
        case labelOverlap
        case labelPadding
        case labelSeparation
        case legendX
        case legendY
        case offset
        case orient
        case padding
        case rowPadding
        case strokeColor
        case symbolDash
        case symbolDashOffset
        case symbolFillColor
        case symbolLimit
        case symbolOffset
        case symbolOpacity
        case symbolSize
        case symbolStrokeColor
        case symbolStrokeWidth
        case symbolType
        case tickCount
        case tickMinStep
        case title
        case titleAlign
        case titleAnchor
        case titleBaseline
        case titleColor
        case titleFont
        case titleFontSize
        case titleFontStyle
        case titleFontWeight
        case titleLimit
        case titleLineHeight
        case titleOpacity
        case titleOrient
        case titlePadding
        case type
        case values
        case zindex
        public var keyDescription: String? {
            switch self {
            case .aria: return nil
            case .clipHeight: return nil
            case .columnPadding: return nil
            case .columns: return nil
            case .cornerRadius: return nil
            case .description: return nil
            case .direction: return "The direction of the legend, one of `\"vertical\"` or `\"horizontal\"`.\n\n__Default value:__\n- For top-/bottom-`orient`ed legends, `\"horizontal\"`\n- For left-/right-`orient`ed legends, `\"vertical\"`\n- For top/bottom-left/right-`orient`ed legends, `\"horizontal\"` for gradient legends and `\"vertical\"` for symbol legends."
            case .fillColor: return nil
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .gradientLength: return nil
            case .gradientOpacity: return nil
            case .gradientStrokeColor: return nil
            case .gradientStrokeWidth: return nil
            case .gradientThickness: return nil
            case .gridAlign: return nil
            case .labelAlign: return nil
            case .labelBaseline: return nil
            case .labelColor: return nil
            case .labelExpr: return "[Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.\n\n__Note:__ The label text and value can be assessed via the `label` and `value` properties of the legend's backing `datum` object."
            case .labelFont: return nil
            case .labelFontSize: return nil
            case .labelFontStyle: return nil
            case .labelFontWeight: return nil
            case .labelLimit: return nil
            case .labelOffset: return nil
            case .labelOpacity: return nil
            case .labelOverlap: return nil
            case .labelPadding: return nil
            case .labelSeparation: return nil
            case .legendX: return nil
            case .legendY: return nil
            case .offset: return nil
            case .orient: return "The orientation of the legend, which determines how the legend is positioned within the scene. One of `\"left\"`, `\"right\"`, `\"top\"`, `\"bottom\"`, `\"top-left\"`, `\"top-right\"`, `\"bottom-left\"`, `\"bottom-right\"`, `\"none\"`.\n\n__Default value:__ `\"right\"`"
            case .padding: return nil
            case .rowPadding: return nil
            case .strokeColor: return nil
            case .symbolDash: return nil
            case .symbolDashOffset: return nil
            case .symbolFillColor: return nil
            case .symbolLimit: return nil
            case .symbolOffset: return nil
            case .symbolOpacity: return nil
            case .symbolSize: return nil
            case .symbolStrokeColor: return nil
            case .symbolStrokeWidth: return nil
            case .symbolType: return nil
            case .tickCount: return nil
            case .tickMinStep: return "The minimum desired step between legend ticks, in terms of scale domain values. For example, a value of `1` indicates that ticks should not be less than 1 unit apart. If `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to enforce the minimum step value.\n\n__Default value__: `undefined`"
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .titleAlign: return nil
            case .titleAnchor: return nil
            case .titleBaseline: return nil
            case .titleColor: return nil
            case .titleFont: return nil
            case .titleFontSize: return nil
            case .titleFontStyle: return nil
            case .titleFontWeight: return nil
            case .titleLimit: return nil
            case .titleLineHeight: return nil
            case .titleOpacity: return nil
            case .titleOrient: return nil
            case .titlePadding: return nil
            case .type: return "The type of the legend. Use `\"symbol\"` to create a discrete legend and `\"gradient\"` for a continuous color gradient.\n\n__Default value:__ `\"gradient\"` for non-binned quantitative fields and temporal fields; `\"symbol\"` otherwise."
            case .values: return "Explicitly set the visible legend values."
            case .zindex: return "A non-negative integer indicating the z-index of the legend. If zindex is 0, legend should be drawn behind all chart elements. To put them in front, use zindex = 1."
             } 
        }

        public typealias CodingOwner = LegendDef
    }

    /// The type of the legend. Use `"symbol"` to create a discrete legend and `"gradient"` for a continuous color gradient.
    /// __Default value:__ `"gradient"` for non-binned quantitative fields and temporal fields; `"symbol"` otherwise.
    /// Generated by Curio
    public enum LiteralSymbolOrGradient : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case symbol
        case gradient
    }
}

/// Generated by Curio
public struct LegendResolveMap : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var angle: ResolveMode?
    public var color: ResolveMode?
    public var fill: ResolveMode?
    public var fillOpacity: ResolveMode?
    public var opacity: ResolveMode?
    public var shape: ResolveMode?
    public var size: ResolveMode?
    public var stroke: ResolveMode?
    public var strokeDash: ResolveMode?
    public var strokeOpacity: ResolveMode?
    public var strokeWidth: ResolveMode?
    public static let codingKeyPaths = (\Self.angle as KeyPath, \Self.color as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.opacity as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.stroke as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.angle as KeyPath : CodingKeys.angle, \Self.color as KeyPath : CodingKeys.color, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth]

    public init(angle: ResolveMode? = nil, color: ResolveMode? = nil, fill: ResolveMode? = nil, fillOpacity: ResolveMode? = nil, opacity: ResolveMode? = nil, shape: ResolveMode? = nil, size: ResolveMode? = nil, stroke: ResolveMode? = nil, strokeDash: ResolveMode? = nil, strokeOpacity: ResolveMode? = nil, strokeWidth: ResolveMode? = nil) {
        self.angle = angle 
        self.color = color 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.opacity = opacity 
        self.shape = shape 
        self.size = size 
        self.stroke = stroke 
        self.strokeDash = strokeDash 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.angle = try values.decodeOptional(ResolveMode.self, forKey: .angle) 
        self.color = try values.decodeOptional(ResolveMode.self, forKey: .color) 
        self.fill = try values.decodeOptional(ResolveMode.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(ResolveMode.self, forKey: .fillOpacity) 
        self.opacity = try values.decodeOptional(ResolveMode.self, forKey: .opacity) 
        self.shape = try values.decodeOptional(ResolveMode.self, forKey: .shape) 
        self.size = try values.decodeOptional(ResolveMode.self, forKey: .size) 
        self.stroke = try values.decodeOptional(ResolveMode.self, forKey: .stroke) 
        self.strokeDash = try values.decodeOptional(ResolveMode.self, forKey: .strokeDash) 
        self.strokeOpacity = try values.decodeOptional(ResolveMode.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(ResolveMode.self, forKey: .strokeWidth) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case angle
        case color
        case fill
        case fillOpacity
        case opacity
        case shape
        case size
        case stroke
        case strokeDash
        case strokeOpacity
        case strokeWidth
        public var keyDescription: String? {
            switch self {
            case .angle: return nil
            case .color: return nil
            case .fill: return nil
            case .fillOpacity: return nil
            case .opacity: return nil
            case .shape: return nil
            case .size: return nil
            case .stroke: return nil
            case .strokeDash: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
             } 
        }

        public typealias CodingOwner = LegendResolveMap
    }
}

/// Generated by Curio
public struct LegendStreamBinding : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var legend: LegendChoice
    public static let codingKeyPaths = (\Self.legend as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.legend as KeyPath : CodingKeys.legend]

    public init(legend: LegendChoice) {
        self.legend = legend 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.legend = try values.decode(LegendChoice.self, forKey: .legend) 
    }

    /// Generated by Curio
    public typealias LegendChoice = OneOf<String>.Or<Stream>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case legend
        public var keyDescription: String? {
            switch self {
            case .legend: return nil
             } 
        }

        public typealias CodingOwner = LegendStreamBinding
    }
}

/// Generated by Curio
public struct LineConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var align: AlignChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    public var ariaRole: AriaRoleChoice?
    public var ariaRoleDescription: AriaRoleDescriptionChoice?
    public var aspect: AspectChoice?
    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var baseline: BaselineChoice?
    public var blend: BlendChoice?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    public var cornerRadius: CornerRadiusChoice?
    public var cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice?
    public var cornerRadiusBottomRight: CornerRadiusBottomRightChoice?
    public var cornerRadiusTopLeft: CornerRadiusTopLeftChoice?
    public var cornerRadiusTopRight: CornerRadiusTopRightChoice?
    public var cursor: CursorChoice?
    public var description: DescriptionChoice?
    public var dir: DirChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var ellipsis: EllipsisChoice?
    public var endAngle: EndAngleChoice?
    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// Whether the mark's color should be used as fill color instead of stroke color.
    /// __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.
    /// __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    public var filled: Bool?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var height: HeightChoice?
    public var href: HrefChoice?
    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    public var innerRadius: InnerRadiusChoice?
    public var interpolate: InterpolateChoice?
    /// Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
    /// - If set to `"filter"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).
    /// - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
    public var invalid: Invalid?
    public var limit: LimitChoice?
    public var lineBreak: LineBreakChoice?
    public var lineHeight: LineHeightChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources.
    public var order: Order?
    /// The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored.
    public var orient: Orientation?
    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    public var outerRadius: OuterRadiusChoice?
    public var padAngle: PadAngleChoice?
    /// A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.
    /// - If this property is `"transparent"`, transparent points will be used (for enhancing tooltips and selections).
    /// - If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.
    /// - If this property is `false`, no points would be automatically added to line or area marks.
    /// __Default value:__ `false`.
    public var point: PointChoice?
    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    public var radius: RadiusChoice?
    /// The secondary (inner) radius in pixels of arc marks.
    public var radius2: Radius2Choice?
    public var shape: SymbolShape?
    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    public var size: SizeChoice?
    public var smooth: SmoothChoice?
    public var startAngle: StartAngleChoice?
    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOffset: StrokeOffsetChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    public var tension: TensionChoice?
    public var text: TextChoice?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaChoice?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Choice?
    /// Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step.
    public var timeUnitBandPosition: Double?
    /// Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step.
    public var timeUnitBandSize: Double?
    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    public var tooltip: TooltipChoice?
    public var url: UrlChoice?
    public var width: WidthChoice?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XChoice?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Choice?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YChoice?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Choice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.aspect as KeyPath, \Self.baseline as KeyPath, \Self.blend as KeyPath, \Self.color as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cursor as KeyPath, \Self.description as KeyPath, \Self.dir as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.ellipsis as KeyPath, \Self.endAngle as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.filled as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.height as KeyPath, \Self.href as KeyPath, \Self.innerRadius as KeyPath, \Self.interpolate as KeyPath, \Self.invalid as KeyPath, \Self.limit as KeyPath, \Self.lineBreak as KeyPath, \Self.lineHeight as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.orient as KeyPath, \Self.outerRadius as KeyPath, \Self.padAngle as KeyPath, \Self.point as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.smooth as KeyPath, \Self.startAngle as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.tension as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.timeUnitBandPosition as KeyPath, \Self.timeUnitBandSize as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.width as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.blend as KeyPath : CodingKeys.blend, \Self.color as KeyPath : CodingKeys.color, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.description as KeyPath : CodingKeys.description, \Self.dir as KeyPath : CodingKeys.dir, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.endAngle as KeyPath : CodingKeys.endAngle, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.filled as KeyPath : CodingKeys.filled, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.height as KeyPath : CodingKeys.height, \Self.href as KeyPath : CodingKeys.href, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.invalid as KeyPath : CodingKeys.invalid, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.orient as KeyPath : CodingKeys.orient, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.point as KeyPath : CodingKeys.point, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.startAngle as KeyPath : CodingKeys.startAngle, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.tension as KeyPath : CodingKeys.tension, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.timeUnitBandPosition as KeyPath : CodingKeys.timeUnitBandPosition, \Self.timeUnitBandSize as KeyPath : CodingKeys.timeUnitBandSize, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.width as KeyPath : CodingKeys.width, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2]

    public init(align: AlignChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, ariaRole: AriaRoleChoice? = nil, ariaRoleDescription: AriaRoleDescriptionChoice? = nil, aspect: AspectChoice? = nil, baseline: BaselineChoice? = nil, blend: BlendChoice? = nil, color: ColorChoice? = nil, cornerRadius: CornerRadiusChoice? = nil, cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice? = nil, cornerRadiusBottomRight: CornerRadiusBottomRightChoice? = nil, cornerRadiusTopLeft: CornerRadiusTopLeftChoice? = nil, cornerRadiusTopRight: CornerRadiusTopRightChoice? = nil, cursor: CursorChoice? = nil, description: DescriptionChoice? = nil, dir: DirChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, ellipsis: EllipsisChoice? = nil, endAngle: EndAngleChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, filled: Bool? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, height: HeightChoice? = nil, href: HrefChoice? = nil, innerRadius: InnerRadiusChoice? = nil, interpolate: InterpolateChoice? = nil, invalid: Invalid? = nil, limit: LimitChoice? = nil, lineBreak: LineBreakChoice? = nil, lineHeight: LineHeightChoice? = nil, opacity: OpacityChoice? = nil, order: Order? = nil, orient: Orientation? = nil, outerRadius: OuterRadiusChoice? = nil, padAngle: PadAngleChoice? = nil, point: PointChoice? = nil, radius: RadiusChoice? = nil, radius2: Radius2Choice? = nil, shape: SymbolShape? = nil, size: SizeChoice? = nil, smooth: SmoothChoice? = nil, startAngle: StartAngleChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOffset: StrokeOffsetChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, tension: TensionChoice? = nil, text: TextChoice? = nil, theta: ThetaChoice? = nil, theta2: Theta2Choice? = nil, timeUnitBandPosition: Double? = nil, timeUnitBandSize: Double? = nil, tooltip: TooltipChoice? = nil, url: UrlChoice? = nil, width: WidthChoice? = nil, x: XChoice? = nil, x2: X2Choice? = nil, y: YChoice? = nil, y2: Y2Choice? = nil) {
        self.align = align 
        self.angle = angle 
        self.aria = aria 
        self.ariaRole = ariaRole 
        self.ariaRoleDescription = ariaRoleDescription 
        self.aspect = aspect 
        self.baseline = baseline 
        self.blend = blend 
        self.color = color 
        self.cornerRadius = cornerRadius 
        self.cornerRadiusBottomLeft = cornerRadiusBottomLeft 
        self.cornerRadiusBottomRight = cornerRadiusBottomRight 
        self.cornerRadiusTopLeft = cornerRadiusTopLeft 
        self.cornerRadiusTopRight = cornerRadiusTopRight 
        self.cursor = cursor 
        self.description = description 
        self.dir = dir 
        self.dx = dx 
        self.dy = dy 
        self.ellipsis = ellipsis 
        self.endAngle = endAngle 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.filled = filled 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.height = height 
        self.href = href 
        self.innerRadius = innerRadius 
        self.interpolate = interpolate 
        self.invalid = invalid 
        self.limit = limit 
        self.lineBreak = lineBreak 
        self.lineHeight = lineHeight 
        self.opacity = opacity 
        self.order = order 
        self.orient = orient 
        self.outerRadius = outerRadius 
        self.padAngle = padAngle 
        self.point = point 
        self.radius = radius 
        self.radius2 = radius2 
        self.shape = shape 
        self.size = size 
        self.smooth = smooth 
        self.startAngle = startAngle 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOffset = strokeOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.tension = tension 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.timeUnitBandPosition = timeUnitBandPosition 
        self.timeUnitBandSize = timeUnitBandSize 
        self.tooltip = tooltip 
        self.url = url 
        self.width = width 
        self.x = x 
        self.x2 = x2 
        self.y = y 
        self.y2 = y2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.ariaRole = try values.decodeOptional(AriaRoleChoice.self, forKey: .ariaRole) 
        self.ariaRoleDescription = try values.decodeOptional(AriaRoleDescriptionChoice.self, forKey: .ariaRoleDescription) 
        self.aspect = try values.decodeOptional(AspectChoice.self, forKey: .aspect) 
        self.baseline = try values.decodeOptional(BaselineChoice.self, forKey: .baseline) 
        self.blend = try values.decodeOptional(BlendChoice.self, forKey: .blend) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cornerRadiusBottomLeft = try values.decodeOptional(CornerRadiusBottomLeftChoice.self, forKey: .cornerRadiusBottomLeft) 
        self.cornerRadiusBottomRight = try values.decodeOptional(CornerRadiusBottomRightChoice.self, forKey: .cornerRadiusBottomRight) 
        self.cornerRadiusTopLeft = try values.decodeOptional(CornerRadiusTopLeftChoice.self, forKey: .cornerRadiusTopLeft) 
        self.cornerRadiusTopRight = try values.decodeOptional(CornerRadiusTopRightChoice.self, forKey: .cornerRadiusTopRight) 
        self.cursor = try values.decodeOptional(CursorChoice.self, forKey: .cursor) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.dir = try values.decodeOptional(DirChoice.self, forKey: .dir) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.ellipsis = try values.decodeOptional(EllipsisChoice.self, forKey: .ellipsis) 
        self.endAngle = try values.decodeOptional(EndAngleChoice.self, forKey: .endAngle) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.filled = try values.decodeOptional(Bool.self, forKey: .filled) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.href = try values.decodeOptional(HrefChoice.self, forKey: .href) 
        self.innerRadius = try values.decodeOptional(InnerRadiusChoice.self, forKey: .innerRadius) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.invalid = try values.decodeOptional(Invalid.self, forKey: .invalid) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.order = try values.decodeOptional(Order.self, forKey: .order) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outerRadius = try values.decodeOptional(OuterRadiusChoice.self, forKey: .outerRadius) 
        self.padAngle = try values.decodeOptional(PadAngleChoice.self, forKey: .padAngle) 
        self.point = try values.decodeOptional(PointChoice.self, forKey: .point) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Choice.self, forKey: .radius2) 
        self.shape = try values.decodeOptional(SymbolShape.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.smooth = try values.decodeOptional(SmoothChoice.self, forKey: .smooth) 
        self.startAngle = try values.decodeOptional(StartAngleChoice.self, forKey: .startAngle) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOffset = try values.decodeOptional(StrokeOffsetChoice.self, forKey: .strokeOffset) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.tension = try values.decodeOptional(TensionChoice.self, forKey: .tension) 
        self.text = try values.decodeOptional(TextChoice.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaChoice.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Choice.self, forKey: .theta2) 
        self.timeUnitBandPosition = try values.decodeOptional(Double.self, forKey: .timeUnitBandPosition) 
        self.timeUnitBandSize = try values.decodeOptional(Double.self, forKey: .timeUnitBandSize) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlChoice.self, forKey: .url) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
        self.x = try values.decodeOptional(XChoice.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Choice.self, forKey: .x2) 
        self.y = try values.decodeOptional(YChoice.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Choice.self, forKey: .y2) 
    }

    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleDescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AspectChoice = OneOf<Bool>.Or<ExprRef>

    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias BaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias BlendChoice = OneOf<Blend>.Or<ExprRef>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CursorChoice = OneOf<Cursor>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DirChoice = OneOf<TextDirection>.Or<ExprRef>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias EllipsisChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias EndAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias HrefChoice = OneOf<URI>.Or<ExprRef>

    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    /// Generated by Curio
    public typealias InnerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<Interpolate>.Or<ExprRef>

    /// Generated by Curio
    public typealias Invalid = Nullable<String>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias Order = Nullable<Bool>

    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    /// Generated by Curio
    public typealias OuterRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PadAngleChoice = OneOf<Double>.Or<ExprRef>

    /// A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.
    /// - If this property is `"transparent"`, transparent points will be used (for enhancing tooltips and selections).
    /// - If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.
    /// - If this property is `false`, no points would be automatically added to line or area marks.
    /// __Default value:__ `false`.
    /// Generated by Curio
    public typealias PointChoice = OneOf<Bool>.Or<OverlayMarkDef>.Or<LiteralTransparent>

    /// The secondary (inner) radius in pixels of arc marks.
    /// Generated by Curio
    public typealias Radius2Choice = OneOf<Double>.Or<ExprRef>

    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    /// Generated by Curio
    public typealias SizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SmoothChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias StartAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TensionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    /// Generated by Curio
    public typealias Theta2Choice = OneOf<Double>.Or<ExprRef>

    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    /// Generated by Curio
    public typealias ThetaChoice = OneOf<Double>.Or<ExprRef>

    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<Double>.Or<String>.Or<Bool>.Or<TooltipContent>.Or<ExprRef>>

    /// Generated by Curio
    public typealias UrlChoice = OneOf<URI>.Or<ExprRef>

    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<ExprRef>

    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias X2Choice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias XChoice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias Y2Choice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias YChoice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case angle
        case aria
        case ariaRole
        case ariaRoleDescription
        case aspect
        case baseline
        case blend
        case color
        case cornerRadius
        case cornerRadiusBottomLeft
        case cornerRadiusBottomRight
        case cornerRadiusTopLeft
        case cornerRadiusTopRight
        case cursor
        case description
        case dir
        case dx
        case dy
        case ellipsis
        case endAngle
        case fill
        case fillOpacity
        case filled
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case height
        case href
        case innerRadius
        case interpolate
        case invalid
        case limit
        case lineBreak
        case lineHeight
        case opacity
        case order
        case orient
        case outerRadius
        case padAngle
        case point
        case radius
        case radius2
        case shape
        case size
        case smooth
        case startAngle
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOffset
        case strokeOpacity
        case strokeWidth
        case tension
        case text
        case theta
        case theta2
        case timeUnitBandPosition
        case timeUnitBandSize
        case tooltip
        case url
        case width
        case x
        case x2
        case y
        case y2
        public var keyDescription: String? {
            switch self {
            case .align: return "The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `\"left\"`, `\"right\"`, `\"center\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .angle: return nil
            case .aria: return nil
            case .ariaRole: return nil
            case .ariaRoleDescription: return nil
            case .aspect: return nil
            case .baseline: return "For text marks, the vertical text baseline. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, `\"line-bottom\"`, or an expression reference that provides one of the valid values. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.\n\nFor range marks, the vertical alignment of the marks. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .blend: return nil
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .cornerRadius: return nil
            case .cornerRadiusBottomLeft: return nil
            case .cornerRadiusBottomRight: return nil
            case .cornerRadiusTopLeft: return nil
            case .cornerRadiusTopRight: return nil
            case .cursor: return nil
            case .description: return nil
            case .dir: return nil
            case .dx: return nil
            case .dy: return nil
            case .ellipsis: return nil
            case .endAngle: return nil
            case .fill: return "Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.\n\n__Default value:__ (None)"
            case .fillOpacity: return nil
            case .filled: return "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.\n\n__Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config)."
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .height: return nil
            case .href: return nil
            case .innerRadius: return "The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`."
            case .interpolate: return nil
            case .invalid: return "Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes."
            case .limit: return nil
            case .lineBreak: return nil
            case .lineHeight: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .order: return "For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources."
            case .orient: return "The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored."
            case .outerRadius: return "The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`."
            case .padAngle: return nil
            case .point: return "A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.\n\n- If this property is `\"transparent\"`, transparent points will be used (for enhancing tooltips and selections).\n\n- If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.\n\n- If this property is `false`, no points would be automatically added to line or area marks.\n\n__Default value:__ `false`."
            case .radius: return "For arc mark, the primary (outer) radius in pixels.\n\nFor text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties."
            case .radius2: return "The secondary (inner) radius in pixels of arc marks."
            case .shape: return nil
            case .size: return "Default size for marks.\n- For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.\n- For `bar`, this represents the band size of the bar, in pixels.\n- For `text`, this represents the font size, in pixels.\n\n__Default value:__\n- `30` for point, circle, square marks; width/height's `step`\n- `2` for bar marks with discrete dimensions;\n- `5` for bar marks with continuous dimensions;\n- `11` for text marks."
            case .smooth: return nil
            case .startAngle: return nil
            case .stroke: return "Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.\n\n__Default value:__ (None)"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOffset: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .tension: return nil
            case .text: return nil
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .timeUnitBandPosition: return "Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step."
            case .timeUnitBandSize: return "Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step."
            case .tooltip: return "The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n\n- If `tooltip` is `true` or `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n- If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n- If set to `null` or `false`, then no tooltip will be used.\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.\n\n__Default value:__ `null`"
            case .url: return nil
            case .width: return nil
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
             } 
        }

        public typealias CodingOwner = LineConfig
    }
}

/// Generated by Curio
public struct Locale : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var number: NumberLocale?
    public var time: TimeLocale?
    public static let codingKeyPaths = (\Self.number as KeyPath, \Self.time as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.number as KeyPath : CodingKeys.number, \Self.time as KeyPath : CodingKeys.time]

    public init(number: NumberLocale? = nil, time: TimeLocale? = nil) {
        self.number = number 
        self.time = time 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.number = try values.decodeOptional(NumberLocale.self, forKey: .number) 
        self.time = try values.decodeOptional(TimeLocale.self, forKey: .time) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case number
        case time
        public var keyDescription: String? {
            switch self {
            case .number: return nil
            case .time: return nil
             } 
        }

        public typealias CodingOwner = Locale
    }
}

/// Generated by Curio
public struct LoessTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output field names for the smoothed points generated by the loess transform.
    /// __Default value:__ The field names of the input x and y values.
    public var `as`: [FieldName]?
    /// A bandwidth parameter in the range `[0, 1]` that determines the amount of smoothing.
    /// __Default value:__ `0.3`
    public var bandwidth: Double?
    /// The data fields to group by. If not specified, a single group containing all data objects will be used.
    public var groupby: [FieldName]?
    /// The data field of the dependent variable to smooth.
    public var loess: FieldName
    /// The data field of the independent variable to use a predictor.
    public var on: FieldName
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.bandwidth as KeyPath, \Self.groupby as KeyPath, \Self.loess as KeyPath, \Self.on as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.bandwidth as KeyPath : CodingKeys.bandwidth, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.loess as KeyPath : CodingKeys.loess, \Self.on as KeyPath : CodingKeys.on]

    public init(id: TransformId? = nil, `as`: [FieldName]? = nil, bandwidth: Double? = nil, groupby: [FieldName]? = nil, loess: FieldName, on: FieldName) {
        self.id = id 
        self.`as` = `as` 
        self.bandwidth = bandwidth 
        self.groupby = groupby 
        self.loess = loess 
        self.on = on 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decodeOptional([FieldName].self, forKey: .`as`) 
        self.bandwidth = try values.decodeOptional(Double.self, forKey: .bandwidth) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
        self.loess = try values.decode(FieldName.self, forKey: .loess) 
        self.on = try values.decode(FieldName.self, forKey: .on) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case bandwidth
        case groupby
        case loess
        case on
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output field names for the smoothed points generated by the loess transform.\n\n__Default value:__ The field names of the input x and y values."
            case .bandwidth: return "A bandwidth parameter in the range `[0, 1]` that determines the amount of smoothing.\n\n__Default value:__ `0.3`"
            case .groupby: return "The data fields to group by. If not specified, a single group containing all data objects will be used."
            case .loess: return "The data field of the dependent variable to smooth."
            case .on: return "The data field of the independent variable to use a predictor."
             } 
        }

        public typealias CodingOwner = LoessTransform
    }
}

/// Generated by Curio
public struct LogicalAndPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var and: [PredicateComposition]
    public static let codingKeyPaths = (\Self.and as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.and as KeyPath : CodingKeys.and]

    public init(and: [PredicateComposition] = []) {
        self.and = and 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.and = try values.decode([PredicateComposition].self, forKey: .and) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case and
        public var keyDescription: String? {
            switch self {
            case .and: return nil
             } 
        }

        public typealias CodingOwner = LogicalAndPredicate
    }
}

/// Generated by Curio
public struct LogicalNotPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var not: PredicateComposition
    public static let codingKeyPaths = (\Self.not as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.not as KeyPath : CodingKeys.not]

    public init(not: PredicateComposition) {
        self.not = not 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.not = try values.decode(PredicateComposition.self, forKey: .not) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case not
        public var keyDescription: String? {
            switch self {
            case .not: return nil
             } 
        }

        public typealias CodingOwner = LogicalNotPredicate
    }
}

/// Generated by Curio
public struct LogicalOrPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var or: [PredicateComposition]
    public static let codingKeyPaths = (\Self.or as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.or as KeyPath : CodingKeys.or]

    public init(or: [PredicateComposition] = []) {
        self.or = or 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.or = try values.decode([PredicateComposition].self, forKey: .or) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case or
        public var keyDescription: String? {
            switch self {
            case .or: return nil
             } 
        }

        public typealias CodingOwner = LogicalOrPredicate
    }
}

/// Generated by Curio
public struct LookupData : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Secondary data source to lookup in.
    public var data: DataProvider
    /// Fields in foreign data or selection to lookup. If not specified, the entire object is queried.
    public var fields: [FieldName]?
    /// Key in data to lookup.
    public var key: FieldName
    public static let codingKeyPaths = (\Self.data as KeyPath, \Self.fields as KeyPath, \Self.key as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.data as KeyPath : CodingKeys.data, \Self.fields as KeyPath : CodingKeys.fields, \Self.key as KeyPath : CodingKeys.key]

    public init(data: DataProvider, fields: [FieldName]? = nil, key: FieldName) {
        self.data = data 
        self.fields = fields 
        self.key = key 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.data = try values.decode(DataProvider.self, forKey: .data) 
        self.fields = try values.decodeOptional([FieldName].self, forKey: .fields) 
        self.key = try values.decode(FieldName.self, forKey: .key) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case data
        case fields
        case key
        public var keyDescription: String? {
            switch self {
            case .data: return "Secondary data source to lookup in."
            case .fields: return "Fields in foreign data or selection to lookup. If not specified, the entire object is queried."
            case .key: return "Key in data to lookup."
             } 
        }

        public typealias CodingOwner = LookupData
    }
}

/// Generated by Curio
public struct LookupSelection : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Fields in foreign data or selection to lookup. If not specified, the entire object is queried.
    public var fields: [FieldName]?
    /// Key in data to lookup.
    public var key: FieldName
    /// Selection parameter name to look up.
    public var param: ParameterName
    public static let codingKeyPaths = (\Self.fields as KeyPath, \Self.key as KeyPath, \Self.param as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.fields as KeyPath : CodingKeys.fields, \Self.key as KeyPath : CodingKeys.key, \Self.param as KeyPath : CodingKeys.param]

    public init(fields: [FieldName]? = nil, key: FieldName, param: ParameterName) {
        self.fields = fields 
        self.key = key 
        self.param = param 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.fields = try values.decodeOptional([FieldName].self, forKey: .fields) 
        self.key = try values.decode(FieldName.self, forKey: .key) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case fields
        case key
        case param
        public var keyDescription: String? {
            switch self {
            case .fields: return "Fields in foreign data or selection to lookup. If not specified, the entire object is queried."
            case .key: return "Key in data to lookup."
            case .param: return "Selection parameter name to look up."
             } 
        }

        public typealias CodingOwner = LookupSelection
    }
}

/// Generated by Curio
public struct LookupTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output fields on which to store the looked up data values.
    /// For data lookups, this property may be left blank if `from.fields` has been specified (those field names will be used); if `from.fields` has not been specified, `as` must be a string.
    /// For selection lookups, this property is optional: if unspecified, looked up values will be stored under a property named for the selection; and if specified, it must correspond to `from.fields`.
    public var `as`: AsChoice?
    /// The default value to use if lookup fails.
    /// __Default value:__ `null`
    public var `default`: Bric?
    /// Data source or selection for secondary data reference.
    public var from: FromChoice
    /// Key in primary data source.
    public var lookup: FieldName
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.`default` as KeyPath, \Self.from as KeyPath, \Self.lookup as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.`default` as KeyPath : CodingKeys.`default`, \Self.from as KeyPath : CodingKeys.from, \Self.lookup as KeyPath : CodingKeys.lookup]

    public init(id: TransformId? = nil, `as`: AsChoice? = nil, `default`: Bric? = nil, from: FromChoice, lookup: FieldName) {
        self.id = id 
        self.`as` = `as` 
        self.`default` = `default` 
        self.from = from 
        self.lookup = lookup 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decodeOptional(AsChoice.self, forKey: .`as`) 
        self.`default` = try values.decodeOptional(Bric.self, forKey: .`default`) 
        self.from = try values.decode(FromChoice.self, forKey: .from) 
        self.lookup = try values.decode(FieldName.self, forKey: .lookup) 
    }

    /// The output fields on which to store the looked up data values.
    /// For data lookups, this property may be left blank if `from.fields` has been specified (those field names will be used); if `from.fields` has not been specified, `as` must be a string.
    /// For selection lookups, this property is optional: if unspecified, looked up values will be stored under a property named for the selection; and if specified, it must correspond to `from.fields`.
    /// Generated by Curio
    public typealias AsChoice = OneOrMany<FieldName>

    /// Data source or selection for secondary data reference.
    /// Generated by Curio
    public typealias FromChoice = OneOf<LookupData>.Or<LookupSelection>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case `default`
        case from
        case lookup
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output fields on which to store the looked up data values.\n\nFor data lookups, this property may be left blank if `from.fields` has been specified (those field names will be used); if `from.fields` has not been specified, `as` must be a string.\n\nFor selection lookups, this property is optional: if unspecified, looked up values will be stored under a property named for the selection; and if specified, it must correspond to `from.fields`."
            case .`default`: return "The default value to use if lookup fails.\n\n__Default value:__ `null`"
            case .from: return "Data source or selection for secondary data reference."
            case .lookup: return "Key in primary data source."
             } 
        }

        public typealias CodingOwner = LookupTransform
    }
}

/// Generated by Curio
public struct MarkConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var align: AlignChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    public var ariaRole: AriaRoleChoice?
    public var ariaRoleDescription: AriaRoleDescriptionChoice?
    public var aspect: AspectChoice?
    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var baseline: BaselineChoice?
    public var blend: BlendChoice?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    public var cornerRadius: CornerRadiusChoice?
    public var cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice?
    public var cornerRadiusBottomRight: CornerRadiusBottomRightChoice?
    public var cornerRadiusTopLeft: CornerRadiusTopLeftChoice?
    public var cornerRadiusTopRight: CornerRadiusTopRightChoice?
    public var cursor: CursorChoice?
    public var description: DescriptionChoice?
    public var dir: DirChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var ellipsis: EllipsisChoice?
    public var endAngle: EndAngleChoice?
    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// Whether the mark's color should be used as fill color instead of stroke color.
    /// __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.
    /// __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    public var filled: Bool?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var height: HeightChoice?
    public var href: HrefChoice?
    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    public var innerRadius: InnerRadiusChoice?
    public var interpolate: InterpolateChoice?
    /// Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
    /// - If set to `"filter"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).
    /// - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
    public var invalid: Invalid?
    public var limit: LimitChoice?
    public var lineBreak: LineBreakChoice?
    public var lineHeight: LineHeightChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources.
    public var order: Order?
    /// The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored.
    public var orient: Orientation?
    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    public var outerRadius: OuterRadiusChoice?
    public var padAngle: PadAngleChoice?
    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    public var radius: RadiusChoice?
    /// The secondary (inner) radius in pixels of arc marks.
    public var radius2: Radius2Choice?
    public var shape: SymbolShape?
    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    public var size: SizeChoice?
    public var smooth: SmoothChoice?
    public var startAngle: StartAngleChoice?
    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOffset: StrokeOffsetChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    public var tension: TensionChoice?
    public var text: TextChoice?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaChoice?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Choice?
    /// Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step.
    public var timeUnitBandPosition: Double?
    /// Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step.
    public var timeUnitBandSize: Double?
    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    public var tooltip: TooltipChoice?
    public var url: UrlChoice?
    public var width: WidthChoice?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XChoice?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Choice?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YChoice?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Choice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.aspect as KeyPath, \Self.baseline as KeyPath, \Self.blend as KeyPath, \Self.color as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cursor as KeyPath, \Self.description as KeyPath, \Self.dir as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.ellipsis as KeyPath, \Self.endAngle as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.filled as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.height as KeyPath, \Self.href as KeyPath, \Self.innerRadius as KeyPath, \Self.interpolate as KeyPath, \Self.invalid as KeyPath, \Self.limit as KeyPath, \Self.lineBreak as KeyPath, \Self.lineHeight as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.orient as KeyPath, \Self.outerRadius as KeyPath, \Self.padAngle as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.smooth as KeyPath, \Self.startAngle as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.tension as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.timeUnitBandPosition as KeyPath, \Self.timeUnitBandSize as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.width as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.blend as KeyPath : CodingKeys.blend, \Self.color as KeyPath : CodingKeys.color, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.description as KeyPath : CodingKeys.description, \Self.dir as KeyPath : CodingKeys.dir, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.endAngle as KeyPath : CodingKeys.endAngle, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.filled as KeyPath : CodingKeys.filled, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.height as KeyPath : CodingKeys.height, \Self.href as KeyPath : CodingKeys.href, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.invalid as KeyPath : CodingKeys.invalid, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.orient as KeyPath : CodingKeys.orient, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.startAngle as KeyPath : CodingKeys.startAngle, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.tension as KeyPath : CodingKeys.tension, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.timeUnitBandPosition as KeyPath : CodingKeys.timeUnitBandPosition, \Self.timeUnitBandSize as KeyPath : CodingKeys.timeUnitBandSize, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.width as KeyPath : CodingKeys.width, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2]

    public init(align: AlignChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, ariaRole: AriaRoleChoice? = nil, ariaRoleDescription: AriaRoleDescriptionChoice? = nil, aspect: AspectChoice? = nil, baseline: BaselineChoice? = nil, blend: BlendChoice? = nil, color: ColorChoice? = nil, cornerRadius: CornerRadiusChoice? = nil, cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice? = nil, cornerRadiusBottomRight: CornerRadiusBottomRightChoice? = nil, cornerRadiusTopLeft: CornerRadiusTopLeftChoice? = nil, cornerRadiusTopRight: CornerRadiusTopRightChoice? = nil, cursor: CursorChoice? = nil, description: DescriptionChoice? = nil, dir: DirChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, ellipsis: EllipsisChoice? = nil, endAngle: EndAngleChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, filled: Bool? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, height: HeightChoice? = nil, href: HrefChoice? = nil, innerRadius: InnerRadiusChoice? = nil, interpolate: InterpolateChoice? = nil, invalid: Invalid? = nil, limit: LimitChoice? = nil, lineBreak: LineBreakChoice? = nil, lineHeight: LineHeightChoice? = nil, opacity: OpacityChoice? = nil, order: Order? = nil, orient: Orientation? = nil, outerRadius: OuterRadiusChoice? = nil, padAngle: PadAngleChoice? = nil, radius: RadiusChoice? = nil, radius2: Radius2Choice? = nil, shape: SymbolShape? = nil, size: SizeChoice? = nil, smooth: SmoothChoice? = nil, startAngle: StartAngleChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOffset: StrokeOffsetChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, tension: TensionChoice? = nil, text: TextChoice? = nil, theta: ThetaChoice? = nil, theta2: Theta2Choice? = nil, timeUnitBandPosition: Double? = nil, timeUnitBandSize: Double? = nil, tooltip: TooltipChoice? = nil, url: UrlChoice? = nil, width: WidthChoice? = nil, x: XChoice? = nil, x2: X2Choice? = nil, y: YChoice? = nil, y2: Y2Choice? = nil) {
        self.align = align 
        self.angle = angle 
        self.aria = aria 
        self.ariaRole = ariaRole 
        self.ariaRoleDescription = ariaRoleDescription 
        self.aspect = aspect 
        self.baseline = baseline 
        self.blend = blend 
        self.color = color 
        self.cornerRadius = cornerRadius 
        self.cornerRadiusBottomLeft = cornerRadiusBottomLeft 
        self.cornerRadiusBottomRight = cornerRadiusBottomRight 
        self.cornerRadiusTopLeft = cornerRadiusTopLeft 
        self.cornerRadiusTopRight = cornerRadiusTopRight 
        self.cursor = cursor 
        self.description = description 
        self.dir = dir 
        self.dx = dx 
        self.dy = dy 
        self.ellipsis = ellipsis 
        self.endAngle = endAngle 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.filled = filled 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.height = height 
        self.href = href 
        self.innerRadius = innerRadius 
        self.interpolate = interpolate 
        self.invalid = invalid 
        self.limit = limit 
        self.lineBreak = lineBreak 
        self.lineHeight = lineHeight 
        self.opacity = opacity 
        self.order = order 
        self.orient = orient 
        self.outerRadius = outerRadius 
        self.padAngle = padAngle 
        self.radius = radius 
        self.radius2 = radius2 
        self.shape = shape 
        self.size = size 
        self.smooth = smooth 
        self.startAngle = startAngle 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOffset = strokeOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.tension = tension 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.timeUnitBandPosition = timeUnitBandPosition 
        self.timeUnitBandSize = timeUnitBandSize 
        self.tooltip = tooltip 
        self.url = url 
        self.width = width 
        self.x = x 
        self.x2 = x2 
        self.y = y 
        self.y2 = y2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.ariaRole = try values.decodeOptional(AriaRoleChoice.self, forKey: .ariaRole) 
        self.ariaRoleDescription = try values.decodeOptional(AriaRoleDescriptionChoice.self, forKey: .ariaRoleDescription) 
        self.aspect = try values.decodeOptional(AspectChoice.self, forKey: .aspect) 
        self.baseline = try values.decodeOptional(BaselineChoice.self, forKey: .baseline) 
        self.blend = try values.decodeOptional(BlendChoice.self, forKey: .blend) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cornerRadiusBottomLeft = try values.decodeOptional(CornerRadiusBottomLeftChoice.self, forKey: .cornerRadiusBottomLeft) 
        self.cornerRadiusBottomRight = try values.decodeOptional(CornerRadiusBottomRightChoice.self, forKey: .cornerRadiusBottomRight) 
        self.cornerRadiusTopLeft = try values.decodeOptional(CornerRadiusTopLeftChoice.self, forKey: .cornerRadiusTopLeft) 
        self.cornerRadiusTopRight = try values.decodeOptional(CornerRadiusTopRightChoice.self, forKey: .cornerRadiusTopRight) 
        self.cursor = try values.decodeOptional(CursorChoice.self, forKey: .cursor) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.dir = try values.decodeOptional(DirChoice.self, forKey: .dir) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.ellipsis = try values.decodeOptional(EllipsisChoice.self, forKey: .ellipsis) 
        self.endAngle = try values.decodeOptional(EndAngleChoice.self, forKey: .endAngle) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.filled = try values.decodeOptional(Bool.self, forKey: .filled) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.href = try values.decodeOptional(HrefChoice.self, forKey: .href) 
        self.innerRadius = try values.decodeOptional(InnerRadiusChoice.self, forKey: .innerRadius) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.invalid = try values.decodeOptional(Invalid.self, forKey: .invalid) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.order = try values.decodeOptional(Order.self, forKey: .order) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outerRadius = try values.decodeOptional(OuterRadiusChoice.self, forKey: .outerRadius) 
        self.padAngle = try values.decodeOptional(PadAngleChoice.self, forKey: .padAngle) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Choice.self, forKey: .radius2) 
        self.shape = try values.decodeOptional(SymbolShape.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.smooth = try values.decodeOptional(SmoothChoice.self, forKey: .smooth) 
        self.startAngle = try values.decodeOptional(StartAngleChoice.self, forKey: .startAngle) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOffset = try values.decodeOptional(StrokeOffsetChoice.self, forKey: .strokeOffset) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.tension = try values.decodeOptional(TensionChoice.self, forKey: .tension) 
        self.text = try values.decodeOptional(TextChoice.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaChoice.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Choice.self, forKey: .theta2) 
        self.timeUnitBandPosition = try values.decodeOptional(Double.self, forKey: .timeUnitBandPosition) 
        self.timeUnitBandSize = try values.decodeOptional(Double.self, forKey: .timeUnitBandSize) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlChoice.self, forKey: .url) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
        self.x = try values.decodeOptional(XChoice.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Choice.self, forKey: .x2) 
        self.y = try values.decodeOptional(YChoice.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Choice.self, forKey: .y2) 
    }

    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleDescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AspectChoice = OneOf<Bool>.Or<ExprRef>

    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias BaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias BlendChoice = OneOf<Blend>.Or<ExprRef>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CursorChoice = OneOf<Cursor>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DirChoice = OneOf<TextDirection>.Or<ExprRef>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias EllipsisChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias EndAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias HrefChoice = OneOf<URI>.Or<ExprRef>

    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    /// Generated by Curio
    public typealias InnerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<Interpolate>.Or<ExprRef>

    /// Generated by Curio
    public typealias Invalid = Nullable<String>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias Order = Nullable<Bool>

    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    /// Generated by Curio
    public typealias OuterRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PadAngleChoice = OneOf<Double>.Or<ExprRef>

    /// The secondary (inner) radius in pixels of arc marks.
    /// Generated by Curio
    public typealias Radius2Choice = OneOf<Double>.Or<ExprRef>

    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    /// Generated by Curio
    public typealias SizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SmoothChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias StartAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TensionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    /// Generated by Curio
    public typealias Theta2Choice = OneOf<Double>.Or<ExprRef>

    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    /// Generated by Curio
    public typealias ThetaChoice = OneOf<Double>.Or<ExprRef>

    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<Double>.Or<String>.Or<Bool>.Or<TooltipContent>.Or<ExprRef>>

    /// Generated by Curio
    public typealias UrlChoice = OneOf<URI>.Or<ExprRef>

    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<ExprRef>

    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias X2Choice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias XChoice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias Y2Choice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias YChoice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case angle
        case aria
        case ariaRole
        case ariaRoleDescription
        case aspect
        case baseline
        case blend
        case color
        case cornerRadius
        case cornerRadiusBottomLeft
        case cornerRadiusBottomRight
        case cornerRadiusTopLeft
        case cornerRadiusTopRight
        case cursor
        case description
        case dir
        case dx
        case dy
        case ellipsis
        case endAngle
        case fill
        case fillOpacity
        case filled
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case height
        case href
        case innerRadius
        case interpolate
        case invalid
        case limit
        case lineBreak
        case lineHeight
        case opacity
        case order
        case orient
        case outerRadius
        case padAngle
        case radius
        case radius2
        case shape
        case size
        case smooth
        case startAngle
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOffset
        case strokeOpacity
        case strokeWidth
        case tension
        case text
        case theta
        case theta2
        case timeUnitBandPosition
        case timeUnitBandSize
        case tooltip
        case url
        case width
        case x
        case x2
        case y
        case y2
        public var keyDescription: String? {
            switch self {
            case .align: return "The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `\"left\"`, `\"right\"`, `\"center\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .angle: return nil
            case .aria: return nil
            case .ariaRole: return nil
            case .ariaRoleDescription: return nil
            case .aspect: return nil
            case .baseline: return "For text marks, the vertical text baseline. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, `\"line-bottom\"`, or an expression reference that provides one of the valid values. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.\n\nFor range marks, the vertical alignment of the marks. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .blend: return nil
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .cornerRadius: return nil
            case .cornerRadiusBottomLeft: return nil
            case .cornerRadiusBottomRight: return nil
            case .cornerRadiusTopLeft: return nil
            case .cornerRadiusTopRight: return nil
            case .cursor: return nil
            case .description: return nil
            case .dir: return nil
            case .dx: return nil
            case .dy: return nil
            case .ellipsis: return nil
            case .endAngle: return nil
            case .fill: return "Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.\n\n__Default value:__ (None)"
            case .fillOpacity: return nil
            case .filled: return "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.\n\n__Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config)."
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .height: return nil
            case .href: return nil
            case .innerRadius: return "The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`."
            case .interpolate: return nil
            case .invalid: return "Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes."
            case .limit: return nil
            case .lineBreak: return nil
            case .lineHeight: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .order: return "For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources."
            case .orient: return "The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored."
            case .outerRadius: return "The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`."
            case .padAngle: return nil
            case .radius: return "For arc mark, the primary (outer) radius in pixels.\n\nFor text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties."
            case .radius2: return "The secondary (inner) radius in pixels of arc marks."
            case .shape: return nil
            case .size: return "Default size for marks.\n- For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.\n- For `bar`, this represents the band size of the bar, in pixels.\n- For `text`, this represents the font size, in pixels.\n\n__Default value:__\n- `30` for point, circle, square marks; width/height's `step`\n- `2` for bar marks with discrete dimensions;\n- `5` for bar marks with continuous dimensions;\n- `11` for text marks."
            case .smooth: return nil
            case .startAngle: return nil
            case .stroke: return "Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.\n\n__Default value:__ (None)"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOffset: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .tension: return nil
            case .text: return nil
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .timeUnitBandPosition: return "Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step."
            case .timeUnitBandSize: return "Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step."
            case .tooltip: return "The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n\n- If `tooltip` is `true` or `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n- If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n- If set to `null` or `false`, then no tooltip will be used.\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.\n\n__Default value:__ `null`"
            case .url: return nil
            case .width: return nil
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
             } 
        }

        public typealias CodingOwner = MarkConfig
    }
}

/// Generated by Curio
public struct MarkDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var align: AlignChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    public var ariaRole: AriaRoleChoice?
    public var ariaRoleDescription: AriaRoleDescriptionChoice?
    public var aspect: AspectChoice?
    /// The width of the ticks.
    /// __Default value:__  3/4 of step (width step for horizontal ticks and height step for vertical ticks).
    public var bandSize: Double?
    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var baseline: BaselineChoice?
    /// Offset between bars for binned field. The ideal value for this is either 0 (preferred by statisticians) or 1 (Vega-Lite default, D3 example style).
    /// __Default value:__ `1`
    public var binSpacing: Double?
    public var blend: BlendChoice?
    /// Whether a mark be clipped to the enclosing group’s width and height.
    public var clip: Bool?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    /// The default size of the bars on continuous scales.
    /// __Default value:__ `5`
    public var continuousBandSize: Double?
    public var cornerRadius: CornerRadiusChoice?
    public var cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice?
    public var cornerRadiusBottomRight: CornerRadiusBottomRightChoice?
    /// - For vertical bars, top-left and top-right corner radius.
    /// - For horizontal bars, top-right and bottom-right corner radius.
    public var cornerRadiusEnd: CornerRadiusEndChoice?
    public var cornerRadiusTopLeft: CornerRadiusTopLeftChoice?
    public var cornerRadiusTopRight: CornerRadiusTopRightChoice?
    public var cursor: CursorChoice?
    public var description: DescriptionChoice?
    public var dir: DirChoice?
    /// The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars.
    public var discreteBandSize: DiscreteBandSizeChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var ellipsis: EllipsisChoice?
    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// Whether the mark's color should be used as fill color instead of stroke color.
    /// __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.
    /// __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    public var filled: Bool?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    /// Height of the marks.  One of:
    /// - A number representing a fixed pixel height.
    /// - A relative band size definition.  For example, `{band: 0.5}` represents half of the band
    public var height: HeightChoice?
    public var href: HrefChoice?
    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    public var innerRadius: InnerRadiusChoice?
    public var interpolate: InterpolateChoice?
    /// Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
    /// - If set to `"filter"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).
    /// - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
    public var invalid: Invalid?
    public var limit: LimitChoice?
    /// A flag for overlaying line on top of area marks, or an object defining the properties of the overlayed lines.
    /// - If this value is an empty object (`{}`) or `true`, lines with default properties will be used.
    /// - If this value is `false`, no lines would be automatically added to area marks.
    /// __Default value:__ `false`.
    public var line: LineChoice?
    public var lineBreak: LineBreakChoice?
    public var lineHeight: LineHeightChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources.
    public var order: Order?
    /// The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored.
    public var orient: Orientation?
    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    public var outerRadius: OuterRadiusChoice?
    public var padAngle: PadAngleChoice?
    /// A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.
    /// - If this property is `"transparent"`, transparent points will be used (for enhancing tooltips and selections).
    /// - If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.
    /// - If this property is `false`, no points would be automatically added to line or area marks.
    /// __Default value:__ `false`.
    public var point: PointChoice?
    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    public var radius: RadiusChoice?
    /// The secondary (inner) radius in pixels of arc marks.
    public var radius2: Radius2Choice?
    /// Offset for radius2.
    public var radius2Offset: Radius2OffsetChoice?
    /// Offset for radius.
    public var radiusOffset: RadiusOffsetChoice?
    public var shape: SymbolShape?
    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    public var size: SizeChoice?
    public var smooth: SmoothChoice?
    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOffset: StrokeOffsetChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    /// A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles. Any [mark properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.
    /// __Default value:__ The mark's name. For example, a bar mark will have style `"bar"` by default. __Note:__ Any specified style will augment the default style. For example, a bar mark with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo` (the specified style `"foo"` has higher precedence).
    public var style: StyleChoice?
    public var tension: TensionChoice?
    public var text: TextChoice?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaChoice?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Choice?
    /// Offset for theta2.
    public var theta2Offset: Theta2OffsetChoice?
    /// Offset for theta.
    public var thetaOffset: ThetaOffsetChoice?
    /// Thickness of the tick mark.
    /// __Default value:__  `1`
    public var thickness: Double?
    /// Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step.
    public var timeUnitBandPosition: Double?
    /// Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step.
    public var timeUnitBandSize: Double?
    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    public var tooltip: TooltipChoice?
    /// The mark type. This could a primitive mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`, `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`) or a composite mark type (`"boxplot"`, `"errorband"`, `"errorbar"`).
    public var type: PrimitiveMarkType
    public var url: UrlChoice?
    /// Width of the marks.  One of:
    /// - A number representing a fixed pixel width.
    /// - A relative band size definition.  For example, `{band: 0.5}` represents half of the band.
    public var width: WidthChoice?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XChoice?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Choice?
    /// Offset for x2-position.
    public var x2Offset: X2OffsetChoice?
    /// Offset for x-position.
    public var xOffset: XOffsetChoice?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YChoice?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Choice?
    /// Offset for y2-position.
    public var y2Offset: Y2OffsetChoice?
    /// Offset for y-position.
    public var yOffset: YOffsetChoice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.aspect as KeyPath, \Self.bandSize as KeyPath, \Self.baseline as KeyPath, \Self.binSpacing as KeyPath, \Self.blend as KeyPath, \Self.clip as KeyPath, \Self.color as KeyPath, \Self.continuousBandSize as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusEnd as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cursor as KeyPath, \Self.description as KeyPath, \Self.dir as KeyPath, \Self.discreteBandSize as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.ellipsis as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.filled as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.height as KeyPath, \Self.href as KeyPath, \Self.innerRadius as KeyPath, \Self.interpolate as KeyPath, \Self.invalid as KeyPath, \Self.limit as KeyPath, \Self.line as KeyPath, \Self.lineBreak as KeyPath, \Self.lineHeight as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.orient as KeyPath, \Self.outerRadius as KeyPath, \Self.padAngle as KeyPath, \Self.point as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.radius2Offset as KeyPath, \Self.radiusOffset as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.smooth as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.style as KeyPath, \Self.tension as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.theta2Offset as KeyPath, \Self.thetaOffset as KeyPath, \Self.thickness as KeyPath, \Self.timeUnitBandPosition as KeyPath, \Self.timeUnitBandSize as KeyPath, \Self.tooltip as KeyPath, \Self.type as KeyPath, \Self.url as KeyPath, \Self.width as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.x2Offset as KeyPath, \Self.xOffset as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath, \Self.y2Offset as KeyPath, \Self.yOffset as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.bandSize as KeyPath : CodingKeys.bandSize, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.binSpacing as KeyPath : CodingKeys.binSpacing, \Self.blend as KeyPath : CodingKeys.blend, \Self.clip as KeyPath : CodingKeys.clip, \Self.color as KeyPath : CodingKeys.color, \Self.continuousBandSize as KeyPath : CodingKeys.continuousBandSize, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusEnd as KeyPath : CodingKeys.cornerRadiusEnd, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.description as KeyPath : CodingKeys.description, \Self.dir as KeyPath : CodingKeys.dir, \Self.discreteBandSize as KeyPath : CodingKeys.discreteBandSize, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.filled as KeyPath : CodingKeys.filled, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.height as KeyPath : CodingKeys.height, \Self.href as KeyPath : CodingKeys.href, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.invalid as KeyPath : CodingKeys.invalid, \Self.limit as KeyPath : CodingKeys.limit, \Self.line as KeyPath : CodingKeys.line, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.orient as KeyPath : CodingKeys.orient, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.point as KeyPath : CodingKeys.point, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.radius2Offset as KeyPath : CodingKeys.radius2Offset, \Self.radiusOffset as KeyPath : CodingKeys.radiusOffset, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.style as KeyPath : CodingKeys.style, \Self.tension as KeyPath : CodingKeys.tension, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.theta2Offset as KeyPath : CodingKeys.theta2Offset, \Self.thetaOffset as KeyPath : CodingKeys.thetaOffset, \Self.thickness as KeyPath : CodingKeys.thickness, \Self.timeUnitBandPosition as KeyPath : CodingKeys.timeUnitBandPosition, \Self.timeUnitBandSize as KeyPath : CodingKeys.timeUnitBandSize, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.type as KeyPath : CodingKeys.type, \Self.url as KeyPath : CodingKeys.url, \Self.width as KeyPath : CodingKeys.width, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.x2Offset as KeyPath : CodingKeys.x2Offset, \Self.xOffset as KeyPath : CodingKeys.xOffset, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2, \Self.y2Offset as KeyPath : CodingKeys.y2Offset, \Self.yOffset as KeyPath : CodingKeys.yOffset]

    public init(align: AlignChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, ariaRole: AriaRoleChoice? = nil, ariaRoleDescription: AriaRoleDescriptionChoice? = nil, aspect: AspectChoice? = nil, bandSize: Double? = nil, baseline: BaselineChoice? = nil, binSpacing: Double? = nil, blend: BlendChoice? = nil, clip: Bool? = nil, color: ColorChoice? = nil, continuousBandSize: Double? = nil, cornerRadius: CornerRadiusChoice? = nil, cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice? = nil, cornerRadiusBottomRight: CornerRadiusBottomRightChoice? = nil, cornerRadiusEnd: CornerRadiusEndChoice? = nil, cornerRadiusTopLeft: CornerRadiusTopLeftChoice? = nil, cornerRadiusTopRight: CornerRadiusTopRightChoice? = nil, cursor: CursorChoice? = nil, description: DescriptionChoice? = nil, dir: DirChoice? = nil, discreteBandSize: DiscreteBandSizeChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, ellipsis: EllipsisChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, filled: Bool? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, height: HeightChoice? = nil, href: HrefChoice? = nil, innerRadius: InnerRadiusChoice? = nil, interpolate: InterpolateChoice? = nil, invalid: Invalid? = nil, limit: LimitChoice? = nil, line: LineChoice? = nil, lineBreak: LineBreakChoice? = nil, lineHeight: LineHeightChoice? = nil, opacity: OpacityChoice? = nil, order: Order? = nil, orient: Orientation? = nil, outerRadius: OuterRadiusChoice? = nil, padAngle: PadAngleChoice? = nil, point: PointChoice? = nil, radius: RadiusChoice? = nil, radius2: Radius2Choice? = nil, radius2Offset: Radius2OffsetChoice? = nil, radiusOffset: RadiusOffsetChoice? = nil, shape: SymbolShape? = nil, size: SizeChoice? = nil, smooth: SmoothChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOffset: StrokeOffsetChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, style: StyleChoice? = nil, tension: TensionChoice? = nil, text: TextChoice? = nil, theta: ThetaChoice? = nil, theta2: Theta2Choice? = nil, theta2Offset: Theta2OffsetChoice? = nil, thetaOffset: ThetaOffsetChoice? = nil, thickness: Double? = nil, timeUnitBandPosition: Double? = nil, timeUnitBandSize: Double? = nil, tooltip: TooltipChoice? = nil, type: PrimitiveMarkType, url: UrlChoice? = nil, width: WidthChoice? = nil, x: XChoice? = nil, x2: X2Choice? = nil, x2Offset: X2OffsetChoice? = nil, xOffset: XOffsetChoice? = nil, y: YChoice? = nil, y2: Y2Choice? = nil, y2Offset: Y2OffsetChoice? = nil, yOffset: YOffsetChoice? = nil) {
        self.align = align 
        self.angle = angle 
        self.aria = aria 
        self.ariaRole = ariaRole 
        self.ariaRoleDescription = ariaRoleDescription 
        self.aspect = aspect 
        self.bandSize = bandSize 
        self.baseline = baseline 
        self.binSpacing = binSpacing 
        self.blend = blend 
        self.clip = clip 
        self.color = color 
        self.continuousBandSize = continuousBandSize 
        self.cornerRadius = cornerRadius 
        self.cornerRadiusBottomLeft = cornerRadiusBottomLeft 
        self.cornerRadiusBottomRight = cornerRadiusBottomRight 
        self.cornerRadiusEnd = cornerRadiusEnd 
        self.cornerRadiusTopLeft = cornerRadiusTopLeft 
        self.cornerRadiusTopRight = cornerRadiusTopRight 
        self.cursor = cursor 
        self.description = description 
        self.dir = dir 
        self.discreteBandSize = discreteBandSize 
        self.dx = dx 
        self.dy = dy 
        self.ellipsis = ellipsis 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.filled = filled 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.height = height 
        self.href = href 
        self.innerRadius = innerRadius 
        self.interpolate = interpolate 
        self.invalid = invalid 
        self.limit = limit 
        self.line = line 
        self.lineBreak = lineBreak 
        self.lineHeight = lineHeight 
        self.opacity = opacity 
        self.order = order 
        self.orient = orient 
        self.outerRadius = outerRadius 
        self.padAngle = padAngle 
        self.point = point 
        self.radius = radius 
        self.radius2 = radius2 
        self.radius2Offset = radius2Offset 
        self.radiusOffset = radiusOffset 
        self.shape = shape 
        self.size = size 
        self.smooth = smooth 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOffset = strokeOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.style = style 
        self.tension = tension 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.theta2Offset = theta2Offset 
        self.thetaOffset = thetaOffset 
        self.thickness = thickness 
        self.timeUnitBandPosition = timeUnitBandPosition 
        self.timeUnitBandSize = timeUnitBandSize 
        self.tooltip = tooltip 
        self.type = type 
        self.url = url 
        self.width = width 
        self.x = x 
        self.x2 = x2 
        self.x2Offset = x2Offset 
        self.xOffset = xOffset 
        self.y = y 
        self.y2 = y2 
        self.y2Offset = y2Offset 
        self.yOffset = yOffset 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.ariaRole = try values.decodeOptional(AriaRoleChoice.self, forKey: .ariaRole) 
        self.ariaRoleDescription = try values.decodeOptional(AriaRoleDescriptionChoice.self, forKey: .ariaRoleDescription) 
        self.aspect = try values.decodeOptional(AspectChoice.self, forKey: .aspect) 
        self.bandSize = try values.decodeOptional(Double.self, forKey: .bandSize) 
        self.baseline = try values.decodeOptional(BaselineChoice.self, forKey: .baseline) 
        self.binSpacing = try values.decodeOptional(Double.self, forKey: .binSpacing) 
        self.blend = try values.decodeOptional(BlendChoice.self, forKey: .blend) 
        self.clip = try values.decodeOptional(Bool.self, forKey: .clip) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.continuousBandSize = try values.decodeOptional(Double.self, forKey: .continuousBandSize) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cornerRadiusBottomLeft = try values.decodeOptional(CornerRadiusBottomLeftChoice.self, forKey: .cornerRadiusBottomLeft) 
        self.cornerRadiusBottomRight = try values.decodeOptional(CornerRadiusBottomRightChoice.self, forKey: .cornerRadiusBottomRight) 
        self.cornerRadiusEnd = try values.decodeOptional(CornerRadiusEndChoice.self, forKey: .cornerRadiusEnd) 
        self.cornerRadiusTopLeft = try values.decodeOptional(CornerRadiusTopLeftChoice.self, forKey: .cornerRadiusTopLeft) 
        self.cornerRadiusTopRight = try values.decodeOptional(CornerRadiusTopRightChoice.self, forKey: .cornerRadiusTopRight) 
        self.cursor = try values.decodeOptional(CursorChoice.self, forKey: .cursor) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.dir = try values.decodeOptional(DirChoice.self, forKey: .dir) 
        self.discreteBandSize = try values.decodeOptional(DiscreteBandSizeChoice.self, forKey: .discreteBandSize) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.ellipsis = try values.decodeOptional(EllipsisChoice.self, forKey: .ellipsis) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.filled = try values.decodeOptional(Bool.self, forKey: .filled) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.href = try values.decodeOptional(HrefChoice.self, forKey: .href) 
        self.innerRadius = try values.decodeOptional(InnerRadiusChoice.self, forKey: .innerRadius) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.invalid = try values.decodeOptional(Invalid.self, forKey: .invalid) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.line = try values.decodeOptional(LineChoice.self, forKey: .line) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.order = try values.decodeOptional(Order.self, forKey: .order) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outerRadius = try values.decodeOptional(OuterRadiusChoice.self, forKey: .outerRadius) 
        self.padAngle = try values.decodeOptional(PadAngleChoice.self, forKey: .padAngle) 
        self.point = try values.decodeOptional(PointChoice.self, forKey: .point) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Choice.self, forKey: .radius2) 
        self.radius2Offset = try values.decodeOptional(Radius2OffsetChoice.self, forKey: .radius2Offset) 
        self.radiusOffset = try values.decodeOptional(RadiusOffsetChoice.self, forKey: .radiusOffset) 
        self.shape = try values.decodeOptional(SymbolShape.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.smooth = try values.decodeOptional(SmoothChoice.self, forKey: .smooth) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOffset = try values.decodeOptional(StrokeOffsetChoice.self, forKey: .strokeOffset) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.style = try values.decodeOptional(StyleChoice.self, forKey: .style) 
        self.tension = try values.decodeOptional(TensionChoice.self, forKey: .tension) 
        self.text = try values.decodeOptional(TextChoice.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaChoice.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Choice.self, forKey: .theta2) 
        self.theta2Offset = try values.decodeOptional(Theta2OffsetChoice.self, forKey: .theta2Offset) 
        self.thetaOffset = try values.decodeOptional(ThetaOffsetChoice.self, forKey: .thetaOffset) 
        self.thickness = try values.decodeOptional(Double.self, forKey: .thickness) 
        self.timeUnitBandPosition = try values.decodeOptional(Double.self, forKey: .timeUnitBandPosition) 
        self.timeUnitBandSize = try values.decodeOptional(Double.self, forKey: .timeUnitBandSize) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.type = try values.decode(PrimitiveMarkType.self, forKey: .type) 
        self.url = try values.decodeOptional(UrlChoice.self, forKey: .url) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
        self.x = try values.decodeOptional(XChoice.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Choice.self, forKey: .x2) 
        self.x2Offset = try values.decodeOptional(X2OffsetChoice.self, forKey: .x2Offset) 
        self.xOffset = try values.decodeOptional(XOffsetChoice.self, forKey: .xOffset) 
        self.y = try values.decodeOptional(YChoice.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Choice.self, forKey: .y2) 
        self.y2Offset = try values.decodeOptional(Y2OffsetChoice.self, forKey: .y2Offset) 
        self.yOffset = try values.decodeOptional(YOffsetChoice.self, forKey: .yOffset) 
    }

    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleDescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AspectChoice = OneOf<Bool>.Or<ExprRef>

    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias BaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias BlendChoice = OneOf<Blend>.Or<ExprRef>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// - For vertical bars, top-left and top-right corner radius.
    /// - For horizontal bars, top-right and bottom-right corner radius.
    /// Generated by Curio
    public typealias CornerRadiusEndChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CursorChoice = OneOf<Cursor>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DirChoice = OneOf<TextDirection>.Or<ExprRef>

    /// The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars.
    /// Generated by Curio
    public typealias DiscreteBandSizeChoice = OneOf<Double>.Or<RelativeBandSize>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias EllipsisChoice = OneOf<String>.Or<ExprRef>

    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Height of the marks.  One of:
    /// - A number representing a fixed pixel height.
    /// - A relative band size definition.  For example, `{band: 0.5}` represents half of the band
    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<ExprRef>.Or<RelativeBandSize>

    /// Generated by Curio
    public typealias HrefChoice = OneOf<URI>.Or<ExprRef>

    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    /// Generated by Curio
    public typealias InnerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<Interpolate>.Or<ExprRef>

    /// Generated by Curio
    public typealias Invalid = Nullable<String>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// A flag for overlaying line on top of area marks, or an object defining the properties of the overlayed lines.
    /// - If this value is an empty object (`{}`) or `true`, lines with default properties will be used.
    /// - If this value is `false`, no lines would be automatically added to area marks.
    /// __Default value:__ `false`.
    /// Generated by Curio
    public typealias LineChoice = OneOf<Bool>.Or<OverlayMarkDef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias Order = Nullable<Bool>

    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    /// Generated by Curio
    public typealias OuterRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PadAngleChoice = OneOf<Double>.Or<ExprRef>

    /// A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.
    /// - If this property is `"transparent"`, transparent points will be used (for enhancing tooltips and selections).
    /// - If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.
    /// - If this property is `false`, no points would be automatically added to line or area marks.
    /// __Default value:__ `false`.
    /// Generated by Curio
    public typealias PointChoice = OneOf<Bool>.Or<OverlayMarkDef>.Or<LiteralTransparent>

    /// The secondary (inner) radius in pixels of arc marks.
    /// Generated by Curio
    public typealias Radius2Choice = OneOf<Double>.Or<ExprRef>

    /// Offset for radius2.
    /// Generated by Curio
    public typealias Radius2OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Offset for radius.
    /// Generated by Curio
    public typealias RadiusOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    /// Generated by Curio
    public typealias SizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SmoothChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles. Any [mark properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.
    /// __Default value:__ The mark's name. For example, a bar mark will have style `"bar"` by default. __Note:__ Any specified style will augment the default style. For example, a bar mark with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo` (the specified style `"foo"` has higher precedence).
    /// Generated by Curio
    public typealias StyleChoice = OneOrMany<String>

    /// Generated by Curio
    public typealias TensionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    /// Generated by Curio
    public typealias Theta2Choice = OneOf<Double>.Or<ExprRef>

    /// Offset for theta2.
    /// Generated by Curio
    public typealias Theta2OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    /// Generated by Curio
    public typealias ThetaChoice = OneOf<Double>.Or<ExprRef>

    /// Offset for theta.
    /// Generated by Curio
    public typealias ThetaOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<Double>.Or<String>.Or<Bool>.Or<TooltipContent>.Or<ExprRef>>

    /// Generated by Curio
    public typealias UrlChoice = OneOf<URI>.Or<ExprRef>

    /// Width of the marks.  One of:
    /// - A number representing a fixed pixel width.
    /// - A relative band size definition.  For example, `{band: 0.5}` represents half of the band.
    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<ExprRef>.Or<RelativeBandSize>

    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias X2Choice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Offset for x2-position.
    /// Generated by Curio
    public typealias X2OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias XChoice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Offset for x-position.
    /// Generated by Curio
    public typealias XOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias Y2Choice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Offset for y2-position.
    /// Generated by Curio
    public typealias Y2OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias YChoice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Offset for y-position.
    /// Generated by Curio
    public typealias YOffsetChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case angle
        case aria
        case ariaRole
        case ariaRoleDescription
        case aspect
        case bandSize
        case baseline
        case binSpacing
        case blend
        case clip
        case color
        case continuousBandSize
        case cornerRadius
        case cornerRadiusBottomLeft
        case cornerRadiusBottomRight
        case cornerRadiusEnd
        case cornerRadiusTopLeft
        case cornerRadiusTopRight
        case cursor
        case description
        case dir
        case discreteBandSize
        case dx
        case dy
        case ellipsis
        case fill
        case fillOpacity
        case filled
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case height
        case href
        case innerRadius
        case interpolate
        case invalid
        case limit
        case line
        case lineBreak
        case lineHeight
        case opacity
        case order
        case orient
        case outerRadius
        case padAngle
        case point
        case radius
        case radius2
        case radius2Offset
        case radiusOffset
        case shape
        case size
        case smooth
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOffset
        case strokeOpacity
        case strokeWidth
        case style
        case tension
        case text
        case theta
        case theta2
        case theta2Offset
        case thetaOffset
        case thickness
        case timeUnitBandPosition
        case timeUnitBandSize
        case tooltip
        case type
        case url
        case width
        case x
        case x2
        case x2Offset
        case xOffset
        case y
        case y2
        case y2Offset
        case yOffset
        public var keyDescription: String? {
            switch self {
            case .align: return "The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `\"left\"`, `\"right\"`, `\"center\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .angle: return nil
            case .aria: return nil
            case .ariaRole: return nil
            case .ariaRoleDescription: return nil
            case .aspect: return nil
            case .bandSize: return "The width of the ticks.\n\n__Default value:__  3/4 of step (width step for horizontal ticks and height step for vertical ticks)."
            case .baseline: return "For text marks, the vertical text baseline. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, `\"line-bottom\"`, or an expression reference that provides one of the valid values. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.\n\nFor range marks, the vertical alignment of the marks. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .binSpacing: return "Offset between bars for binned field. The ideal value for this is either 0 (preferred by statisticians) or 1 (Vega-Lite default, D3 example style).\n\n__Default value:__ `1`"
            case .blend: return nil
            case .clip: return "Whether a mark be clipped to the enclosing group’s width and height."
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .continuousBandSize: return "The default size of the bars on continuous scales.\n\n__Default value:__ `5`"
            case .cornerRadius: return nil
            case .cornerRadiusBottomLeft: return nil
            case .cornerRadiusBottomRight: return nil
            case .cornerRadiusEnd: return "- For vertical bars, top-left and top-right corner radius.\n\n- For horizontal bars, top-right and bottom-right corner radius."
            case .cornerRadiusTopLeft: return nil
            case .cornerRadiusTopRight: return nil
            case .cursor: return nil
            case .description: return nil
            case .dir: return nil
            case .discreteBandSize: return "The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars."
            case .dx: return nil
            case .dy: return nil
            case .ellipsis: return nil
            case .fill: return "Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.\n\n__Default value:__ (None)"
            case .fillOpacity: return nil
            case .filled: return "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.\n\n__Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config)."
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .height: return "Height of the marks.  One of:\n\n- A number representing a fixed pixel height.\n\n- A relative band size definition.  For example, `{band: 0.5}` represents half of the band"
            case .href: return nil
            case .innerRadius: return "The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`."
            case .interpolate: return nil
            case .invalid: return "Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes."
            case .limit: return nil
            case .line: return "A flag for overlaying line on top of area marks, or an object defining the properties of the overlayed lines.\n\n- If this value is an empty object (`{}`) or `true`, lines with default properties will be used.\n\n- If this value is `false`, no lines would be automatically added to area marks.\n\n__Default value:__ `false`."
            case .lineBreak: return nil
            case .lineHeight: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .order: return "For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources."
            case .orient: return "The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored."
            case .outerRadius: return "The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`."
            case .padAngle: return nil
            case .point: return "A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.\n\n- If this property is `\"transparent\"`, transparent points will be used (for enhancing tooltips and selections).\n\n- If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.\n\n- If this property is `false`, no points would be automatically added to line or area marks.\n\n__Default value:__ `false`."
            case .radius: return "For arc mark, the primary (outer) radius in pixels.\n\nFor text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties."
            case .radius2: return "The secondary (inner) radius in pixels of arc marks."
            case .radius2Offset: return "Offset for radius2."
            case .radiusOffset: return "Offset for radius."
            case .shape: return nil
            case .size: return "Default size for marks.\n- For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.\n- For `bar`, this represents the band size of the bar, in pixels.\n- For `text`, this represents the font size, in pixels.\n\n__Default value:__\n- `30` for point, circle, square marks; width/height's `step`\n- `2` for bar marks with discrete dimensions;\n- `5` for bar marks with continuous dimensions;\n- `11` for text marks."
            case .smooth: return nil
            case .stroke: return "Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.\n\n__Default value:__ (None)"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOffset: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .style: return "A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles. Any [mark properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.\n\n__Default value:__ The mark's name. For example, a bar mark will have style `\"bar\"` by default. __Note:__ Any specified style will augment the default style. For example, a bar mark with `\"style\": \"foo\"` will receive from `config.style.bar` and `config.style.foo` (the specified style `\"foo\"` has higher precedence)."
            case .tension: return nil
            case .text: return nil
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .theta2Offset: return "Offset for theta2."
            case .thetaOffset: return "Offset for theta."
            case .thickness: return "Thickness of the tick mark.\n\n__Default value:__  `1`"
            case .timeUnitBandPosition: return "Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step."
            case .timeUnitBandSize: return "Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step."
            case .tooltip: return "The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n\n- If `tooltip` is `true` or `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n- If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n- If set to `null` or `false`, then no tooltip will be used.\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.\n\n__Default value:__ `null`"
            case .type: return "The mark type. This could a primitive mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`, `\"area\"`, `\"point\"`, `\"geoshape\"`, `\"rule\"`, and `\"text\"`) or a composite mark type (`\"boxplot\"`, `\"errorband\"`, `\"errorbar\"`)."
            case .url: return nil
            case .width: return "Width of the marks.  One of:\n\n- A number representing a fixed pixel width.\n\n- A relative band size definition.  For example, `{band: 0.5}` represents half of the band."
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2Offset: return "Offset for x2-position."
            case .xOffset: return "Offset for x-position."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2Offset: return "Offset for y2-position."
            case .yOffset: return "Offset for y-position."
             } 
        }

        public typealias CodingOwner = MarkDef
    }
}

public struct MarkPropDefGradientStringNull : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull>.Or<FieldOrDatumDefWithConditionDatumDefGradientStringNull>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull>

    public init(rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull>.Or<FieldOrDatumDefWithConditionDatumDefGradientStringNull>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull>.Or<FieldOrDatumDefWithConditionDatumDefGradientStringNull>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull>) {
        self.rawValue = rawValue 
    }
}

public struct MarkPropDefNumber : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefNumber>.Or<FieldOrDatumDefWithConditionDatumDefNumber>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefNumber>

    public init(rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefNumber>.Or<FieldOrDatumDefWithConditionDatumDefNumber>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefNumber>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefNumber>.Or<FieldOrDatumDefWithConditionDatumDefNumber>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefNumber>) {
        self.rawValue = rawValue 
    }
}

public struct MarkPropDefNumberArray : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefNumberArray>.Or<FieldOrDatumDefWithConditionDatumDefNumberArray>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefNumberArray>

    public init(rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefNumberArray>.Or<FieldOrDatumDefWithConditionDatumDefNumberArray>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefNumberArray>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefNumberArray>.Or<FieldOrDatumDefWithConditionDatumDefNumberArray>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefNumberArray>) {
        self.rawValue = rawValue 
    }
}

public struct MarkPropDefStringNullTypeForShape : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull>.Or<FieldOrDatumDefWithConditionDatumDefStringNull>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull>

    public init(rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull>.Or<FieldOrDatumDefWithConditionDatumDefStringNull>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull>.Or<FieldOrDatumDefWithConditionDatumDefStringNull>.Or<ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct MergedStream : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var between: [Stream]?
    public var consume: Bool?
    public var debounce: Double?
    public var filter: FilterChoice?
    public var markname: String?
    public var marktype: VgMarkType?
    public var merge: [Stream]
    public var throttle: Double?
    public static let codingKeyPaths = (\Self.between as KeyPath, \Self.consume as KeyPath, \Self.debounce as KeyPath, \Self.filter as KeyPath, \Self.markname as KeyPath, \Self.marktype as KeyPath, \Self.merge as KeyPath, \Self.throttle as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.between as KeyPath : CodingKeys.between, \Self.consume as KeyPath : CodingKeys.consume, \Self.debounce as KeyPath : CodingKeys.debounce, \Self.filter as KeyPath : CodingKeys.filter, \Self.markname as KeyPath : CodingKeys.markname, \Self.marktype as KeyPath : CodingKeys.marktype, \Self.merge as KeyPath : CodingKeys.merge, \Self.throttle as KeyPath : CodingKeys.throttle]

    public init(between: [Stream]? = nil, consume: Bool? = nil, debounce: Double? = nil, filter: FilterChoice? = nil, markname: String? = nil, marktype: VgMarkType? = nil, merge: [Stream] = [], throttle: Double? = nil) {
        self.between = between 
        self.consume = consume 
        self.debounce = debounce 
        self.filter = filter 
        self.markname = markname 
        self.marktype = marktype 
        self.merge = merge 
        self.throttle = throttle 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.between = try values.decodeOptional([Stream].self, forKey: .between) 
        self.consume = try values.decodeOptional(Bool.self, forKey: .consume) 
        self.debounce = try values.decodeOptional(Double.self, forKey: .debounce) 
        self.filter = try values.decodeOptional(FilterChoice.self, forKey: .filter) 
        self.markname = try values.decodeOptional(String.self, forKey: .markname) 
        self.marktype = try values.decodeOptional(VgMarkType.self, forKey: .marktype) 
        self.merge = try values.decode([Stream].self, forKey: .merge) 
        self.throttle = try values.decodeOptional(Double.self, forKey: .throttle) 
    }

    /// Generated by Curio
    public typealias FilterChoice = OneOrMany<Expr>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case between
        case consume
        case debounce
        case filter
        case markname
        case marktype
        case merge
        case throttle
        public var keyDescription: String? {
            switch self {
            case .between: return nil
            case .consume: return nil
            case .debounce: return nil
            case .filter: return nil
            case .markname: return nil
            case .marktype: return nil
            case .merge: return nil
            case .throttle: return nil
             } 
        }

        public typealias CodingOwner = MergedStream
    }
}

public struct Month : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: UInt8

    public init(rawValue: UInt8) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: UInt8) {
        self.rawValue = rawValue 
    }
}

public struct MultiTimeUnit : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<LocalMultiTimeUnit>.Or<UtcMultiTimeUnit>

    public init(rawValue: OneOf<LocalMultiTimeUnit>.Or<UtcMultiTimeUnit>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<LocalMultiTimeUnit>.Or<UtcMultiTimeUnit>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct NamedData : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// An object that specifies the format for parsing the data.
    public var format: DataFormat?
    /// Provide a placeholder name and bind data at runtime.
    public var name: String
    public static let codingKeyPaths = (\Self.format as KeyPath, \Self.name as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.format as KeyPath : CodingKeys.format, \Self.name as KeyPath : CodingKeys.name]

    public init(format: DataFormat? = nil, name: String) {
        self.format = format 
        self.name = name 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.format = try values.decodeOptional(DataFormat.self, forKey: .format) 
        self.name = try values.decode(String.self, forKey: .name) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case format
        case name
        public var keyDescription: String? {
            switch self {
            case .format: return "An object that specifies the format for parsing the data."
            case .name: return "Provide a placeholder name and bind data at runtime."
             } 
        }

        public typealias CodingOwner = NamedData
    }
}

/// Base interface for a repeat specification.
/// Generated by Curio
public struct NonLayerRepeatSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// The number of columns to include in the view composition layout.
    /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
    /// __Note__:
    /// 1) This property is only for:
    /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
    /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
    /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
    public var columns: Double?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// Name of the visualization for later reference.
    public var name: String?
    /// Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed fields to be repeated along the particular orientations. The objects `{"repeat": "row"}` and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
    public var `repeat`: OneOf<[FieldName]>.Or<RepeatMapping>
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// A specification of the view that gets repeated.
    public var spec: NonNormalizedSpec
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.align as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.data as KeyPath, \Self.description as KeyPath, \Self.name as KeyPath, \Self.`repeat` as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.spec as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.align as KeyPath : CodingKeys.align, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.name as KeyPath : CodingKeys.name, \Self.`repeat` as KeyPath : CodingKeys.`repeat`, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.spec as KeyPath : CodingKeys.spec, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform]

    public init(id: LayerId? = nil, align: AlignChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, data: DataChoice? = nil, description: String? = nil, name: String? = nil, `repeat`: OneOf<[FieldName]>.Or<RepeatMapping>, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, spec: NonNormalizedSpec, title: TitleChoice? = nil, transform: [DataTransformation]? = nil) {
        self.id = id 
        self.align = align 
        self.bounds = bounds 
        self.center = center 
        self.columns = columns 
        self.data = data 
        self.description = description 
        self.name = name 
        self.`repeat` = `repeat` 
        self.resolve = resolve 
        self.spacing = spacing 
        self.spec = spec 
        self.title = title 
        self.transform = transform 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.`repeat` = try values.decode(OneOf<[FieldName]>.Or<RepeatMapping>.self, forKey: .`repeat`) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.spec = try values.decode(NonNormalizedSpec.self, forKey: .spec) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case align
        case bounds
        case center
        case columns
        case data
        case description
        case name
        case `repeat`
        case resolve
        case spacing
        case spec
        case title
        case transform
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .name: return "Name of the visualization for later reference."
            case .`repeat`: return "Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `\"repeat\"` is an array, the field can be referred to as `{\"repeat\": \"repeat\"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `\"row\"` and/or `\"column\"` to the listed fields to be repeated along the particular orientations. The objects `{\"repeat\": \"row\"}` and `{\"repeat\": \"column\"}` can be used to refer to the repeated field respectively."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .spec: return "A specification of the view that gets repeated."
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
             } 
        }

        public typealias CodingOwner = NonLayerRepeatSpec
    }
}

/// Locale definition for formatting numbers.
/// Generated by Curio
public struct NumberLocale : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The currency prefix and suffix (e.g., ["$", ""]).
    public var currency: Vector2String
    /// The decimal point (e.g., ".").
    public var decimal: String
    /// The array of group sizes (e.g., [3]), cycled as needed.
    public var grouping: [GroupingItem]
    /// The minus sign (defaults to hyphen-minus, "-").
    public var minus: String?
    /// The not-a-number value (defaults to "NaN").
    public var nan: String?
    /// An array of ten strings to replace the numerals 0-9.
    public var numerals: Vector10String?
    /// The percent sign (defaults to "%").
    public var percent: String?
    /// The group separator (e.g., ",").
    public var thousands: String
    public static let codingKeyPaths = (\Self.currency as KeyPath, \Self.decimal as KeyPath, \Self.grouping as KeyPath, \Self.minus as KeyPath, \Self.nan as KeyPath, \Self.numerals as KeyPath, \Self.percent as KeyPath, \Self.thousands as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.currency as KeyPath : CodingKeys.currency, \Self.decimal as KeyPath : CodingKeys.decimal, \Self.grouping as KeyPath : CodingKeys.grouping, \Self.minus as KeyPath : CodingKeys.minus, \Self.nan as KeyPath : CodingKeys.nan, \Self.numerals as KeyPath : CodingKeys.numerals, \Self.percent as KeyPath : CodingKeys.percent, \Self.thousands as KeyPath : CodingKeys.thousands]

    public init(currency: Vector2String, decimal: String, grouping: [GroupingItem] = [], minus: String? = nil, nan: String? = nil, numerals: Vector10String? = nil, percent: String? = nil, thousands: String) {
        self.currency = currency 
        self.decimal = decimal 
        self.grouping = grouping 
        self.minus = minus 
        self.nan = nan 
        self.numerals = numerals 
        self.percent = percent 
        self.thousands = thousands 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.currency = try values.decode(Vector2String.self, forKey: .currency) 
        self.decimal = try values.decode(String.self, forKey: .decimal) 
        self.grouping = try values.decode([GroupingItem].self, forKey: .grouping) 
        self.minus = try values.decodeOptional(String.self, forKey: .minus) 
        self.nan = try values.decodeOptional(String.self, forKey: .nan) 
        self.numerals = try values.decodeOptional(Vector10String.self, forKey: .numerals) 
        self.percent = try values.decodeOptional(String.self, forKey: .percent) 
        self.thousands = try values.decode(String.self, forKey: .thousands) 
    }

    public typealias GroupingItem = Double

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case currency
        case decimal
        case grouping
        case minus
        case nan
        case numerals
        case percent
        case thousands
        public var keyDescription: String? {
            switch self {
            case .currency: return "The currency prefix and suffix (e.g., [\"$\", \"\"])."
            case .decimal: return "The decimal point (e.g., \".\")."
            case .grouping: return "The array of group sizes (e.g., [3]), cycled as needed."
            case .minus: return "The minus sign (defaults to hyphen-minus, \"-\")."
            case .nan: return "The not-a-number value (defaults to \"NaN\")."
            case .numerals: return "An array of ten strings to replace the numerals 0-9."
            case .percent: return "The percent sign (defaults to \"%\")."
            case .thousands: return "The group separator (e.g., \",\")."
             } 
        }

        public typealias CodingOwner = NumberLocale
    }
}

/// Generated by Curio
public struct OrderFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// The sort order. One of `"ascending"` (default) or `"descending"`.
    public var sort: SortOrder?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, sort: SortOrder? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.sort = sort 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.sort = try values.decodeOptional(SortOrder.self, forKey: .sort) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case field
        case sort
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .sort: return "The sort order. One of `\"ascending\"` (default) or `\"descending\"`."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = OrderFieldDef
    }
}

/// Generated by Curio
public struct OrderValueDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    public var condition: ConditionChoice?
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

    public init(condition: ConditionChoice? = nil, value: ValueChoice) {
        self.condition = condition 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
    /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
    /// Generated by Curio
    public typealias ConditionChoice = OneOrMany<ConditionalValueDefNumber>

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case condition
        case value
        public var keyDescription: String? {
            switch self {
            case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = OrderValueDef
    }
}

/// Generated by Curio
public struct OverlayMarkDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var align: AlignChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    public var ariaRole: AriaRoleChoice?
    public var ariaRoleDescription: AriaRoleDescriptionChoice?
    public var aspect: AspectChoice?
    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var baseline: BaselineChoice?
    public var blend: BlendChoice?
    /// Whether a mark be clipped to the enclosing group’s width and height.
    public var clip: Bool?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    public var cornerRadius: CornerRadiusChoice?
    public var cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice?
    public var cornerRadiusBottomRight: CornerRadiusBottomRightChoice?
    public var cornerRadiusTopLeft: CornerRadiusTopLeftChoice?
    public var cornerRadiusTopRight: CornerRadiusTopRightChoice?
    public var cursor: CursorChoice?
    public var description: DescriptionChoice?
    public var dir: DirChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var ellipsis: EllipsisChoice?
    public var endAngle: EndAngleChoice?
    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// Whether the mark's color should be used as fill color instead of stroke color.
    /// __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.
    /// __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    public var filled: Bool?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var height: HeightChoice?
    public var href: HrefChoice?
    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    public var innerRadius: InnerRadiusChoice?
    public var interpolate: InterpolateChoice?
    /// Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
    /// - If set to `"filter"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).
    /// - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
    public var invalid: Invalid?
    public var limit: LimitChoice?
    public var lineBreak: LineBreakChoice?
    public var lineHeight: LineHeightChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources.
    public var order: Order?
    /// The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored.
    public var orient: Orientation?
    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    public var outerRadius: OuterRadiusChoice?
    public var padAngle: PadAngleChoice?
    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    public var radius: RadiusChoice?
    /// The secondary (inner) radius in pixels of arc marks.
    public var radius2: Radius2Choice?
    /// Offset for radius2.
    public var radius2Offset: Radius2OffsetChoice?
    /// Offset for radius.
    public var radiusOffset: RadiusOffsetChoice?
    public var shape: SymbolShape?
    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    public var size: SizeChoice?
    public var smooth: SmoothChoice?
    public var startAngle: StartAngleChoice?
    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOffset: StrokeOffsetChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    /// A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles. Any [mark properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.
    /// __Default value:__ The mark's name. For example, a bar mark will have style `"bar"` by default. __Note:__ Any specified style will augment the default style. For example, a bar mark with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo` (the specified style `"foo"` has higher precedence).
    public var style: StyleChoice?
    public var tension: TensionChoice?
    public var text: TextChoice?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaChoice?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Choice?
    /// Offset for theta2.
    public var theta2Offset: Theta2OffsetChoice?
    /// Offset for theta.
    public var thetaOffset: ThetaOffsetChoice?
    /// Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step.
    public var timeUnitBandPosition: Double?
    /// Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step.
    public var timeUnitBandSize: Double?
    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    public var tooltip: TooltipChoice?
    public var url: UrlChoice?
    public var width: WidthChoice?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XChoice?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Choice?
    /// Offset for x2-position.
    public var x2Offset: X2OffsetChoice?
    /// Offset for x-position.
    public var xOffset: XOffsetChoice?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YChoice?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Choice?
    /// Offset for y2-position.
    public var y2Offset: Y2OffsetChoice?
    /// Offset for y-position.
    public var yOffset: YOffsetChoice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.aspect as KeyPath, \Self.baseline as KeyPath, \Self.blend as KeyPath, \Self.clip as KeyPath, \Self.color as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cursor as KeyPath, \Self.description as KeyPath, \Self.dir as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.ellipsis as KeyPath, \Self.endAngle as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.filled as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.height as KeyPath, \Self.href as KeyPath, \Self.innerRadius as KeyPath, \Self.interpolate as KeyPath, \Self.invalid as KeyPath, \Self.limit as KeyPath, \Self.lineBreak as KeyPath, \Self.lineHeight as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.orient as KeyPath, \Self.outerRadius as KeyPath, \Self.padAngle as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.radius2Offset as KeyPath, \Self.radiusOffset as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.smooth as KeyPath, \Self.startAngle as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.style as KeyPath, \Self.tension as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.theta2Offset as KeyPath, \Self.thetaOffset as KeyPath, \Self.timeUnitBandPosition as KeyPath, \Self.timeUnitBandSize as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.width as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.x2Offset as KeyPath, \Self.xOffset as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath, \Self.y2Offset as KeyPath, \Self.yOffset as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.blend as KeyPath : CodingKeys.blend, \Self.clip as KeyPath : CodingKeys.clip, \Self.color as KeyPath : CodingKeys.color, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.description as KeyPath : CodingKeys.description, \Self.dir as KeyPath : CodingKeys.dir, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.endAngle as KeyPath : CodingKeys.endAngle, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.filled as KeyPath : CodingKeys.filled, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.height as KeyPath : CodingKeys.height, \Self.href as KeyPath : CodingKeys.href, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.invalid as KeyPath : CodingKeys.invalid, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.orient as KeyPath : CodingKeys.orient, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.radius2Offset as KeyPath : CodingKeys.radius2Offset, \Self.radiusOffset as KeyPath : CodingKeys.radiusOffset, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.startAngle as KeyPath : CodingKeys.startAngle, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.style as KeyPath : CodingKeys.style, \Self.tension as KeyPath : CodingKeys.tension, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.theta2Offset as KeyPath : CodingKeys.theta2Offset, \Self.thetaOffset as KeyPath : CodingKeys.thetaOffset, \Self.timeUnitBandPosition as KeyPath : CodingKeys.timeUnitBandPosition, \Self.timeUnitBandSize as KeyPath : CodingKeys.timeUnitBandSize, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.width as KeyPath : CodingKeys.width, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.x2Offset as KeyPath : CodingKeys.x2Offset, \Self.xOffset as KeyPath : CodingKeys.xOffset, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2, \Self.y2Offset as KeyPath : CodingKeys.y2Offset, \Self.yOffset as KeyPath : CodingKeys.yOffset]

    public init(align: AlignChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, ariaRole: AriaRoleChoice? = nil, ariaRoleDescription: AriaRoleDescriptionChoice? = nil, aspect: AspectChoice? = nil, baseline: BaselineChoice? = nil, blend: BlendChoice? = nil, clip: Bool? = nil, color: ColorChoice? = nil, cornerRadius: CornerRadiusChoice? = nil, cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice? = nil, cornerRadiusBottomRight: CornerRadiusBottomRightChoice? = nil, cornerRadiusTopLeft: CornerRadiusTopLeftChoice? = nil, cornerRadiusTopRight: CornerRadiusTopRightChoice? = nil, cursor: CursorChoice? = nil, description: DescriptionChoice? = nil, dir: DirChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, ellipsis: EllipsisChoice? = nil, endAngle: EndAngleChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, filled: Bool? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, height: HeightChoice? = nil, href: HrefChoice? = nil, innerRadius: InnerRadiusChoice? = nil, interpolate: InterpolateChoice? = nil, invalid: Invalid? = nil, limit: LimitChoice? = nil, lineBreak: LineBreakChoice? = nil, lineHeight: LineHeightChoice? = nil, opacity: OpacityChoice? = nil, order: Order? = nil, orient: Orientation? = nil, outerRadius: OuterRadiusChoice? = nil, padAngle: PadAngleChoice? = nil, radius: RadiusChoice? = nil, radius2: Radius2Choice? = nil, radius2Offset: Radius2OffsetChoice? = nil, radiusOffset: RadiusOffsetChoice? = nil, shape: SymbolShape? = nil, size: SizeChoice? = nil, smooth: SmoothChoice? = nil, startAngle: StartAngleChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOffset: StrokeOffsetChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, style: StyleChoice? = nil, tension: TensionChoice? = nil, text: TextChoice? = nil, theta: ThetaChoice? = nil, theta2: Theta2Choice? = nil, theta2Offset: Theta2OffsetChoice? = nil, thetaOffset: ThetaOffsetChoice? = nil, timeUnitBandPosition: Double? = nil, timeUnitBandSize: Double? = nil, tooltip: TooltipChoice? = nil, url: UrlChoice? = nil, width: WidthChoice? = nil, x: XChoice? = nil, x2: X2Choice? = nil, x2Offset: X2OffsetChoice? = nil, xOffset: XOffsetChoice? = nil, y: YChoice? = nil, y2: Y2Choice? = nil, y2Offset: Y2OffsetChoice? = nil, yOffset: YOffsetChoice? = nil) {
        self.align = align 
        self.angle = angle 
        self.aria = aria 
        self.ariaRole = ariaRole 
        self.ariaRoleDescription = ariaRoleDescription 
        self.aspect = aspect 
        self.baseline = baseline 
        self.blend = blend 
        self.clip = clip 
        self.color = color 
        self.cornerRadius = cornerRadius 
        self.cornerRadiusBottomLeft = cornerRadiusBottomLeft 
        self.cornerRadiusBottomRight = cornerRadiusBottomRight 
        self.cornerRadiusTopLeft = cornerRadiusTopLeft 
        self.cornerRadiusTopRight = cornerRadiusTopRight 
        self.cursor = cursor 
        self.description = description 
        self.dir = dir 
        self.dx = dx 
        self.dy = dy 
        self.ellipsis = ellipsis 
        self.endAngle = endAngle 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.filled = filled 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.height = height 
        self.href = href 
        self.innerRadius = innerRadius 
        self.interpolate = interpolate 
        self.invalid = invalid 
        self.limit = limit 
        self.lineBreak = lineBreak 
        self.lineHeight = lineHeight 
        self.opacity = opacity 
        self.order = order 
        self.orient = orient 
        self.outerRadius = outerRadius 
        self.padAngle = padAngle 
        self.radius = radius 
        self.radius2 = radius2 
        self.radius2Offset = radius2Offset 
        self.radiusOffset = radiusOffset 
        self.shape = shape 
        self.size = size 
        self.smooth = smooth 
        self.startAngle = startAngle 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOffset = strokeOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.style = style 
        self.tension = tension 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.theta2Offset = theta2Offset 
        self.thetaOffset = thetaOffset 
        self.timeUnitBandPosition = timeUnitBandPosition 
        self.timeUnitBandSize = timeUnitBandSize 
        self.tooltip = tooltip 
        self.url = url 
        self.width = width 
        self.x = x 
        self.x2 = x2 
        self.x2Offset = x2Offset 
        self.xOffset = xOffset 
        self.y = y 
        self.y2 = y2 
        self.y2Offset = y2Offset 
        self.yOffset = yOffset 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.ariaRole = try values.decodeOptional(AriaRoleChoice.self, forKey: .ariaRole) 
        self.ariaRoleDescription = try values.decodeOptional(AriaRoleDescriptionChoice.self, forKey: .ariaRoleDescription) 
        self.aspect = try values.decodeOptional(AspectChoice.self, forKey: .aspect) 
        self.baseline = try values.decodeOptional(BaselineChoice.self, forKey: .baseline) 
        self.blend = try values.decodeOptional(BlendChoice.self, forKey: .blend) 
        self.clip = try values.decodeOptional(Bool.self, forKey: .clip) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cornerRadiusBottomLeft = try values.decodeOptional(CornerRadiusBottomLeftChoice.self, forKey: .cornerRadiusBottomLeft) 
        self.cornerRadiusBottomRight = try values.decodeOptional(CornerRadiusBottomRightChoice.self, forKey: .cornerRadiusBottomRight) 
        self.cornerRadiusTopLeft = try values.decodeOptional(CornerRadiusTopLeftChoice.self, forKey: .cornerRadiusTopLeft) 
        self.cornerRadiusTopRight = try values.decodeOptional(CornerRadiusTopRightChoice.self, forKey: .cornerRadiusTopRight) 
        self.cursor = try values.decodeOptional(CursorChoice.self, forKey: .cursor) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.dir = try values.decodeOptional(DirChoice.self, forKey: .dir) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.ellipsis = try values.decodeOptional(EllipsisChoice.self, forKey: .ellipsis) 
        self.endAngle = try values.decodeOptional(EndAngleChoice.self, forKey: .endAngle) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.filled = try values.decodeOptional(Bool.self, forKey: .filled) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.href = try values.decodeOptional(HrefChoice.self, forKey: .href) 
        self.innerRadius = try values.decodeOptional(InnerRadiusChoice.self, forKey: .innerRadius) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.invalid = try values.decodeOptional(Invalid.self, forKey: .invalid) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.order = try values.decodeOptional(Order.self, forKey: .order) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outerRadius = try values.decodeOptional(OuterRadiusChoice.self, forKey: .outerRadius) 
        self.padAngle = try values.decodeOptional(PadAngleChoice.self, forKey: .padAngle) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Choice.self, forKey: .radius2) 
        self.radius2Offset = try values.decodeOptional(Radius2OffsetChoice.self, forKey: .radius2Offset) 
        self.radiusOffset = try values.decodeOptional(RadiusOffsetChoice.self, forKey: .radiusOffset) 
        self.shape = try values.decodeOptional(SymbolShape.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.smooth = try values.decodeOptional(SmoothChoice.self, forKey: .smooth) 
        self.startAngle = try values.decodeOptional(StartAngleChoice.self, forKey: .startAngle) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOffset = try values.decodeOptional(StrokeOffsetChoice.self, forKey: .strokeOffset) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.style = try values.decodeOptional(StyleChoice.self, forKey: .style) 
        self.tension = try values.decodeOptional(TensionChoice.self, forKey: .tension) 
        self.text = try values.decodeOptional(TextChoice.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaChoice.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Choice.self, forKey: .theta2) 
        self.theta2Offset = try values.decodeOptional(Theta2OffsetChoice.self, forKey: .theta2Offset) 
        self.thetaOffset = try values.decodeOptional(ThetaOffsetChoice.self, forKey: .thetaOffset) 
        self.timeUnitBandPosition = try values.decodeOptional(Double.self, forKey: .timeUnitBandPosition) 
        self.timeUnitBandSize = try values.decodeOptional(Double.self, forKey: .timeUnitBandSize) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlChoice.self, forKey: .url) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
        self.x = try values.decodeOptional(XChoice.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Choice.self, forKey: .x2) 
        self.x2Offset = try values.decodeOptional(X2OffsetChoice.self, forKey: .x2Offset) 
        self.xOffset = try values.decodeOptional(XOffsetChoice.self, forKey: .xOffset) 
        self.y = try values.decodeOptional(YChoice.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Choice.self, forKey: .y2) 
        self.y2Offset = try values.decodeOptional(Y2OffsetChoice.self, forKey: .y2Offset) 
        self.yOffset = try values.decodeOptional(YOffsetChoice.self, forKey: .yOffset) 
    }

    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleDescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AspectChoice = OneOf<Bool>.Or<ExprRef>

    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias BaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias BlendChoice = OneOf<Blend>.Or<ExprRef>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CursorChoice = OneOf<Cursor>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DirChoice = OneOf<TextDirection>.Or<ExprRef>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias EllipsisChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias EndAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias HrefChoice = OneOf<URI>.Or<ExprRef>

    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    /// Generated by Curio
    public typealias InnerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<Interpolate>.Or<ExprRef>

    /// Generated by Curio
    public typealias Invalid = Nullable<String>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias Order = Nullable<Bool>

    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    /// Generated by Curio
    public typealias OuterRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PadAngleChoice = OneOf<Double>.Or<ExprRef>

    /// The secondary (inner) radius in pixels of arc marks.
    /// Generated by Curio
    public typealias Radius2Choice = OneOf<Double>.Or<ExprRef>

    /// Offset for radius2.
    /// Generated by Curio
    public typealias Radius2OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Offset for radius.
    /// Generated by Curio
    public typealias RadiusOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    /// Generated by Curio
    public typealias SizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SmoothChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias StartAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles. Any [mark properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.
    /// __Default value:__ The mark's name. For example, a bar mark will have style `"bar"` by default. __Note:__ Any specified style will augment the default style. For example, a bar mark with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo` (the specified style `"foo"` has higher precedence).
    /// Generated by Curio
    public typealias StyleChoice = OneOrMany<String>

    /// Generated by Curio
    public typealias TensionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    /// Generated by Curio
    public typealias Theta2Choice = OneOf<Double>.Or<ExprRef>

    /// Offset for theta2.
    /// Generated by Curio
    public typealias Theta2OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    /// Generated by Curio
    public typealias ThetaChoice = OneOf<Double>.Or<ExprRef>

    /// Offset for theta.
    /// Generated by Curio
    public typealias ThetaOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<Double>.Or<String>.Or<Bool>.Or<TooltipContent>.Or<ExprRef>>

    /// Generated by Curio
    public typealias UrlChoice = OneOf<URI>.Or<ExprRef>

    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<ExprRef>

    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias X2Choice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Offset for x2-position.
    /// Generated by Curio
    public typealias X2OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias XChoice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Offset for x-position.
    /// Generated by Curio
    public typealias XOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias Y2Choice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Offset for y2-position.
    /// Generated by Curio
    public typealias Y2OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias YChoice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Offset for y-position.
    /// Generated by Curio
    public typealias YOffsetChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case angle
        case aria
        case ariaRole
        case ariaRoleDescription
        case aspect
        case baseline
        case blend
        case clip
        case color
        case cornerRadius
        case cornerRadiusBottomLeft
        case cornerRadiusBottomRight
        case cornerRadiusTopLeft
        case cornerRadiusTopRight
        case cursor
        case description
        case dir
        case dx
        case dy
        case ellipsis
        case endAngle
        case fill
        case fillOpacity
        case filled
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case height
        case href
        case innerRadius
        case interpolate
        case invalid
        case limit
        case lineBreak
        case lineHeight
        case opacity
        case order
        case orient
        case outerRadius
        case padAngle
        case radius
        case radius2
        case radius2Offset
        case radiusOffset
        case shape
        case size
        case smooth
        case startAngle
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOffset
        case strokeOpacity
        case strokeWidth
        case style
        case tension
        case text
        case theta
        case theta2
        case theta2Offset
        case thetaOffset
        case timeUnitBandPosition
        case timeUnitBandSize
        case tooltip
        case url
        case width
        case x
        case x2
        case x2Offset
        case xOffset
        case y
        case y2
        case y2Offset
        case yOffset
        public var keyDescription: String? {
            switch self {
            case .align: return "The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `\"left\"`, `\"right\"`, `\"center\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .angle: return nil
            case .aria: return nil
            case .ariaRole: return nil
            case .ariaRoleDescription: return nil
            case .aspect: return nil
            case .baseline: return "For text marks, the vertical text baseline. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, `\"line-bottom\"`, or an expression reference that provides one of the valid values. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.\n\nFor range marks, the vertical alignment of the marks. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .blend: return nil
            case .clip: return "Whether a mark be clipped to the enclosing group’s width and height."
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .cornerRadius: return nil
            case .cornerRadiusBottomLeft: return nil
            case .cornerRadiusBottomRight: return nil
            case .cornerRadiusTopLeft: return nil
            case .cornerRadiusTopRight: return nil
            case .cursor: return nil
            case .description: return nil
            case .dir: return nil
            case .dx: return nil
            case .dy: return nil
            case .ellipsis: return nil
            case .endAngle: return nil
            case .fill: return "Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.\n\n__Default value:__ (None)"
            case .fillOpacity: return nil
            case .filled: return "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.\n\n__Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config)."
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .height: return nil
            case .href: return nil
            case .innerRadius: return "The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`."
            case .interpolate: return nil
            case .invalid: return "Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes."
            case .limit: return nil
            case .lineBreak: return nil
            case .lineHeight: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .order: return "For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources."
            case .orient: return "The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored."
            case .outerRadius: return "The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`."
            case .padAngle: return nil
            case .radius: return "For arc mark, the primary (outer) radius in pixels.\n\nFor text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties."
            case .radius2: return "The secondary (inner) radius in pixels of arc marks."
            case .radius2Offset: return "Offset for radius2."
            case .radiusOffset: return "Offset for radius."
            case .shape: return nil
            case .size: return "Default size for marks.\n- For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.\n- For `bar`, this represents the band size of the bar, in pixels.\n- For `text`, this represents the font size, in pixels.\n\n__Default value:__\n- `30` for point, circle, square marks; width/height's `step`\n- `2` for bar marks with discrete dimensions;\n- `5` for bar marks with continuous dimensions;\n- `11` for text marks."
            case .smooth: return nil
            case .startAngle: return nil
            case .stroke: return "Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.\n\n__Default value:__ (None)"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOffset: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .style: return "A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles. Any [mark properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.\n\n__Default value:__ The mark's name. For example, a bar mark will have style `\"bar\"` by default. __Note:__ Any specified style will augment the default style. For example, a bar mark with `\"style\": \"foo\"` will receive from `config.style.bar` and `config.style.foo` (the specified style `\"foo\"` has higher precedence)."
            case .tension: return nil
            case .text: return nil
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .theta2Offset: return "Offset for theta2."
            case .thetaOffset: return "Offset for theta."
            case .timeUnitBandPosition: return "Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step."
            case .timeUnitBandSize: return "Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step."
            case .tooltip: return "The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n\n- If `tooltip` is `true` or `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n- If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n- If set to `null` or `false`, then no tooltip will be used.\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.\n\n__Default value:__ `null`"
            case .url: return nil
            case .width: return nil
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2Offset: return "Offset for x2-position."
            case .xOffset: return "Offset for x-position."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2Offset: return "Offset for y2-position."
            case .yOffset: return "Offset for y-position."
             } 
        }

        public typealias CodingOwner = OverlayMarkDef
    }
}

public struct Padding : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Double>.Or<BottomLeftRightTopType>

    public init(rawValue: OneOf<Double>.Or<BottomLeftRightTopType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Double>.Or<BottomLeftRightTopType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct BottomLeftRightTopType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var bottom: Double?
        public var left: Double?
        public var right: Double?
        public var top: Double?
        public static let codingKeyPaths = (\Self.bottom as KeyPath, \Self.left as KeyPath, \Self.right as KeyPath, \Self.top as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bottom as KeyPath : CodingKeys.bottom, \Self.left as KeyPath : CodingKeys.left, \Self.right as KeyPath : CodingKeys.right, \Self.top as KeyPath : CodingKeys.top]

        public init(bottom: Double? = nil, left: Double? = nil, right: Double? = nil, top: Double? = nil) {
            self.bottom = bottom 
            self.left = left 
            self.right = right 
            self.top = top 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.bottom = try values.decodeOptional(Double.self, forKey: .bottom) 
            self.left = try values.decodeOptional(Double.self, forKey: .left) 
            self.right = try values.decodeOptional(Double.self, forKey: .right) 
            self.top = try values.decodeOptional(Double.self, forKey: .top) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case bottom
            case left
            case right
            case top
            public var keyDescription: String? {
                switch self {
                case .bottom: return nil
                case .left: return nil
                case .right: return nil
                case .top: return nil
                 } 
            }

            public typealias CodingOwner = BottomLeftRightTopType
        }
    }
}

public struct ParameterExtent : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FieldParamType>.Or<EncodingParamType>

    public init(rawValue: OneOf<FieldParamType>.Or<EncodingParamType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FieldParamType>.Or<EncodingParamType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct EncodingParamType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// If a selection parameter is specified, the encoding channel to extract selected values for when a selection is [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple fields or encodings.
        public var encoding: SingleDefUnitChannel?
        /// The name of a parameter.
        public var param: ParameterName
        public static let codingKeyPaths = (\Self.encoding as KeyPath, \Self.param as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.encoding as KeyPath : CodingKeys.encoding, \Self.param as KeyPath : CodingKeys.param]

        public init(encoding: SingleDefUnitChannel? = nil, param: ParameterName) {
            self.encoding = encoding 
            self.param = param 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.encoding = try values.decodeOptional(SingleDefUnitChannel.self, forKey: .encoding) 
            self.param = try values.decode(ParameterName.self, forKey: .param) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case encoding
            case param
            public var keyDescription: String? {
                switch self {
                case .encoding: return "If a selection parameter is specified, the encoding channel to extract selected values for when a selection is [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple fields or encodings."
                case .param: return "The name of a parameter."
                 } 
            }

            public typealias CodingOwner = EncodingParamType
        }
    }

    /// Generated by Curio
    public struct FieldParamType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// If a selection parameter is specified, the field name to extract selected values for when the selection is [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple fields or encodings.
        public var field: FieldName?
        /// The name of a parameter.
        public var param: ParameterName
        public static let codingKeyPaths = (\Self.field as KeyPath, \Self.param as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.param as KeyPath : CodingKeys.param]

        public init(field: FieldName? = nil, param: ParameterName) {
            self.field = field 
            self.param = param 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.field = try values.decodeOptional(FieldName.self, forKey: .field) 
            self.param = try values.decode(ParameterName.self, forKey: .param) 
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case field
            case param
            public var keyDescription: String? {
                switch self {
                case .field: return "If a selection parameter is specified, the field name to extract selected values for when the selection is [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple fields or encodings."
                case .param: return "The name of a parameter."
                 } 
            }

            public typealias CodingOwner = FieldParamType
        }
    }
}

public struct ParameterId : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: UUID

    public init(rawValue: UUID) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: UUID) {
        self.rawValue = rawValue 
    }
}

public struct ParameterName : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: String) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct ParameterPredicate : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`.
    public var empty: Bool?
    /// Filter using a parameter name.
    public var param: ParameterName
    public static let codingKeyPaths = (\Self.empty as KeyPath, \Self.param as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.empty as KeyPath : CodingKeys.empty, \Self.param as KeyPath : CodingKeys.param]

    public init(empty: Bool? = nil, param: ParameterName) {
        self.empty = empty 
        self.param = param 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.empty = try values.decodeOptional(Bool.self, forKey: .empty) 
        self.param = try values.decode(ParameterName.self, forKey: .param) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case empty
        case param
        public var keyDescription: String? {
            switch self {
            case .empty: return "For selection parameters, the predicate of empty selections returns true by default. Override this behavior, by setting this property `empty: false`."
            case .param: return "Filter using a parameter name."
             } 
        }

        public typealias CodingOwner = ParameterPredicate
    }
}

public struct ParseValue : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: Nullable<OneOf<String>.Or<LiteralString>.Or<LiteralBoolean>.Or<LiteralDate>.Or<LiteralNumber>>

    public init(rawValue: Nullable<OneOf<String>.Or<LiteralString>.Or<LiteralBoolean>.Or<LiteralDate>.Or<LiteralNumber>>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: Nullable<OneOf<String>.Or<LiteralString>.Or<LiteralBoolean>.Or<LiteralDate>.Or<LiteralNumber>>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public enum LiteralBoolean : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case boolean
    }

    /// Generated by Curio
    public enum LiteralDate : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case date
    }

    /// Generated by Curio
    public enum LiteralNumber : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case number
    }

    /// Generated by Curio
    public enum LiteralString : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case string
    }
}

/// Generated by Curio
public struct PivotTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The optional data fields to group by. If not specified, a single group containing all data objects will be used.
    public var groupby: [FieldName]?
    /// An optional parameter indicating the maximum number of pivoted fields to generate. The default (`0`) applies no limit. The pivoted `pivot` names are sorted in ascending order prior to enforcing the limit. __Default value:__ `0`
    public var limit: Double?
    /// The aggregation operation to apply to grouped `value` field values. __Default value:__ `sum`
    public var op: AggregateOp?
    /// The data field to pivot on. The unique values of this field become new field names in the output stream.
    public var pivot: FieldName
    /// The data field to populate pivoted fields. The aggregate values of this field become the values of the new pivoted fields.
    public var value: FieldName
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.groupby as KeyPath, \Self.limit as KeyPath, \Self.op as KeyPath, \Self.pivot as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.limit as KeyPath : CodingKeys.limit, \Self.op as KeyPath : CodingKeys.op, \Self.pivot as KeyPath : CodingKeys.pivot, \Self.value as KeyPath : CodingKeys.value]

    public init(id: TransformId? = nil, groupby: [FieldName]? = nil, limit: Double? = nil, op: AggregateOp? = nil, pivot: FieldName, value: FieldName) {
        self.id = id 
        self.groupby = groupby 
        self.limit = limit 
        self.op = op 
        self.pivot = pivot 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
        self.limit = try values.decodeOptional(Double.self, forKey: .limit) 
        self.op = try values.decodeOptional(AggregateOp.self, forKey: .op) 
        self.pivot = try values.decode(FieldName.self, forKey: .pivot) 
        self.value = try values.decode(FieldName.self, forKey: .value) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case groupby
        case limit
        case op
        case pivot
        case value
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .groupby: return "The optional data fields to group by. If not specified, a single group containing all data objects will be used."
            case .limit: return "An optional parameter indicating the maximum number of pivoted fields to generate. The default (`0`) applies no limit. The pivoted `pivot` names are sorted in ascending order prior to enforcing the limit. __Default value:__ `0`"
            case .op: return "The aggregation operation to apply to grouped `value` field values. __Default value:__ `sum`"
            case .pivot: return "The data field to pivot on. The unique values of this field become new field names in the output stream."
            case .value: return "The data field to populate pivoted fields. The aggregate values of this field become the values of the new pivoted fields."
             } 
        }

        public typealias CodingOwner = PivotTransform
    }
}

/// Generated by Curio
public struct PointSelectionConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
    /// __Default value:__ `dblclick`.
    /// __See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
    public var clear: ClearChoice?
    /// An array of encoding channels. The corresponding data field values must match for a data tuple to fall within the selection.
    /// __See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation.
    public var encodings: [SingleDefUnitChannel]?
    /// An array of field names whose values must match for a data tuple to fall within the selection.
    /// __See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation.
    public var fields: [FieldName]?
    /// When true, an invisible voronoi diagram is computed to accelerate discrete selection. The data value _nearest_ the mouse cursor is added to the selection.
    /// __Default value:__ `false`, which means that data values must be interacted with directly (e.g., clicked on) to be added to the selection.
    /// __See also:__ [`nearest` examples](https://vega.github.io/vega-lite/docs/selection.html#nearest) documentation.
    public var nearest: Bool?
    /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
    /// __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation.
    public var on: OnChoice?
    /// With layered and multi-view displays, a strategy that determines how selections' data queries are resolved when applied in a filter transform, conditional encoding rule, or scale domain.
    /// One of:
    /// - `"global"` -- only one brush exists for the entire SPLOM. When the user begins to drag, any previous brushes are cleared, and a new one is constructed.
    /// - `"union"` -- each cell contains its own brush, and points are highlighted if they lie within _any_ of these individual brushes.
    /// - `"intersect"` -- each cell contains its own brush, and points are highlighted only if they fall within _all_ of these individual brushes.
    /// __Default value:__ `global`.
    /// __See also:__ [`resolve` examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the documentation.
    public var resolve: SelectionResolution?
    /// Controls whether data values should be toggled (inserted or removed from a point selection) or only ever inserted into multi selections.
    /// One of:
    /// - `true` -- the default behavior, which corresponds to `"event.shiftKey"`.  As a result, data values are toggled when the user interacts with the shift-key pressed.
    /// - `false` -- disables toggling behaviour; as the user interacts, data values are only inserted into the multi selection and never removed.
    /// - A [Vega expression](https://vega.github.io/vega/docs/expressions/) which is re-evaluated as the user interacts. If the expression evaluates to `true`, the data value is toggled into or out of the multi selection. If the expression evaluates to `false`, the multi selection is first clear, and the data value is then inserted. For example, setting the value to the Vega expression `"true"` will toggle data values without the user pressing the shift-key.
    /// __Default value:__ `true`
    /// __See also:__ [`toggle` examples](https://vega.github.io/vega-lite/docs/selection.html#toggle) in the documentation.
    public var toggle: Toggle?
    /// Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:
    /// - `"point"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.
    /// - `"interval"` -- to select a continuous range of data values on `drag`.
    public var type: LiteralPoint
    public static let codingKeyPaths = (\Self.clear as KeyPath, \Self.encodings as KeyPath, \Self.fields as KeyPath, \Self.nearest as KeyPath, \Self.on as KeyPath, \Self.resolve as KeyPath, \Self.toggle as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.clear as KeyPath : CodingKeys.clear, \Self.encodings as KeyPath : CodingKeys.encodings, \Self.fields as KeyPath : CodingKeys.fields, \Self.nearest as KeyPath : CodingKeys.nearest, \Self.on as KeyPath : CodingKeys.on, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.toggle as KeyPath : CodingKeys.toggle, \Self.type as KeyPath : CodingKeys.type]

    public init(clear: ClearChoice? = nil, encodings: [SingleDefUnitChannel]? = nil, fields: [FieldName]? = nil, nearest: Bool? = nil, on: OnChoice? = nil, resolve: SelectionResolution? = nil, toggle: Toggle? = nil, type: LiteralPoint = .point) {
        self.clear = clear 
        self.encodings = encodings 
        self.fields = fields 
        self.nearest = nearest 
        self.on = on 
        self.resolve = resolve 
        self.toggle = toggle 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.clear = try values.decodeOptional(ClearChoice.self, forKey: .clear) 
        self.encodings = try values.decodeOptional([SingleDefUnitChannel].self, forKey: .encodings) 
        self.fields = try values.decodeOptional([FieldName].self, forKey: .fields) 
        self.nearest = try values.decodeOptional(Bool.self, forKey: .nearest) 
        self.on = try values.decodeOptional(OnChoice.self, forKey: .on) 
        self.resolve = try values.decodeOptional(SelectionResolution.self, forKey: .resolve) 
        self.toggle = try values.decodeOptional(Toggle.self, forKey: .toggle) 
        self.type = try values.decode(LiteralPoint.self, forKey: .type) 
    }

    /// Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
    /// __Default value:__ `dblclick`.
    /// __See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
    /// Generated by Curio
    public typealias ClearChoice = OneOf<Stream>.Or<String>.Or<Bool>

    /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
    /// __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation.
    /// Generated by Curio
    public typealias OnChoice = OneOf<Stream>.Or<String>

    /// Generated by Curio
    public typealias Toggle = OneOf<String>.Or<Bool>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case clear
        case encodings
        case fields
        case nearest
        case on
        case resolve
        case toggle
        case type
        public var keyDescription: String? {
            switch self {
            case .clear: return "Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.\n\n__Default value:__ `dblclick`.\n\n__See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation."
            case .encodings: return "An array of encoding channels. The corresponding data field values must match for a data tuple to fall within the selection.\n\n__See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation."
            case .fields: return "An array of field names whose values must match for a data tuple to fall within the selection.\n\n__See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation."
            case .nearest: return "When true, an invisible voronoi diagram is computed to accelerate discrete selection. The data value _nearest_ the mouse cursor is added to the selection.\n\n__Default value:__ `false`, which means that data values must be interacted with directly (e.g., clicked on) to be added to the selection.\n\n__See also:__ [`nearest` examples](https://vega.github.io/vega-lite/docs/selection.html#nearest) documentation."
            case .on: return "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).\n\n__See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation."
            case .resolve: return "With layered and multi-view displays, a strategy that determines how selections' data queries are resolved when applied in a filter transform, conditional encoding rule, or scale domain.\n\nOne of:\n- `\"global\"` -- only one brush exists for the entire SPLOM. When the user begins to drag, any previous brushes are cleared, and a new one is constructed.\n- `\"union\"` -- each cell contains its own brush, and points are highlighted if they lie within _any_ of these individual brushes.\n- `\"intersect\"` -- each cell contains its own brush, and points are highlighted only if they fall within _all_ of these individual brushes.\n\n__Default value:__ `global`.\n\n__See also:__ [`resolve` examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the documentation."
            case .toggle: return "Controls whether data values should be toggled (inserted or removed from a point selection) or only ever inserted into multi selections.\n\nOne of:\n- `true` -- the default behavior, which corresponds to `\"event.shiftKey\"`.  As a result, data values are toggled when the user interacts with the shift-key pressed.\n- `false` -- disables toggling behaviour; as the user interacts, data values are only inserted into the multi selection and never removed.\n- A [Vega expression](https://vega.github.io/vega/docs/expressions/) which is re-evaluated as the user interacts. If the expression evaluates to `true`, the data value is toggled into or out of the multi selection. If the expression evaluates to `false`, the multi selection is first clear, and the data value is then inserted. For example, setting the value to the Vega expression `\"true\"` will toggle data values without the user pressing the shift-key.\n\n__Default value:__ `true`\n\n__See also:__ [`toggle` examples](https://vega.github.io/vega-lite/docs/selection.html#toggle) in the documentation."
            case .type: return "Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:\n\n- `\"point\"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.\n- `\"interval\"` -- to select a continuous range of data values on `drag`."
             } 
        }

        public typealias CodingOwner = PointSelectionConfig
    }

    /// Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:
    /// - `"point"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.
    /// - `"interval"` -- to select a continuous range of data values on `drag`.
    /// Generated by Curio
    public enum LiteralPoint : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case point
    }
}

/// Generated by Curio
public struct PointSelectionConfigWithoutType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
    /// __Default value:__ `dblclick`.
    /// __See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
    public var clear: ClearChoice?
    /// An array of encoding channels. The corresponding data field values must match for a data tuple to fall within the selection.
    /// __See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation.
    public var encodings: [SingleDefUnitChannel]?
    /// An array of field names whose values must match for a data tuple to fall within the selection.
    /// __See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation.
    public var fields: [FieldName]?
    /// When true, an invisible voronoi diagram is computed to accelerate discrete selection. The data value _nearest_ the mouse cursor is added to the selection.
    /// __Default value:__ `false`, which means that data values must be interacted with directly (e.g., clicked on) to be added to the selection.
    /// __See also:__ [`nearest` examples](https://vega.github.io/vega-lite/docs/selection.html#nearest) documentation.
    public var nearest: Bool?
    /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
    /// __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation.
    public var on: OnChoice?
    /// With layered and multi-view displays, a strategy that determines how selections' data queries are resolved when applied in a filter transform, conditional encoding rule, or scale domain.
    /// One of:
    /// - `"global"` -- only one brush exists for the entire SPLOM. When the user begins to drag, any previous brushes are cleared, and a new one is constructed.
    /// - `"union"` -- each cell contains its own brush, and points are highlighted if they lie within _any_ of these individual brushes.
    /// - `"intersect"` -- each cell contains its own brush, and points are highlighted only if they fall within _all_ of these individual brushes.
    /// __Default value:__ `global`.
    /// __See also:__ [`resolve` examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the documentation.
    public var resolve: SelectionResolution?
    /// Controls whether data values should be toggled (inserted or removed from a point selection) or only ever inserted into multi selections.
    /// One of:
    /// - `true` -- the default behavior, which corresponds to `"event.shiftKey"`.  As a result, data values are toggled when the user interacts with the shift-key pressed.
    /// - `false` -- disables toggling behaviour; as the user interacts, data values are only inserted into the multi selection and never removed.
    /// - A [Vega expression](https://vega.github.io/vega/docs/expressions/) which is re-evaluated as the user interacts. If the expression evaluates to `true`, the data value is toggled into or out of the multi selection. If the expression evaluates to `false`, the multi selection is first clear, and the data value is then inserted. For example, setting the value to the Vega expression `"true"` will toggle data values without the user pressing the shift-key.
    /// __Default value:__ `true`
    /// __See also:__ [`toggle` examples](https://vega.github.io/vega-lite/docs/selection.html#toggle) in the documentation.
    public var toggle: Toggle?
    public static let codingKeyPaths = (\Self.clear as KeyPath, \Self.encodings as KeyPath, \Self.fields as KeyPath, \Self.nearest as KeyPath, \Self.on as KeyPath, \Self.resolve as KeyPath, \Self.toggle as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.clear as KeyPath : CodingKeys.clear, \Self.encodings as KeyPath : CodingKeys.encodings, \Self.fields as KeyPath : CodingKeys.fields, \Self.nearest as KeyPath : CodingKeys.nearest, \Self.on as KeyPath : CodingKeys.on, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.toggle as KeyPath : CodingKeys.toggle]

    public init(clear: ClearChoice? = nil, encodings: [SingleDefUnitChannel]? = nil, fields: [FieldName]? = nil, nearest: Bool? = nil, on: OnChoice? = nil, resolve: SelectionResolution? = nil, toggle: Toggle? = nil) {
        self.clear = clear 
        self.encodings = encodings 
        self.fields = fields 
        self.nearest = nearest 
        self.on = on 
        self.resolve = resolve 
        self.toggle = toggle 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.clear = try values.decodeOptional(ClearChoice.self, forKey: .clear) 
        self.encodings = try values.decodeOptional([SingleDefUnitChannel].self, forKey: .encodings) 
        self.fields = try values.decodeOptional([FieldName].self, forKey: .fields) 
        self.nearest = try values.decodeOptional(Bool.self, forKey: .nearest) 
        self.on = try values.decodeOptional(OnChoice.self, forKey: .on) 
        self.resolve = try values.decodeOptional(SelectionResolution.self, forKey: .resolve) 
        self.toggle = try values.decodeOptional(Toggle.self, forKey: .toggle) 
    }

    /// Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
    /// __Default value:__ `dblclick`.
    /// __See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
    /// Generated by Curio
    public typealias ClearChoice = OneOf<Stream>.Or<String>.Or<Bool>

    /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
    /// __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation.
    /// Generated by Curio
    public typealias OnChoice = OneOf<Stream>.Or<String>

    /// Generated by Curio
    public typealias Toggle = OneOf<String>.Or<Bool>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case clear
        case encodings
        case fields
        case nearest
        case on
        case resolve
        case toggle
        public var keyDescription: String? {
            switch self {
            case .clear: return "Clears the selection, emptying it of all values. This property can be a [Event Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.\n\n__Default value:__ `dblclick`.\n\n__See also:__ [`clear` examples ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation."
            case .encodings: return "An array of encoding channels. The corresponding data field values must match for a data tuple to fall within the selection.\n\n__See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation."
            case .fields: return "An array of field names whose values must match for a data tuple to fall within the selection.\n\n__See also:__ The [projection with `encodings` and `fields` section](https://vega.github.io/vega-lite/docs/selection.html#project) in the documentation."
            case .nearest: return "When true, an invisible voronoi diagram is computed to accelerate discrete selection. The data value _nearest_ the mouse cursor is added to the selection.\n\n__Default value:__ `false`, which means that data values must be interacted with directly (e.g., clicked on) to be added to the selection.\n\n__See also:__ [`nearest` examples](https://vega.github.io/vega-lite/docs/selection.html#nearest) documentation."
            case .on: return "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection. For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).\n\n__See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in the documentation."
            case .resolve: return "With layered and multi-view displays, a strategy that determines how selections' data queries are resolved when applied in a filter transform, conditional encoding rule, or scale domain.\n\nOne of:\n- `\"global\"` -- only one brush exists for the entire SPLOM. When the user begins to drag, any previous brushes are cleared, and a new one is constructed.\n- `\"union\"` -- each cell contains its own brush, and points are highlighted if they lie within _any_ of these individual brushes.\n- `\"intersect\"` -- each cell contains its own brush, and points are highlighted only if they fall within _all_ of these individual brushes.\n\n__Default value:__ `global`.\n\n__See also:__ [`resolve` examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the documentation."
            case .toggle: return "Controls whether data values should be toggled (inserted or removed from a point selection) or only ever inserted into multi selections.\n\nOne of:\n- `true` -- the default behavior, which corresponds to `\"event.shiftKey\"`.  As a result, data values are toggled when the user interacts with the shift-key pressed.\n- `false` -- disables toggling behaviour; as the user interacts, data values are only inserted into the multi selection and never removed.\n- A [Vega expression](https://vega.github.io/vega/docs/expressions/) which is re-evaluated as the user interacts. If the expression evaluates to `true`, the data value is toggled into or out of the multi selection. If the expression evaluates to `false`, the multi selection is first clear, and the data value is then inserted. For example, setting the value to the Vega expression `\"true\"` will toggle data values without the user pressing the shift-key.\n\n__Default value:__ `true`\n\n__See also:__ [`toggle` examples](https://vega.github.io/vega-lite/docs/selection.html#toggle) in the documentation."
             } 
        }

        public typealias CodingOwner = PointSelectionConfigWithoutType
    }
}

public struct PolarDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<PositionFieldDefBase>.Or<PositionDatumDefBase>.Or<PositionValueDef>

    public init(rawValue: OneOf<PositionFieldDefBase>.Or<PositionDatumDefBase>.Or<PositionValueDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<PositionFieldDefBase>.Or<PositionDatumDefBase>.Or<PositionValueDef>) {
        self.rawValue = rawValue 
    }
}

public struct Position2Def : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<SecondaryFieldDef>.Or<DatumDef>.Or<PositionValueDef>

    public init(rawValue: OneOf<SecondaryFieldDef>.Or<DatumDef>.Or<PositionValueDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<SecondaryFieldDef>.Or<DatumDef>.Or<PositionValueDef>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct PositionDatumDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
    /// __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
    public var axis: AxisChoice?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A constant value in data domain.
    public var datum: DatumChoice?
    /// An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.
    /// __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
    public var impute: ImputeChoice?
    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    public var scale: ScaleChoice?
    /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
    /// `stack` can be one of the following values:
    /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
    /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
    /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
    /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
    /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
    /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
    public var stack: StackChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: MeasureType?
    public static let codingKeyPaths = (\Self.axis as KeyPath, \Self.bandPosition as KeyPath, \Self.datum as KeyPath, \Self.impute as KeyPath, \Self.scale as KeyPath, \Self.stack as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.axis as KeyPath : CodingKeys.axis, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.datum as KeyPath : CodingKeys.datum, \Self.impute as KeyPath : CodingKeys.impute, \Self.scale as KeyPath : CodingKeys.scale, \Self.stack as KeyPath : CodingKeys.stack, \Self.type as KeyPath : CodingKeys.type]

    public init(axis: AxisChoice? = nil, bandPosition: Double? = nil, datum: DatumChoice? = nil, impute: ImputeChoice? = nil, scale: ScaleChoice? = nil, stack: StackChoice? = nil, type: MeasureType? = nil) {
        self.axis = axis 
        self.bandPosition = bandPosition 
        self.datum = datum 
        self.impute = impute 
        self.scale = scale 
        self.stack = stack 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.axis = try values.decodeOptional(AxisChoice.self, forKey: .axis) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
        self.impute = try values.decodeOptional(ImputeChoice.self, forKey: .impute) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.stack = try values.decodeOptional(StackChoice.self, forKey: .stack) 
        self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
    }

    /// An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
    /// __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
    /// Generated by Curio
    public typealias AxisChoice = Nullable<AxisDef>

    /// A constant value in data domain.
    /// Generated by Curio
    public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

    /// An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.
    /// __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
    /// Generated by Curio
    public typealias ImputeChoice = Nullable<ImputeParams>

    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    /// Generated by Curio
    public typealias ScaleChoice = Nullable<ScaleDef>

    /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
    /// `stack` can be one of the following values:
    /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
    /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
    /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
    /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
    /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
    /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
    /// Generated by Curio
    public typealias StackChoice = Nullable<OneOf<StackOffset>.Or<Bool>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case axis
        case bandPosition
        case datum
        case impute
        case scale
        case stack
        case type
        public var keyDescription: String? {
            switch self {
            case .axis: return "An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.\n\n__See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .datum: return "A constant value in data domain."
            case .impute: return "An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.\n\n__See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation."
            case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
            case .stack: return "Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n- `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.\n\n__See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = PositionDatumDef
    }
}

/// Generated by Curio
public struct PositionDatumDefBase : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A constant value in data domain.
    public var datum: DatumChoice?
    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    public var scale: ScaleChoice?
    /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
    /// `stack` can be one of the following values:
    /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
    /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
    /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
    /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
    /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
    /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
    public var stack: StackChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: MeasureType?
    public static let codingKeyPaths = (\Self.bandPosition as KeyPath, \Self.datum as KeyPath, \Self.scale as KeyPath, \Self.stack as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.datum as KeyPath : CodingKeys.datum, \Self.scale as KeyPath : CodingKeys.scale, \Self.stack as KeyPath : CodingKeys.stack, \Self.type as KeyPath : CodingKeys.type]

    public init(bandPosition: Double? = nil, datum: DatumChoice? = nil, scale: ScaleChoice? = nil, stack: StackChoice? = nil, type: MeasureType? = nil) {
        self.bandPosition = bandPosition 
        self.datum = datum 
        self.scale = scale 
        self.stack = stack 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.stack = try values.decodeOptional(StackChoice.self, forKey: .stack) 
        self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
    }

    /// A constant value in data domain.
    /// Generated by Curio
    public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    /// Generated by Curio
    public typealias ScaleChoice = Nullable<ScaleDef>

    /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
    /// `stack` can be one of the following values:
    /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
    /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
    /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
    /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
    /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
    /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
    /// Generated by Curio
    public typealias StackChoice = Nullable<OneOf<StackOffset>.Or<Bool>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case bandPosition
        case datum
        case scale
        case stack
        case type
        public var keyDescription: String? {
            switch self {
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .datum: return "A constant value in data domain."
            case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
            case .stack: return "Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n- `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.\n\n__See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = PositionDatumDefBase
    }
}

public struct PositionDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<PositionFieldDef>.Or<PositionDatumDef>.Or<PositionValueDef>

    public init(rawValue: OneOf<PositionFieldDef>.Or<PositionDatumDef>.Or<PositionValueDef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<PositionFieldDef>.Or<PositionDatumDef>.Or<PositionValueDef>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct PositionFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
    /// __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
    public var axis: AxisChoice?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.
    /// __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
    public var impute: ImputeChoice?
    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    public var scale: ScaleChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
    /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
    public var sort: Sort?
    /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
    /// `stack` can be one of the following values:
    /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
    /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
    /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
    /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
    /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
    /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
    public var stack: StackChoice?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.axis as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.impute as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.stack as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.axis as KeyPath : CodingKeys.axis, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.impute as KeyPath : CodingKeys.impute, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.stack as KeyPath : CodingKeys.stack, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, axis: AxisChoice? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, impute: ImputeChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, stack: StackChoice? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.axis = axis 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.impute = impute 
        self.scale = scale 
        self.sort = sort 
        self.stack = stack 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.axis = try values.decodeOptional(AxisChoice.self, forKey: .axis) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.impute = try values.decodeOptional(ImputeChoice.self, forKey: .impute) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
        self.stack = try values.decodeOptional(StackChoice.self, forKey: .stack) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.
    /// __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
    /// __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
    /// Generated by Curio
    public typealias AxisChoice = Nullable<AxisDef>

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.
    /// __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
    /// Generated by Curio
    public typealias ImputeChoice = Nullable<ImputeParams>

    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    /// Generated by Curio
    public typealias ScaleChoice = Nullable<ScaleDef>

    /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
    /// `stack` can be one of the following values:
    /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
    /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
    /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
    /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
    /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
    /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
    /// Generated by Curio
    public typealias StackChoice = Nullable<OneOf<StackOffset>.Or<Bool>>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case axis
        case bandPosition
        case bin
        case field
        case impute
        case scale
        case sort
        case stack
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .axis: return "An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.\n\n__See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .impute: return "An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.\n\n__See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation."
            case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
            case .stack: return "Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n- `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.\n\n__See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = PositionFieldDef
    }
}

/// Generated by Curio
public struct PositionFieldDefBase : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    public var scale: ScaleChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
    /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
    public var sort: Sort?
    /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
    /// `stack` can be one of the following values:
    /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
    /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
    /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
    /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
    /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
    /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
    public var stack: StackChoice?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.stack as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.stack as KeyPath : CodingKeys.stack, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, stack: StackChoice? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.scale = scale 
        self.sort = sort 
        self.stack = stack 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
        self.stack = try values.decodeOptional(StackChoice.self, forKey: .stack) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
    /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
    /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
    /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
    /// Generated by Curio
    public typealias ScaleChoice = Nullable<ScaleDef>

    /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
    /// `stack` can be one of the following values:
    /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
    /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
    /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
    /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
    /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
    /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
    /// Generated by Curio
    public typealias StackChoice = Nullable<OneOf<StackOffset>.Or<Bool>>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case field
        case scale
        case sort
        case stack
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
            case .stack: return "Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n- `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.\n\n__See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = PositionFieldDefBase
    }
}

public struct Predicate : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FieldEqualPredicate>.Or<FieldRangePredicate>.Or<FieldOneOfPredicate>.Or<FieldLTPredicate>.Or<FieldGTPredicate>.Or<FieldLTEPredicate>.Or<FieldGTEPredicate>.Or<FieldValidPredicate>.Or<ParameterPredicate>.Or<String>

    public init(rawValue: OneOf<FieldEqualPredicate>.Or<FieldRangePredicate>.Or<FieldOneOfPredicate>.Or<FieldLTPredicate>.Or<FieldGTPredicate>.Or<FieldLTEPredicate>.Or<FieldGTEPredicate>.Or<FieldValidPredicate>.Or<ParameterPredicate>.Or<String>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FieldEqualPredicate>.Or<FieldRangePredicate>.Or<FieldOneOfPredicate>.Or<FieldLTPredicate>.Or<FieldGTPredicate>.Or<FieldLTEPredicate>.Or<FieldGTEPredicate>.Or<FieldValidPredicate>.Or<ParameterPredicate>.Or<String>) {
        self.rawValue = rawValue 
    }
}

public struct PredicateComposition : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<LogicalNotPredicate>.Or<LogicalAndPredicate>.Or<LogicalOrPredicate>.Or<Predicate>

    public init(rawValue: OneOf<LogicalNotPredicate>.Or<LogicalAndPredicate>.Or<LogicalOrPredicate>.Or<Predicate>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<LogicalNotPredicate>.Or<LogicalAndPredicate>.Or<LogicalOrPredicate>.Or<Predicate>) {
        self.rawValue = rawValue 
    }
}

public struct PrimitiveValue : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf4<ExplicitNull, Double, String, Bool>

    public init(rawValue: OneOf4<ExplicitNull, Double, String, Bool>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf4<ExplicitNull, Double, String, Bool>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct Projection : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var center: CenterChoice?
    public var clipAngle: ClipAngleChoice?
    public var clipExtent: ClipExtentChoice?
    public var coefficient: CoefficientChoice?
    public var distance: DistanceChoice?
    public var extent: ExtentChoice?
    public var fit: FitChoice?
    public var fraction: FractionChoice?
    public var lobes: LobesChoice?
    public var parallel: ParallelChoice?
    public var parallels: ParallelsChoice?
    public var pointRadius: PointRadiusChoice?
    public var precision: PrecisionChoice?
    public var radius: RadiusChoice?
    public var ratio: RatioChoice?
    public var reflectX: ReflectXChoice?
    public var reflectY: ReflectYChoice?
    public var rotate: RotateChoice?
    /// The projection’s scale (zoom) factor, overriding automatic fitting. The default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, scale factor values are not equivalent across projections.
    public var scale: ScaleChoice?
    public var size: SizeChoice?
    public var spacing: SpacingChoice?
    public var tilt: TiltChoice?
    /// The projection’s translation offset as a two-element array `[tx, ty]`.
    public var translate: TranslateChoice?
    /// The cartographic projection to use. This value is case-insensitive, for example `"albers"` and `"Albers"` indicate the same projection type. You can find all valid projection types [in the documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).
    /// __Default value:__ `equalEarth`
    public var type: TypeChoice?
    public static let codingKeyPaths = (\Self.center as KeyPath, \Self.clipAngle as KeyPath, \Self.clipExtent as KeyPath, \Self.coefficient as KeyPath, \Self.distance as KeyPath, \Self.extent as KeyPath, \Self.fit as KeyPath, \Self.fraction as KeyPath, \Self.lobes as KeyPath, \Self.parallel as KeyPath, \Self.parallels as KeyPath, \Self.pointRadius as KeyPath, \Self.precision as KeyPath, \Self.radius as KeyPath, \Self.ratio as KeyPath, \Self.reflectX as KeyPath, \Self.reflectY as KeyPath, \Self.rotate as KeyPath, \Self.scale as KeyPath, \Self.size as KeyPath, \Self.spacing as KeyPath, \Self.tilt as KeyPath, \Self.translate as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.center as KeyPath : CodingKeys.center, \Self.clipAngle as KeyPath : CodingKeys.clipAngle, \Self.clipExtent as KeyPath : CodingKeys.clipExtent, \Self.coefficient as KeyPath : CodingKeys.coefficient, \Self.distance as KeyPath : CodingKeys.distance, \Self.extent as KeyPath : CodingKeys.extent, \Self.fit as KeyPath : CodingKeys.fit, \Self.fraction as KeyPath : CodingKeys.fraction, \Self.lobes as KeyPath : CodingKeys.lobes, \Self.parallel as KeyPath : CodingKeys.parallel, \Self.parallels as KeyPath : CodingKeys.parallels, \Self.pointRadius as KeyPath : CodingKeys.pointRadius, \Self.precision as KeyPath : CodingKeys.precision, \Self.radius as KeyPath : CodingKeys.radius, \Self.ratio as KeyPath : CodingKeys.ratio, \Self.reflectX as KeyPath : CodingKeys.reflectX, \Self.reflectY as KeyPath : CodingKeys.reflectY, \Self.rotate as KeyPath : CodingKeys.rotate, \Self.scale as KeyPath : CodingKeys.scale, \Self.size as KeyPath : CodingKeys.size, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.tilt as KeyPath : CodingKeys.tilt, \Self.translate as KeyPath : CodingKeys.translate, \Self.type as KeyPath : CodingKeys.type]

    public init(center: CenterChoice? = nil, clipAngle: ClipAngleChoice? = nil, clipExtent: ClipExtentChoice? = nil, coefficient: CoefficientChoice? = nil, distance: DistanceChoice? = nil, extent: ExtentChoice? = nil, fit: FitChoice? = nil, fraction: FractionChoice? = nil, lobes: LobesChoice? = nil, parallel: ParallelChoice? = nil, parallels: ParallelsChoice? = nil, pointRadius: PointRadiusChoice? = nil, precision: PrecisionChoice? = nil, radius: RadiusChoice? = nil, ratio: RatioChoice? = nil, reflectX: ReflectXChoice? = nil, reflectY: ReflectYChoice? = nil, rotate: RotateChoice? = nil, scale: ScaleChoice? = nil, size: SizeChoice? = nil, spacing: SpacingChoice? = nil, tilt: TiltChoice? = nil, translate: TranslateChoice? = nil, type: TypeChoice? = nil) {
        self.center = center 
        self.clipAngle = clipAngle 
        self.clipExtent = clipExtent 
        self.coefficient = coefficient 
        self.distance = distance 
        self.extent = extent 
        self.fit = fit 
        self.fraction = fraction 
        self.lobes = lobes 
        self.parallel = parallel 
        self.parallels = parallels 
        self.pointRadius = pointRadius 
        self.precision = precision 
        self.radius = radius 
        self.ratio = ratio 
        self.reflectX = reflectX 
        self.reflectY = reflectY 
        self.rotate = rotate 
        self.scale = scale 
        self.size = size 
        self.spacing = spacing 
        self.tilt = tilt 
        self.translate = translate 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.clipAngle = try values.decodeOptional(ClipAngleChoice.self, forKey: .clipAngle) 
        self.clipExtent = try values.decodeOptional(ClipExtentChoice.self, forKey: .clipExtent) 
        self.coefficient = try values.decodeOptional(CoefficientChoice.self, forKey: .coefficient) 
        self.distance = try values.decodeOptional(DistanceChoice.self, forKey: .distance) 
        self.extent = try values.decodeOptional(ExtentChoice.self, forKey: .extent) 
        self.fit = try values.decodeOptional(FitChoice.self, forKey: .fit) 
        self.fraction = try values.decodeOptional(FractionChoice.self, forKey: .fraction) 
        self.lobes = try values.decodeOptional(LobesChoice.self, forKey: .lobes) 
        self.parallel = try values.decodeOptional(ParallelChoice.self, forKey: .parallel) 
        self.parallels = try values.decodeOptional(ParallelsChoice.self, forKey: .parallels) 
        self.pointRadius = try values.decodeOptional(PointRadiusChoice.self, forKey: .pointRadius) 
        self.precision = try values.decodeOptional(PrecisionChoice.self, forKey: .precision) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.ratio = try values.decodeOptional(RatioChoice.self, forKey: .ratio) 
        self.reflectX = try values.decodeOptional(ReflectXChoice.self, forKey: .reflectX) 
        self.reflectY = try values.decodeOptional(ReflectYChoice.self, forKey: .reflectY) 
        self.rotate = try values.decodeOptional(RotateChoice.self, forKey: .rotate) 
        self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.tilt = try values.decodeOptional(TiltChoice.self, forKey: .tilt) 
        self.translate = try values.decodeOptional(TranslateChoice.self, forKey: .translate) 
        self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
    }

    /// Generated by Curio
    public typealias CenterChoice = OneOf<Vector2Number>.Or<ExprRef>

    /// Generated by Curio
    public typealias ClipAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ClipExtentChoice = OneOf<Vector2Vector2Number>.Or<ExprRef>

    /// Generated by Curio
    public typealias CoefficientChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DistanceChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ExtentChoice = OneOf<Vector2Vector2Number>.Or<ExprRef>

    /// Generated by Curio
    public typealias FitChoice = OneOf<[GeoJsonFeature]>.Or<[Fit]>.Or<ExprRef>

    /// Generated by Curio
    public typealias FractionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LobesChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParallelChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParallelsChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias PointRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PrecisionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias RatioChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias ReflectXChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias ReflectYChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias RotateChoice = OneOf<OneOf<Vector2Number>.Or<Vector3Number>>.Or<ExprRef>

    /// The projection’s scale (zoom) factor, overriding automatic fitting. The default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, scale factor values are not equivalent across projections.
    /// Generated by Curio
    public typealias ScaleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SizeChoice = OneOf<Vector2Number>.Or<ExprRef>

    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TiltChoice = OneOf<Double>.Or<ExprRef>

    /// The projection’s translation offset as a two-element array `[tx, ty]`.
    /// Generated by Curio
    public typealias TranslateChoice = OneOf<Vector2Number>.Or<ExprRef>

    /// The cartographic projection to use. This value is case-insensitive, for example `"albers"` and `"Albers"` indicate the same projection type. You can find all valid projection types [in the documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).
    /// __Default value:__ `equalEarth`
    /// Generated by Curio
    public typealias TypeChoice = OneOf<ProjectionType>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case center
        case clipAngle
        case clipExtent
        case coefficient
        case distance
        case extent
        case fit
        case fraction
        case lobes
        case parallel
        case parallels
        case pointRadius
        case precision
        case radius
        case ratio
        case reflectX
        case reflectY
        case rotate
        case scale
        case size
        case spacing
        case tilt
        case translate
        case type
        public var keyDescription: String? {
            switch self {
            case .center: return nil
            case .clipAngle: return nil
            case .clipExtent: return nil
            case .coefficient: return nil
            case .distance: return nil
            case .extent: return nil
            case .fit: return nil
            case .fraction: return nil
            case .lobes: return nil
            case .parallel: return nil
            case .parallels: return nil
            case .pointRadius: return nil
            case .precision: return nil
            case .radius: return nil
            case .ratio: return nil
            case .reflectX: return nil
            case .reflectY: return nil
            case .rotate: return nil
            case .scale: return "The projection’s scale (zoom) factor, overriding automatic fitting. The default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, scale factor values are not equivalent across projections."
            case .size: return nil
            case .spacing: return nil
            case .tilt: return nil
            case .translate: return "The projection’s translation offset as a two-element array `[tx, ty]`."
            case .type: return "The cartographic projection to use. This value is case-insensitive, for example `\"albers\"` and `\"Albers\"` indicate the same projection type. You can find all valid projection types [in the documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).\n\n__Default value:__ `equalEarth`"
             } 
        }

        public typealias CodingOwner = Projection
    }
}

/// Generated by Curio
public struct QuantileTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output field names for the probability and quantile values.
    /// __Default value:__ `["prob", "value"]`
    public var `as`: [FieldName]?
    /// The data fields to group by. If not specified, a single group containing all data objects will be used.
    public var groupby: [FieldName]?
    /// An array of probabilities in the range (0, 1) for which to compute quantile values. If not specified, the *step* parameter will be used.
    public var probs: [ProbsItem]?
    /// The data field for which to perform quantile estimation.
    public var quantile: FieldName
    /// A probability step size (default 0.01) for sampling quantile values. All values from one-half the step size up to 1 (exclusive) will be sampled. This parameter is only used if the *probs* parameter is not provided.
    public var step: Double?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.groupby as KeyPath, \Self.probs as KeyPath, \Self.quantile as KeyPath, \Self.step as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.probs as KeyPath : CodingKeys.probs, \Self.quantile as KeyPath : CodingKeys.quantile, \Self.step as KeyPath : CodingKeys.step]

    public init(id: TransformId? = nil, `as`: [FieldName]? = nil, groupby: [FieldName]? = nil, probs: [ProbsItem]? = nil, quantile: FieldName, step: Double? = nil) {
        self.id = id 
        self.`as` = `as` 
        self.groupby = groupby 
        self.probs = probs 
        self.quantile = quantile 
        self.step = step 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decodeOptional([FieldName].self, forKey: .`as`) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
        self.probs = try values.decodeOptional([ProbsItem].self, forKey: .probs) 
        self.quantile = try values.decode(FieldName.self, forKey: .quantile) 
        self.step = try values.decodeOptional(Double.self, forKey: .step) 
    }

    public typealias ProbsItem = Double

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case groupby
        case probs
        case quantile
        case step
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output field names for the probability and quantile values.\n\n__Default value:__ `[\"prob\", \"value\"]`"
            case .groupby: return "The data fields to group by. If not specified, a single group containing all data objects will be used."
            case .probs: return "An array of probabilities in the range (0, 1) for which to compute quantile values. If not specified, the *step* parameter will be used."
            case .quantile: return "The data field for which to perform quantile estimation."
            case .step: return "A probability step size (default 0.01) for sampling quantile values. All values from one-half the step size up to 1 (exclusive) will be sampled. This parameter is only used if the *probs* parameter is not provided."
             } 
        }

        public typealias CodingOwner = QuantileTransform
    }
}

/// Generated by Curio
public struct RangeConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for categorical data.
    public var category: CategoryChoice?
    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for diverging quantitative ramps.
    public var diverging: DivergingChoice?
    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for quantitative heatmaps.
    public var heatmap: HeatmapChoice?
    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for rank-ordered data.
    public var ordinal: OrdinalChoice?
    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for sequential quantitative ramps.
    public var ramp: RampChoice?
    /// Array of [symbol](https://vega.github.io/vega/docs/marks/symbol/) names or paths for the default shape palette.
    public var symbol: [SymbolShape]?
    public static let codingKeyPaths = (\Self.category as KeyPath, \Self.diverging as KeyPath, \Self.heatmap as KeyPath, \Self.ordinal as KeyPath, \Self.ramp as KeyPath, \Self.symbol as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.category as KeyPath : CodingKeys.category, \Self.diverging as KeyPath : CodingKeys.diverging, \Self.heatmap as KeyPath : CodingKeys.heatmap, \Self.ordinal as KeyPath : CodingKeys.ordinal, \Self.ramp as KeyPath : CodingKeys.ramp, \Self.symbol as KeyPath : CodingKeys.symbol]

    public init(category: CategoryChoice? = nil, diverging: DivergingChoice? = nil, heatmap: HeatmapChoice? = nil, ordinal: OrdinalChoice? = nil, ramp: RampChoice? = nil, symbol: [SymbolShape]? = nil) {
        self.category = category 
        self.diverging = diverging 
        self.heatmap = heatmap 
        self.ordinal = ordinal 
        self.ramp = ramp 
        self.symbol = symbol 
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.category = try values.decodeOptional(CategoryChoice.self, forKey: .category) 
        self.diverging = try values.decodeOptional(DivergingChoice.self, forKey: .diverging) 
        self.heatmap = try values.decodeOptional(HeatmapChoice.self, forKey: .heatmap) 
        self.ordinal = try values.decodeOptional(OrdinalChoice.self, forKey: .ordinal) 
        self.ramp = try values.decodeOptional(RampChoice.self, forKey: .ramp) 
        self.symbol = try values.decodeOptional([SymbolShape].self, forKey: .symbol) 
    }

    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for categorical data.
    /// Generated by Curio
    public typealias CategoryChoice = OneOf<RangeScheme>.Or<[ColorLiteral]>

    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for diverging quantitative ramps.
    /// Generated by Curio
    public typealias DivergingChoice = OneOf<RangeScheme>.Or<[ColorLiteral]>

    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for quantitative heatmaps.
    /// Generated by Curio
    public typealias HeatmapChoice = OneOf<RangeScheme>.Or<[ColorLiteral]>

    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for rank-ordered data.
    /// Generated by Curio
    public typealias OrdinalChoice = OneOf<RangeScheme>.Or<[ColorLiteral]>

    /// Default [color scheme](https://vega.github.io/vega/docs/schemes/) for sequential quantitative ramps.
    /// Generated by Curio
    public typealias RampChoice = OneOf<RangeScheme>.Or<[ColorLiteral]>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case category
        case diverging
        case heatmap
        case ordinal
        case ramp
        case symbol
        public var keyDescription: String? {
            switch self {
            case .category: return "Default [color scheme](https://vega.github.io/vega/docs/schemes/) for categorical data."
            case .diverging: return "Default [color scheme](https://vega.github.io/vega/docs/schemes/) for diverging quantitative ramps."
            case .heatmap: return "Default [color scheme](https://vega.github.io/vega/docs/schemes/) for quantitative heatmaps."
            case .ordinal: return "Default [color scheme](https://vega.github.io/vega/docs/schemes/) for rank-ordered data."
            case .ramp: return "Default [color scheme](https://vega.github.io/vega/docs/schemes/) for sequential quantitative ramps."
            case .symbol: return "Array of [symbol](https://vega.github.io/vega/docs/marks/symbol/) names or paths for the default shape palette."
             } 
        }

        public typealias CodingOwner = RangeConfig
    }
}

public struct RangeScheme : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<RangeEnum>.Or<RangeRaw>.Or<CountExtentSchemeType>

    public init(rawValue: OneOf<RangeEnum>.Or<RangeRaw>.Or<CountExtentSchemeType>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<RangeEnum>.Or<RangeRaw>.Or<CountExtentSchemeType>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct CountExtentSchemeType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        public var count: Double?
        public var extent: [ExtentItem]?
        public var scheme: SchemeChoice
        public static let codingKeyPaths = (\Self.count as KeyPath, \Self.extent as KeyPath, \Self.scheme as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.count as KeyPath : CodingKeys.count, \Self.extent as KeyPath : CodingKeys.extent, \Self.scheme as KeyPath : CodingKeys.scheme]

        public init(count: Double? = nil, extent: [ExtentItem]? = nil, scheme: SchemeChoice) {
            self.count = count 
            self.extent = extent 
            self.scheme = scheme 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.count = try values.decodeOptional(Double.self, forKey: .count) 
            self.extent = try values.decodeOptional([ExtentItem].self, forKey: .extent) 
            self.scheme = try values.decode(SchemeChoice.self, forKey: .scheme) 
        }

        public typealias ExtentItem = Double

        /// Generated by Curio
        public typealias SchemeChoice = OneOf<OneOrMany<String>>.Or<ColorScheme>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case count
            case extent
            case scheme
            public var keyDescription: String? {
                switch self {
                case .count: return nil
                case .extent: return nil
                case .scheme: return nil
                 } 
            }

            public typealias CodingOwner = CountExtentSchemeType
        }
    }
}

/// Generated by Curio
public struct RectConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var align: AlignChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    public var ariaRole: AriaRoleChoice?
    public var ariaRoleDescription: AriaRoleDescriptionChoice?
    public var aspect: AspectChoice?
    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var baseline: BaselineChoice?
    /// Offset between bars for binned field. The ideal value for this is either 0 (preferred by statisticians) or 1 (Vega-Lite default, D3 example style).
    /// __Default value:__ `1`
    public var binSpacing: Double?
    public var blend: BlendChoice?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    /// The default size of the bars on continuous scales.
    /// __Default value:__ `5`
    public var continuousBandSize: Double?
    public var cornerRadius: CornerRadiusChoice?
    public var cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice?
    public var cornerRadiusBottomRight: CornerRadiusBottomRightChoice?
    public var cornerRadiusTopLeft: CornerRadiusTopLeftChoice?
    public var cornerRadiusTopRight: CornerRadiusTopRightChoice?
    public var cursor: CursorChoice?
    public var description: DescriptionChoice?
    public var dir: DirChoice?
    /// The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars.
    public var discreteBandSize: DiscreteBandSizeChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var ellipsis: EllipsisChoice?
    public var endAngle: EndAngleChoice?
    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// Whether the mark's color should be used as fill color instead of stroke color.
    /// __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.
    /// __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    public var filled: Bool?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var height: HeightChoice?
    public var href: HrefChoice?
    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    public var innerRadius: InnerRadiusChoice?
    public var interpolate: InterpolateChoice?
    /// Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
    /// - If set to `"filter"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).
    /// - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
    public var invalid: Invalid?
    public var limit: LimitChoice?
    public var lineBreak: LineBreakChoice?
    public var lineHeight: LineHeightChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources.
    public var order: Order?
    /// The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored.
    public var orient: Orientation?
    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    public var outerRadius: OuterRadiusChoice?
    public var padAngle: PadAngleChoice?
    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    public var radius: RadiusChoice?
    /// The secondary (inner) radius in pixels of arc marks.
    public var radius2: Radius2Choice?
    public var shape: SymbolShape?
    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    public var size: SizeChoice?
    public var smooth: SmoothChoice?
    public var startAngle: StartAngleChoice?
    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOffset: StrokeOffsetChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    public var tension: TensionChoice?
    public var text: TextChoice?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaChoice?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Choice?
    /// Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step.
    public var timeUnitBandPosition: Double?
    /// Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step.
    public var timeUnitBandSize: Double?
    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    public var tooltip: TooltipChoice?
    public var url: UrlChoice?
    public var width: WidthChoice?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XChoice?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Choice?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YChoice?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Choice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.aspect as KeyPath, \Self.baseline as KeyPath, \Self.binSpacing as KeyPath, \Self.blend as KeyPath, \Self.color as KeyPath, \Self.continuousBandSize as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cursor as KeyPath, \Self.description as KeyPath, \Self.dir as KeyPath, \Self.discreteBandSize as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.ellipsis as KeyPath, \Self.endAngle as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.filled as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.height as KeyPath, \Self.href as KeyPath, \Self.innerRadius as KeyPath, \Self.interpolate as KeyPath, \Self.invalid as KeyPath, \Self.limit as KeyPath, \Self.lineBreak as KeyPath, \Self.lineHeight as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.orient as KeyPath, \Self.outerRadius as KeyPath, \Self.padAngle as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.smooth as KeyPath, \Self.startAngle as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.tension as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.timeUnitBandPosition as KeyPath, \Self.timeUnitBandSize as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.width as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.binSpacing as KeyPath : CodingKeys.binSpacing, \Self.blend as KeyPath : CodingKeys.blend, \Self.color as KeyPath : CodingKeys.color, \Self.continuousBandSize as KeyPath : CodingKeys.continuousBandSize, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.description as KeyPath : CodingKeys.description, \Self.dir as KeyPath : CodingKeys.dir, \Self.discreteBandSize as KeyPath : CodingKeys.discreteBandSize, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.endAngle as KeyPath : CodingKeys.endAngle, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.filled as KeyPath : CodingKeys.filled, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.height as KeyPath : CodingKeys.height, \Self.href as KeyPath : CodingKeys.href, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.invalid as KeyPath : CodingKeys.invalid, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.orient as KeyPath : CodingKeys.orient, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.startAngle as KeyPath : CodingKeys.startAngle, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.tension as KeyPath : CodingKeys.tension, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.timeUnitBandPosition as KeyPath : CodingKeys.timeUnitBandPosition, \Self.timeUnitBandSize as KeyPath : CodingKeys.timeUnitBandSize, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.width as KeyPath : CodingKeys.width, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2]

    public init(align: AlignChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, ariaRole: AriaRoleChoice? = nil, ariaRoleDescription: AriaRoleDescriptionChoice? = nil, aspect: AspectChoice? = nil, baseline: BaselineChoice? = nil, binSpacing: Double? = nil, blend: BlendChoice? = nil, color: ColorChoice? = nil, continuousBandSize: Double? = nil, cornerRadius: CornerRadiusChoice? = nil, cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice? = nil, cornerRadiusBottomRight: CornerRadiusBottomRightChoice? = nil, cornerRadiusTopLeft: CornerRadiusTopLeftChoice? = nil, cornerRadiusTopRight: CornerRadiusTopRightChoice? = nil, cursor: CursorChoice? = nil, description: DescriptionChoice? = nil, dir: DirChoice? = nil, discreteBandSize: DiscreteBandSizeChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, ellipsis: EllipsisChoice? = nil, endAngle: EndAngleChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, filled: Bool? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, height: HeightChoice? = nil, href: HrefChoice? = nil, innerRadius: InnerRadiusChoice? = nil, interpolate: InterpolateChoice? = nil, invalid: Invalid? = nil, limit: LimitChoice? = nil, lineBreak: LineBreakChoice? = nil, lineHeight: LineHeightChoice? = nil, opacity: OpacityChoice? = nil, order: Order? = nil, orient: Orientation? = nil, outerRadius: OuterRadiusChoice? = nil, padAngle: PadAngleChoice? = nil, radius: RadiusChoice? = nil, radius2: Radius2Choice? = nil, shape: SymbolShape? = nil, size: SizeChoice? = nil, smooth: SmoothChoice? = nil, startAngle: StartAngleChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOffset: StrokeOffsetChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, tension: TensionChoice? = nil, text: TextChoice? = nil, theta: ThetaChoice? = nil, theta2: Theta2Choice? = nil, timeUnitBandPosition: Double? = nil, timeUnitBandSize: Double? = nil, tooltip: TooltipChoice? = nil, url: UrlChoice? = nil, width: WidthChoice? = nil, x: XChoice? = nil, x2: X2Choice? = nil, y: YChoice? = nil, y2: Y2Choice? = nil) {
        self.align = align 
        self.angle = angle 
        self.aria = aria 
        self.ariaRole = ariaRole 
        self.ariaRoleDescription = ariaRoleDescription 
        self.aspect = aspect 
        self.baseline = baseline 
        self.binSpacing = binSpacing 
        self.blend = blend 
        self.color = color 
        self.continuousBandSize = continuousBandSize 
        self.cornerRadius = cornerRadius 
        self.cornerRadiusBottomLeft = cornerRadiusBottomLeft 
        self.cornerRadiusBottomRight = cornerRadiusBottomRight 
        self.cornerRadiusTopLeft = cornerRadiusTopLeft 
        self.cornerRadiusTopRight = cornerRadiusTopRight 
        self.cursor = cursor 
        self.description = description 
        self.dir = dir 
        self.discreteBandSize = discreteBandSize 
        self.dx = dx 
        self.dy = dy 
        self.ellipsis = ellipsis 
        self.endAngle = endAngle 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.filled = filled 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.height = height 
        self.href = href 
        self.innerRadius = innerRadius 
        self.interpolate = interpolate 
        self.invalid = invalid 
        self.limit = limit 
        self.lineBreak = lineBreak 
        self.lineHeight = lineHeight 
        self.opacity = opacity 
        self.order = order 
        self.orient = orient 
        self.outerRadius = outerRadius 
        self.padAngle = padAngle 
        self.radius = radius 
        self.radius2 = radius2 
        self.shape = shape 
        self.size = size 
        self.smooth = smooth 
        self.startAngle = startAngle 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOffset = strokeOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.tension = tension 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.timeUnitBandPosition = timeUnitBandPosition 
        self.timeUnitBandSize = timeUnitBandSize 
        self.tooltip = tooltip 
        self.url = url 
        self.width = width 
        self.x = x 
        self.x2 = x2 
        self.y = y 
        self.y2 = y2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.ariaRole = try values.decodeOptional(AriaRoleChoice.self, forKey: .ariaRole) 
        self.ariaRoleDescription = try values.decodeOptional(AriaRoleDescriptionChoice.self, forKey: .ariaRoleDescription) 
        self.aspect = try values.decodeOptional(AspectChoice.self, forKey: .aspect) 
        self.baseline = try values.decodeOptional(BaselineChoice.self, forKey: .baseline) 
        self.binSpacing = try values.decodeOptional(Double.self, forKey: .binSpacing) 
        self.blend = try values.decodeOptional(BlendChoice.self, forKey: .blend) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.continuousBandSize = try values.decodeOptional(Double.self, forKey: .continuousBandSize) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cornerRadiusBottomLeft = try values.decodeOptional(CornerRadiusBottomLeftChoice.self, forKey: .cornerRadiusBottomLeft) 
        self.cornerRadiusBottomRight = try values.decodeOptional(CornerRadiusBottomRightChoice.self, forKey: .cornerRadiusBottomRight) 
        self.cornerRadiusTopLeft = try values.decodeOptional(CornerRadiusTopLeftChoice.self, forKey: .cornerRadiusTopLeft) 
        self.cornerRadiusTopRight = try values.decodeOptional(CornerRadiusTopRightChoice.self, forKey: .cornerRadiusTopRight) 
        self.cursor = try values.decodeOptional(CursorChoice.self, forKey: .cursor) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.dir = try values.decodeOptional(DirChoice.self, forKey: .dir) 
        self.discreteBandSize = try values.decodeOptional(DiscreteBandSizeChoice.self, forKey: .discreteBandSize) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.ellipsis = try values.decodeOptional(EllipsisChoice.self, forKey: .ellipsis) 
        self.endAngle = try values.decodeOptional(EndAngleChoice.self, forKey: .endAngle) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.filled = try values.decodeOptional(Bool.self, forKey: .filled) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.href = try values.decodeOptional(HrefChoice.self, forKey: .href) 
        self.innerRadius = try values.decodeOptional(InnerRadiusChoice.self, forKey: .innerRadius) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.invalid = try values.decodeOptional(Invalid.self, forKey: .invalid) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.order = try values.decodeOptional(Order.self, forKey: .order) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outerRadius = try values.decodeOptional(OuterRadiusChoice.self, forKey: .outerRadius) 
        self.padAngle = try values.decodeOptional(PadAngleChoice.self, forKey: .padAngle) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Choice.self, forKey: .radius2) 
        self.shape = try values.decodeOptional(SymbolShape.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.smooth = try values.decodeOptional(SmoothChoice.self, forKey: .smooth) 
        self.startAngle = try values.decodeOptional(StartAngleChoice.self, forKey: .startAngle) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOffset = try values.decodeOptional(StrokeOffsetChoice.self, forKey: .strokeOffset) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.tension = try values.decodeOptional(TensionChoice.self, forKey: .tension) 
        self.text = try values.decodeOptional(TextChoice.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaChoice.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Choice.self, forKey: .theta2) 
        self.timeUnitBandPosition = try values.decodeOptional(Double.self, forKey: .timeUnitBandPosition) 
        self.timeUnitBandSize = try values.decodeOptional(Double.self, forKey: .timeUnitBandSize) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlChoice.self, forKey: .url) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
        self.x = try values.decodeOptional(XChoice.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Choice.self, forKey: .x2) 
        self.y = try values.decodeOptional(YChoice.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Choice.self, forKey: .y2) 
    }

    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleDescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AspectChoice = OneOf<Bool>.Or<ExprRef>

    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias BaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias BlendChoice = OneOf<Blend>.Or<ExprRef>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CursorChoice = OneOf<Cursor>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DirChoice = OneOf<TextDirection>.Or<ExprRef>

    /// The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars.
    /// Generated by Curio
    public typealias DiscreteBandSizeChoice = OneOf<Double>.Or<RelativeBandSize>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias EllipsisChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias EndAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias HrefChoice = OneOf<URI>.Or<ExprRef>

    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    /// Generated by Curio
    public typealias InnerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<Interpolate>.Or<ExprRef>

    /// Generated by Curio
    public typealias Invalid = Nullable<String>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias Order = Nullable<Bool>

    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    /// Generated by Curio
    public typealias OuterRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PadAngleChoice = OneOf<Double>.Or<ExprRef>

    /// The secondary (inner) radius in pixels of arc marks.
    /// Generated by Curio
    public typealias Radius2Choice = OneOf<Double>.Or<ExprRef>

    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    /// Generated by Curio
    public typealias SizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SmoothChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias StartAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TensionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    /// Generated by Curio
    public typealias Theta2Choice = OneOf<Double>.Or<ExprRef>

    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    /// Generated by Curio
    public typealias ThetaChoice = OneOf<Double>.Or<ExprRef>

    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<Double>.Or<String>.Or<Bool>.Or<TooltipContent>.Or<ExprRef>>

    /// Generated by Curio
    public typealias UrlChoice = OneOf<URI>.Or<ExprRef>

    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<ExprRef>

    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias X2Choice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias XChoice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias Y2Choice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias YChoice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case angle
        case aria
        case ariaRole
        case ariaRoleDescription
        case aspect
        case baseline
        case binSpacing
        case blend
        case color
        case continuousBandSize
        case cornerRadius
        case cornerRadiusBottomLeft
        case cornerRadiusBottomRight
        case cornerRadiusTopLeft
        case cornerRadiusTopRight
        case cursor
        case description
        case dir
        case discreteBandSize
        case dx
        case dy
        case ellipsis
        case endAngle
        case fill
        case fillOpacity
        case filled
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case height
        case href
        case innerRadius
        case interpolate
        case invalid
        case limit
        case lineBreak
        case lineHeight
        case opacity
        case order
        case orient
        case outerRadius
        case padAngle
        case radius
        case radius2
        case shape
        case size
        case smooth
        case startAngle
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOffset
        case strokeOpacity
        case strokeWidth
        case tension
        case text
        case theta
        case theta2
        case timeUnitBandPosition
        case timeUnitBandSize
        case tooltip
        case url
        case width
        case x
        case x2
        case y
        case y2
        public var keyDescription: String? {
            switch self {
            case .align: return "The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `\"left\"`, `\"right\"`, `\"center\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .angle: return nil
            case .aria: return nil
            case .ariaRole: return nil
            case .ariaRoleDescription: return nil
            case .aspect: return nil
            case .baseline: return "For text marks, the vertical text baseline. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, `\"line-bottom\"`, or an expression reference that provides one of the valid values. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.\n\nFor range marks, the vertical alignment of the marks. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .binSpacing: return "Offset between bars for binned field. The ideal value for this is either 0 (preferred by statisticians) or 1 (Vega-Lite default, D3 example style).\n\n__Default value:__ `1`"
            case .blend: return nil
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .continuousBandSize: return "The default size of the bars on continuous scales.\n\n__Default value:__ `5`"
            case .cornerRadius: return nil
            case .cornerRadiusBottomLeft: return nil
            case .cornerRadiusBottomRight: return nil
            case .cornerRadiusTopLeft: return nil
            case .cornerRadiusTopRight: return nil
            case .cursor: return nil
            case .description: return nil
            case .dir: return nil
            case .discreteBandSize: return "The default size of the bars with discrete dimensions. If unspecified, the default size is  `step-2`, which provides 2 pixel offset between bars."
            case .dx: return nil
            case .dy: return nil
            case .ellipsis: return nil
            case .endAngle: return nil
            case .fill: return "Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.\n\n__Default value:__ (None)"
            case .fillOpacity: return nil
            case .filled: return "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.\n\n__Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config)."
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .height: return nil
            case .href: return nil
            case .innerRadius: return "The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`."
            case .interpolate: return nil
            case .invalid: return "Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes."
            case .limit: return nil
            case .lineBreak: return nil
            case .lineHeight: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .order: return "For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources."
            case .orient: return "The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored."
            case .outerRadius: return "The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`."
            case .padAngle: return nil
            case .radius: return "For arc mark, the primary (outer) radius in pixels.\n\nFor text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties."
            case .radius2: return "The secondary (inner) radius in pixels of arc marks."
            case .shape: return nil
            case .size: return "Default size for marks.\n- For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.\n- For `bar`, this represents the band size of the bar, in pixels.\n- For `text`, this represents the font size, in pixels.\n\n__Default value:__\n- `30` for point, circle, square marks; width/height's `step`\n- `2` for bar marks with discrete dimensions;\n- `5` for bar marks with continuous dimensions;\n- `11` for text marks."
            case .smooth: return nil
            case .startAngle: return nil
            case .stroke: return "Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.\n\n__Default value:__ (None)"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOffset: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .tension: return nil
            case .text: return nil
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .timeUnitBandPosition: return "Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step."
            case .timeUnitBandSize: return "Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step."
            case .tooltip: return "The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n\n- If `tooltip` is `true` or `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n- If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n- If set to `null` or `false`, then no tooltip will be used.\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.\n\n__Default value:__ `null`"
            case .url: return nil
            case .width: return nil
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
             } 
        }

        public typealias CodingOwner = RectConfig
    }
}

/// Generated by Curio
public struct RegressionTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output field names for the smoothed points generated by the regression transform.
    /// __Default value:__ The field names of the input x and y values.
    public var `as`: [FieldName]?
    /// A [min, max] domain over the independent (x) field for the starting and ending points of the generated trend line.
    public var extent: [ExtentItem]?
    /// The data fields to group by. If not specified, a single group containing all data objects will be used.
    public var groupby: [FieldName]?
    /// The functional form of the regression model. One of `"linear"`, `"log"`, `"exp"`, `"pow"`, `"quad"`, or `"poly"`.
    /// __Default value:__ `"linear"`
    public var method: LiteralLinearOrLogOrExpOrPowOrQuadOrPoly?
    /// The data field of the independent variable to use a predictor.
    public var on: FieldName
    /// The polynomial order (number of coefficients) for the 'poly' method.
    /// __Default value:__ `3`
    public var order: Double?
    /// A boolean flag indicating if the transform should return the regression model parameters (one object per group), rather than trend line points. The resulting objects include a `coef` array of fitted coefficient values (starting with the intercept term and then including terms of increasing order) and an `rSquared` value (indicating the total variance explained by the model).
    /// __Default value:__ `false`
    public var params: Bool?
    /// The data field of the dependent variable to predict.
    public var regression: FieldName
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.extent as KeyPath, \Self.groupby as KeyPath, \Self.method as KeyPath, \Self.on as KeyPath, \Self.order as KeyPath, \Self.params as KeyPath, \Self.regression as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.extent as KeyPath : CodingKeys.extent, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.method as KeyPath : CodingKeys.method, \Self.on as KeyPath : CodingKeys.on, \Self.order as KeyPath : CodingKeys.order, \Self.params as KeyPath : CodingKeys.params, \Self.regression as KeyPath : CodingKeys.regression]

    public init(id: TransformId? = nil, `as`: [FieldName]? = nil, extent: [ExtentItem]? = nil, groupby: [FieldName]? = nil, method: LiteralLinearOrLogOrExpOrPowOrQuadOrPoly? = nil, on: FieldName, order: Double? = nil, params: Bool? = nil, regression: FieldName) {
        self.id = id 
        self.`as` = `as` 
        self.extent = extent 
        self.groupby = groupby 
        self.method = method 
        self.on = on 
        self.order = order 
        self.params = params 
        self.regression = regression 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decodeOptional([FieldName].self, forKey: .`as`) 
        self.extent = try values.decodeOptional([ExtentItem].self, forKey: .extent) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
        self.method = try values.decodeOptional(LiteralLinearOrLogOrExpOrPowOrQuadOrPoly.self, forKey: .method) 
        self.on = try values.decode(FieldName.self, forKey: .on) 
        self.order = try values.decodeOptional(Double.self, forKey: .order) 
        self.params = try values.decodeOptional(Bool.self, forKey: .params) 
        self.regression = try values.decode(FieldName.self, forKey: .regression) 
    }

    public typealias ExtentItem = Double

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case extent
        case groupby
        case method
        case on
        case order
        case params
        case regression
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output field names for the smoothed points generated by the regression transform.\n\n__Default value:__ The field names of the input x and y values."
            case .extent: return "A [min, max] domain over the independent (x) field for the starting and ending points of the generated trend line."
            case .groupby: return "The data fields to group by. If not specified, a single group containing all data objects will be used."
            case .method: return "The functional form of the regression model. One of `\"linear\"`, `\"log\"`, `\"exp\"`, `\"pow\"`, `\"quad\"`, or `\"poly\"`.\n\n__Default value:__ `\"linear\"`"
            case .on: return "The data field of the independent variable to use a predictor."
            case .order: return "The polynomial order (number of coefficients) for the 'poly' method.\n\n__Default value:__ `3`"
            case .params: return "A boolean flag indicating if the transform should return the regression model parameters (one object per group), rather than trend line points. The resulting objects include a `coef` array of fitted coefficient values (starting with the intercept term and then including terms of increasing order) and an `rSquared` value (indicating the total variance explained by the model).\n\n__Default value:__ `false`"
            case .regression: return "The data field of the dependent variable to predict."
             } 
        }

        public typealias CodingOwner = RegressionTransform
    }

    /// The functional form of the regression model. One of `"linear"`, `"log"`, `"exp"`, `"pow"`, `"quad"`, or `"poly"`.
    /// __Default value:__ `"linear"`
    /// Generated by Curio
    public enum LiteralLinearOrLogOrExpOrPowOrQuadOrPoly : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case linear
        case log
        case exp
        case pow
        case quad
        case poly
    }
}

/// Generated by Curio
public struct RelativeBandSize : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The relative band size.  For example `0.5` means half of the band scale's band width.
    public var band: Double
    public static let codingKeyPaths = (\Self.band as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.band as KeyPath : CodingKeys.band]

    public init(band: Double) {
        self.band = band 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.band = try values.decode(Double.self, forKey: .band) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case band
        public var keyDescription: String? {
            switch self {
            case .band: return "The relative band size.  For example `0.5` means half of the band scale's band width."
             } 
        }

        public typealias CodingOwner = RelativeBandSize
    }
}

/// Generated by Curio
public struct RepeatMapping : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// An array of fields to be repeated horizontally.
    public var column: [FieldName]?
    /// An array of fields to be repeated vertically.
    public var row: [FieldName]?
    public static let codingKeyPaths = (\Self.column as KeyPath, \Self.row as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.column as KeyPath : CodingKeys.column, \Self.row as KeyPath : CodingKeys.row]

    public init(column: [FieldName]? = nil, row: [FieldName]? = nil) {
        self.column = column 
        self.row = row 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.column = try values.decodeOptional([FieldName].self, forKey: .column) 
        self.row = try values.decodeOptional([FieldName].self, forKey: .row) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case column
        case row
        public var keyDescription: String? {
            switch self {
            case .column: return "An array of fields to be repeated horizontally."
            case .row: return "An array of fields to be repeated vertically."
             } 
        }

        public typealias CodingOwner = RepeatMapping
    }
}

/// Reference to a repeated value.
/// Generated by Curio
public struct RepeatRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var `repeat`: LiteralRowOrColumnOrRepeatOrLayer
    public static let codingKeyPaths = (\Self.`repeat` as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.`repeat` as KeyPath : CodingKeys.`repeat`]

    public init(`repeat`: LiteralRowOrColumnOrRepeatOrLayer) {
        self.`repeat` = `repeat` 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.`repeat` = try values.decode(LiteralRowOrColumnOrRepeatOrLayer.self, forKey: .`repeat`) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case `repeat`
        public var keyDescription: String? {
            switch self {
            case .`repeat`: return nil
             } 
        }

        public typealias CodingOwner = RepeatRef
    }

    /// Generated by Curio
    public enum LiteralRowOrColumnOrRepeatOrLayer : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case row
        case column
        case `repeat`
        case layer
    }
}

public struct RepeatSpec : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<NonLayerRepeatSpec>.Or<LayerRepeatSpec>

    public init(rawValue: OneOf<NonLayerRepeatSpec>.Or<LayerRepeatSpec>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<NonLayerRepeatSpec>.Or<LayerRepeatSpec>) {
        self.rawValue = rawValue 
    }
}

/// Defines how scales, axes, and legends from different specs should be combined. Resolve is a mapping from `scale`, `axis`, and `legend` to a mapping from channels to resolutions. Scales and guides can be resolved to be `"independent"` or `"shared"`.
/// Generated by Curio
public struct Resolve : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var axis: AxisResolveMap?
    public var legend: LegendResolveMap?
    public var scale: ScaleResolveMap?
    public static let codingKeyPaths = (\Self.axis as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.axis as KeyPath : CodingKeys.axis, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale]

    public init(axis: AxisResolveMap? = nil, legend: LegendResolveMap? = nil, scale: ScaleResolveMap? = nil) {
        self.axis = axis 
        self.legend = legend 
        self.scale = scale 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.axis = try values.decodeOptional(AxisResolveMap.self, forKey: .axis) 
        self.legend = try values.decodeOptional(LegendResolveMap.self, forKey: .legend) 
        self.scale = try values.decodeOptional(ScaleResolveMap.self, forKey: .scale) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case axis
        case legend
        case scale
        public var keyDescription: String? {
            switch self {
            case .axis: return nil
            case .legend: return nil
            case .scale: return nil
             } 
        }

        public typealias CodingOwner = Resolve
    }
}

/// Generated by Curio
public struct RowColBoolean : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var column: Bool?
    public var row: Bool?
    public static let codingKeyPaths = (\Self.column as KeyPath, \Self.row as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.column as KeyPath : CodingKeys.column, \Self.row as KeyPath : CodingKeys.row]

    public init(column: Bool? = nil, row: Bool? = nil) {
        self.column = column 
        self.row = row 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.column = try values.decodeOptional(Bool.self, forKey: .column) 
        self.row = try values.decodeOptional(Bool.self, forKey: .row) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case column
        case row
        public var keyDescription: String? {
            switch self {
            case .column: return nil
            case .row: return nil
             } 
        }

        public typealias CodingOwner = RowColBoolean
    }
}

/// Generated by Curio
public struct RowColLayoutAlign : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var column: LayoutAlign?
    public var row: LayoutAlign?
    public static let codingKeyPaths = (\Self.column as KeyPath, \Self.row as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.column as KeyPath : CodingKeys.column, \Self.row as KeyPath : CodingKeys.row]

    public init(column: LayoutAlign? = nil, row: LayoutAlign? = nil) {
        self.column = column 
        self.row = row 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.column = try values.decodeOptional(LayoutAlign.self, forKey: .column) 
        self.row = try values.decodeOptional(LayoutAlign.self, forKey: .row) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case column
        case row
        public var keyDescription: String? {
            switch self {
            case .column: return nil
            case .row: return nil
             } 
        }

        public typealias CodingOwner = RowColLayoutAlign
    }
}

/// Generated by Curio
public struct RowColNumber : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var column: Double?
    public var row: Double?
    public static let codingKeyPaths = (\Self.column as KeyPath, \Self.row as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.column as KeyPath : CodingKeys.column, \Self.row as KeyPath : CodingKeys.row]

    public init(column: Double? = nil, row: Double? = nil) {
        self.column = column 
        self.row = row 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.column = try values.decodeOptional(Double.self, forKey: .column) 
        self.row = try values.decodeOptional(Double.self, forKey: .row) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case column
        case row
        public var keyDescription: String? {
            switch self {
            case .column: return nil
            case .row: return nil
             } 
        }

        public typealias CodingOwner = RowColNumber
    }
}

/// Generated by Curio
public struct RowColumnEncodingFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// The alignment to apply to row/column facet's subplot. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// __Default value:__ `"all"`.
    public var align: LayoutAlign?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// Boolean flag indicating if facet's subviews should be centered relative to their respective rows or columns.
    /// __Default value:__ `false`
    public var center: Bool?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// An object defining properties of a facet's header.
    public var header: HeaderChoice?
    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` is not supported for `row` and `column`.
    public var sort: SortChoice?
    /// The spacing in pixels between facet's sub-views.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: Double?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.align as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.center as KeyPath, \Self.field as KeyPath, \Self.header as KeyPath, \Self.sort as KeyPath, \Self.spacing as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.align as KeyPath : CodingKeys.align, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.center as KeyPath : CodingKeys.center, \Self.field as KeyPath : CodingKeys.field, \Self.header as KeyPath : CodingKeys.header, \Self.sort as KeyPath : CodingKeys.sort, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, align: LayoutAlign? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, center: Bool? = nil, field: SourceColumnRef? = nil, header: HeaderChoice? = nil, sort: SortChoice? = nil, spacing: Double? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.align = align 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.center = center 
        self.field = field 
        self.header = header 
        self.sort = sort 
        self.spacing = spacing 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.align = try values.decodeOptional(LayoutAlign.self, forKey: .align) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.center = try values.decodeOptional(Bool.self, forKey: .center) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.header = try values.decodeOptional(HeaderChoice.self, forKey: .header) 
        self.sort = try values.decodeOptional(SortChoice.self, forKey: .sort) 
        self.spacing = try values.decodeOptional(Double.self, forKey: .spacing) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

    /// An object defining properties of a facet's header.
    /// Generated by Curio
    public typealias HeaderChoice = Nullable<HeaderDef>

    /// Sort order for the encoded field.
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
    /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    /// __Default value:__ `"ascending"`
    /// __Note:__ `null` is not supported for `row` and `column`.
    /// Generated by Curio
    public typealias SortChoice = Nullable<OneOf<SortArray>.Or<SortOrder>.Or<EncodingSortField>>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case align
        case bandPosition
        case bin
        case center
        case field
        case header
        case sort
        case spacing
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .align: return "The alignment to apply to row/column facet's subplot. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\n__Default value:__ `\"all\"`."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .center: return "Boolean flag indicating if facet's subviews should be centered relative to their respective rows or columns.\n\n__Default value:__ `false`"
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .header: return "An object defining properties of a facet's header."
            case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` is not supported for `row` and `column`."
            case .spacing: return "The spacing in pixels between facet's sub-views.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = RowColumnEncodingFieldDef
    }
}

/// Generated by Curio
public struct SampleTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The maximum number of data objects to include in the sample.
    /// __Default value:__ `1000`
    public var sample: Double
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.sample as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.sample as KeyPath : CodingKeys.sample]

    public init(id: TransformId? = nil, sample: Double) {
        self.id = id 
        self.sample = sample 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.sample = try values.decode(Double.self, forKey: .sample) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case sample
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .sample: return "The maximum number of data objects to include in the sample.\n\n__Default value:__ `1000`"
             } 
        }

        public typealias CodingOwner = SampleTransform
    }
}

/// Generated by Curio
public struct ScaleBinParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The starting (lowest-valued) bin boundary.
    /// __Default value:__ The lowest value of the scale domain will be used.
    public var start: Double?
    /// The step size defining the bin interval width.
    public var step: Double
    /// The stopping (highest-valued) bin boundary.
    /// __Default value:__ The highest value of the scale domain will be used.
    public var stop: Double?
    public static let codingKeyPaths = (\Self.start as KeyPath, \Self.step as KeyPath, \Self.stop as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.start as KeyPath : CodingKeys.start, \Self.step as KeyPath : CodingKeys.step, \Self.stop as KeyPath : CodingKeys.stop]

    public init(start: Double? = nil, step: Double, stop: Double? = nil) {
        self.start = start 
        self.step = step 
        self.stop = stop 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.start = try values.decodeOptional(Double.self, forKey: .start) 
        self.step = try values.decode(Double.self, forKey: .step) 
        self.stop = try values.decodeOptional(Double.self, forKey: .stop) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case start
        case step
        case stop
        public var keyDescription: String? {
            switch self {
            case .start: return "The starting (lowest-valued) bin boundary.\n\n__Default value:__ The lowest value of the scale domain will be used."
            case .step: return "The step size defining the bin interval width."
            case .stop: return "The stopping (highest-valued) bin boundary.\n\n__Default value:__ The highest value of the scale domain will be used."
             } 
        }

        public typealias CodingOwner = ScaleBinParams
    }
}

public struct ScaleBins : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<[Double]>.Or<ScaleBinParams>

    public init(rawValue: OneOf<[Double]>.Or<ScaleBinParams>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<[Double]>.Or<ScaleBinParams>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct ScaleConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Default inner padding for `x` and `y` band-ordinal scales.
    /// __Default value:__
    /// - `barBandPaddingInner` for bar marks (`0.1` by default)
    /// - `rectBandPaddingInner` for rect and other marks (`0` by default)
    public var bandPaddingInner: BandPaddingInnerChoice?
    /// Default outer padding for `x` and `y` band-ordinal scales.
    /// __Default value:__ `paddingInner/2` (which makes _width/height = number of unique values * step_)
    public var bandPaddingOuter: BandPaddingOuterChoice?
    /// Default inner padding for `x` and `y` band-ordinal scales of `"bar"` marks.
    /// __Default value:__ `0.1`
    public var barBandPaddingInner: BarBandPaddingInnerChoice?
    /// If true, values that exceed the data domain are clamped to either the minimum or maximum range value
    public var clamp: ClampChoice?
    /// Default padding for continuous scales.
    /// __Default:__ `5` for continuous x-scale of a vertical bar and continuous y-scale of a horizontal bar.; `0` otherwise.
    public var continuousPadding: ContinuousPaddingChoice?
    /// The default max value for mapping quantitative fields to bar's size/bandSize.
    /// If undefined (default), we will use the axis's size (width or height) - 1.
    public var maxBandSize: Double?
    /// The default max value for mapping quantitative fields to text's size/fontSize.
    /// __Default value:__ `40`
    public var maxFontSize: Double?
    /// Default max opacity for mapping a field to opacity.
    /// __Default value:__ `0.8`
    public var maxOpacity: Double?
    /// Default max value for point size scale.
    public var maxSize: Double?
    /// Default max strokeWidth for the scale of strokeWidth for rule and line marks and of size for trail marks.
    /// __Default value:__ `4`
    public var maxStrokeWidth: Double?
    /// The default min value for mapping quantitative fields to bar and tick's size/bandSize scale with zero=false.
    /// __Default value:__ `2`
    public var minBandSize: Double?
    /// The default min value for mapping quantitative fields to tick's size/fontSize scale with zero=false
    /// __Default value:__ `8`
    public var minFontSize: Double?
    /// Default minimum opacity for mapping a field to opacity.
    /// __Default value:__ `0.3`
    public var minOpacity: Double?
    /// Default minimum value for point size scale with zero=false.
    /// __Default value:__ `9`
    public var minSize: Double?
    /// Default minimum strokeWidth for the scale of strokeWidth for rule and line marks and of size for trail marks with zero=false.
    /// __Default value:__ `1`
    public var minStrokeWidth: Double?
    /// Default outer padding for `x` and `y` point-ordinal scales.
    /// __Default value:__ `0.5` (which makes _width/height = number of unique values * step_)
    public var pointPadding: PointPaddingChoice?
    /// Default range cardinality for [`quantile`](https://vega.github.io/vega-lite/docs/scale.html#quantile) scale.
    /// __Default value:__ `4`
    public var quantileCount: Double?
    /// Default range cardinality for [`quantize`](https://vega.github.io/vega-lite/docs/scale.html#quantize) scale.
    /// __Default value:__ `4`
    public var quantizeCount: Double?
    /// Default inner padding for `x` and `y` band-ordinal scales of `"rect"` marks.
    /// __Default value:__ `0`
    public var rectBandPaddingInner: RectBandPaddingInnerChoice?
    /// If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid. (Only available for `x`, `y`, and `size` scales.)
    public var round: RoundChoice?
    /// Use the source data range before aggregation as scale domain instead of aggregated data for aggregate axis.
    /// This is equivalent to setting `domain` to `"unaggregate"` for aggregated _quantitative_ fields by default.
    /// This property only works with aggregate functions that produce values within the raw data domain (`"mean"`, `"average"`, `"median"`, `"q1"`, `"q3"`, `"min"`, `"max"`). For other aggregations that produce values outside of the raw data domain (e.g. `"count"`, `"sum"`), this property is ignored.
    /// __Default value:__ `false`
    public var useUnaggregatedDomain: Bool?
    /// Reverse x-scale by default (useful for right-to-left charts).
    public var xReverse: XReverseChoice?
    public static let codingKeyPaths = (\Self.bandPaddingInner as KeyPath, \Self.bandPaddingOuter as KeyPath, \Self.barBandPaddingInner as KeyPath, \Self.clamp as KeyPath, \Self.continuousPadding as KeyPath, \Self.maxBandSize as KeyPath, \Self.maxFontSize as KeyPath, \Self.maxOpacity as KeyPath, \Self.maxSize as KeyPath, \Self.maxStrokeWidth as KeyPath, \Self.minBandSize as KeyPath, \Self.minFontSize as KeyPath, \Self.minOpacity as KeyPath, \Self.minSize as KeyPath, \Self.minStrokeWidth as KeyPath, \Self.pointPadding as KeyPath, \Self.quantileCount as KeyPath, \Self.quantizeCount as KeyPath, \Self.rectBandPaddingInner as KeyPath, \Self.round as KeyPath, \Self.useUnaggregatedDomain as KeyPath, \Self.xReverse as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.bandPaddingInner as KeyPath : CodingKeys.bandPaddingInner, \Self.bandPaddingOuter as KeyPath : CodingKeys.bandPaddingOuter, \Self.barBandPaddingInner as KeyPath : CodingKeys.barBandPaddingInner, \Self.clamp as KeyPath : CodingKeys.clamp, \Self.continuousPadding as KeyPath : CodingKeys.continuousPadding, \Self.maxBandSize as KeyPath : CodingKeys.maxBandSize, \Self.maxFontSize as KeyPath : CodingKeys.maxFontSize, \Self.maxOpacity as KeyPath : CodingKeys.maxOpacity, \Self.maxSize as KeyPath : CodingKeys.maxSize, \Self.maxStrokeWidth as KeyPath : CodingKeys.maxStrokeWidth, \Self.minBandSize as KeyPath : CodingKeys.minBandSize, \Self.minFontSize as KeyPath : CodingKeys.minFontSize, \Self.minOpacity as KeyPath : CodingKeys.minOpacity, \Self.minSize as KeyPath : CodingKeys.minSize, \Self.minStrokeWidth as KeyPath : CodingKeys.minStrokeWidth, \Self.pointPadding as KeyPath : CodingKeys.pointPadding, \Self.quantileCount as KeyPath : CodingKeys.quantileCount, \Self.quantizeCount as KeyPath : CodingKeys.quantizeCount, \Self.rectBandPaddingInner as KeyPath : CodingKeys.rectBandPaddingInner, \Self.round as KeyPath : CodingKeys.round, \Self.useUnaggregatedDomain as KeyPath : CodingKeys.useUnaggregatedDomain, \Self.xReverse as KeyPath : CodingKeys.xReverse]

    public init(bandPaddingInner: BandPaddingInnerChoice? = nil, bandPaddingOuter: BandPaddingOuterChoice? = nil, barBandPaddingInner: BarBandPaddingInnerChoice? = nil, clamp: ClampChoice? = nil, continuousPadding: ContinuousPaddingChoice? = nil, maxBandSize: Double? = nil, maxFontSize: Double? = nil, maxOpacity: Double? = nil, maxSize: Double? = nil, maxStrokeWidth: Double? = nil, minBandSize: Double? = nil, minFontSize: Double? = nil, minOpacity: Double? = nil, minSize: Double? = nil, minStrokeWidth: Double? = nil, pointPadding: PointPaddingChoice? = nil, quantileCount: Double? = nil, quantizeCount: Double? = nil, rectBandPaddingInner: RectBandPaddingInnerChoice? = nil, round: RoundChoice? = nil, useUnaggregatedDomain: Bool? = nil, xReverse: XReverseChoice? = nil) {
        self.bandPaddingInner = bandPaddingInner 
        self.bandPaddingOuter = bandPaddingOuter 
        self.barBandPaddingInner = barBandPaddingInner 
        self.clamp = clamp 
        self.continuousPadding = continuousPadding 
        self.maxBandSize = maxBandSize 
        self.maxFontSize = maxFontSize 
        self.maxOpacity = maxOpacity 
        self.maxSize = maxSize 
        self.maxStrokeWidth = maxStrokeWidth 
        self.minBandSize = minBandSize 
        self.minFontSize = minFontSize 
        self.minOpacity = minOpacity 
        self.minSize = minSize 
        self.minStrokeWidth = minStrokeWidth 
        self.pointPadding = pointPadding 
        self.quantileCount = quantileCount 
        self.quantizeCount = quantizeCount 
        self.rectBandPaddingInner = rectBandPaddingInner 
        self.round = round 
        self.useUnaggregatedDomain = useUnaggregatedDomain 
        self.xReverse = xReverse 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.bandPaddingInner = try values.decodeOptional(BandPaddingInnerChoice.self, forKey: .bandPaddingInner) 
        self.bandPaddingOuter = try values.decodeOptional(BandPaddingOuterChoice.self, forKey: .bandPaddingOuter) 
        self.barBandPaddingInner = try values.decodeOptional(BarBandPaddingInnerChoice.self, forKey: .barBandPaddingInner) 
        self.clamp = try values.decodeOptional(ClampChoice.self, forKey: .clamp) 
        self.continuousPadding = try values.decodeOptional(ContinuousPaddingChoice.self, forKey: .continuousPadding) 
        self.maxBandSize = try values.decodeOptional(Double.self, forKey: .maxBandSize) 
        self.maxFontSize = try values.decodeOptional(Double.self, forKey: .maxFontSize) 
        self.maxOpacity = try values.decodeOptional(Double.self, forKey: .maxOpacity) 
        self.maxSize = try values.decodeOptional(Double.self, forKey: .maxSize) 
        self.maxStrokeWidth = try values.decodeOptional(Double.self, forKey: .maxStrokeWidth) 
        self.minBandSize = try values.decodeOptional(Double.self, forKey: .minBandSize) 
        self.minFontSize = try values.decodeOptional(Double.self, forKey: .minFontSize) 
        self.minOpacity = try values.decodeOptional(Double.self, forKey: .minOpacity) 
        self.minSize = try values.decodeOptional(Double.self, forKey: .minSize) 
        self.minStrokeWidth = try values.decodeOptional(Double.self, forKey: .minStrokeWidth) 
        self.pointPadding = try values.decodeOptional(PointPaddingChoice.self, forKey: .pointPadding) 
        self.quantileCount = try values.decodeOptional(Double.self, forKey: .quantileCount) 
        self.quantizeCount = try values.decodeOptional(Double.self, forKey: .quantizeCount) 
        self.rectBandPaddingInner = try values.decodeOptional(RectBandPaddingInnerChoice.self, forKey: .rectBandPaddingInner) 
        self.round = try values.decodeOptional(RoundChoice.self, forKey: .round) 
        self.useUnaggregatedDomain = try values.decodeOptional(Bool.self, forKey: .useUnaggregatedDomain) 
        self.xReverse = try values.decodeOptional(XReverseChoice.self, forKey: .xReverse) 
    }

    /// Default inner padding for `x` and `y` band-ordinal scales.
    /// __Default value:__
    /// - `barBandPaddingInner` for bar marks (`0.1` by default)
    /// - `rectBandPaddingInner` for rect and other marks (`0` by default)
    /// Generated by Curio
    public typealias BandPaddingInnerChoice = OneOf<Double>.Or<ExprRef>

    /// Default outer padding for `x` and `y` band-ordinal scales.
    /// __Default value:__ `paddingInner/2` (which makes _width/height = number of unique values * step_)
    /// Generated by Curio
    public typealias BandPaddingOuterChoice = OneOf<Double>.Or<ExprRef>

    /// Default inner padding for `x` and `y` band-ordinal scales of `"bar"` marks.
    /// __Default value:__ `0.1`
    /// Generated by Curio
    public typealias BarBandPaddingInnerChoice = OneOf<Double>.Or<ExprRef>

    /// If true, values that exceed the data domain are clamped to either the minimum or maximum range value
    /// Generated by Curio
    public typealias ClampChoice = OneOf<Bool>.Or<ExprRef>

    /// Default padding for continuous scales.
    /// __Default:__ `5` for continuous x-scale of a vertical bar and continuous y-scale of a horizontal bar.; `0` otherwise.
    /// Generated by Curio
    public typealias ContinuousPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Default outer padding for `x` and `y` point-ordinal scales.
    /// __Default value:__ `0.5` (which makes _width/height = number of unique values * step_)
    /// Generated by Curio
    public typealias PointPaddingChoice = OneOf<Double>.Or<ExprRef>

    /// Default inner padding for `x` and `y` band-ordinal scales of `"rect"` marks.
    /// __Default value:__ `0`
    /// Generated by Curio
    public typealias RectBandPaddingInnerChoice = OneOf<Double>.Or<ExprRef>

    /// If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid. (Only available for `x`, `y`, and `size` scales.)
    /// Generated by Curio
    public typealias RoundChoice = OneOf<Bool>.Or<ExprRef>

    /// Reverse x-scale by default (useful for right-to-left charts).
    /// Generated by Curio
    public typealias XReverseChoice = OneOf<Bool>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case bandPaddingInner
        case bandPaddingOuter
        case barBandPaddingInner
        case clamp
        case continuousPadding
        case maxBandSize
        case maxFontSize
        case maxOpacity
        case maxSize
        case maxStrokeWidth
        case minBandSize
        case minFontSize
        case minOpacity
        case minSize
        case minStrokeWidth
        case pointPadding
        case quantileCount
        case quantizeCount
        case rectBandPaddingInner
        case round
        case useUnaggregatedDomain
        case xReverse
        public var keyDescription: String? {
            switch self {
            case .bandPaddingInner: return "Default inner padding for `x` and `y` band-ordinal scales.\n\n__Default value:__\n- `barBandPaddingInner` for bar marks (`0.1` by default)\n- `rectBandPaddingInner` for rect and other marks (`0` by default)"
            case .bandPaddingOuter: return "Default outer padding for `x` and `y` band-ordinal scales.\n\n__Default value:__ `paddingInner/2` (which makes _width/height = number of unique values * step_)"
            case .barBandPaddingInner: return "Default inner padding for `x` and `y` band-ordinal scales of `\"bar\"` marks.\n\n__Default value:__ `0.1`"
            case .clamp: return "If true, values that exceed the data domain are clamped to either the minimum or maximum range value"
            case .continuousPadding: return "Default padding for continuous scales.\n\n__Default:__ `5` for continuous x-scale of a vertical bar and continuous y-scale of a horizontal bar.; `0` otherwise."
            case .maxBandSize: return "The default max value for mapping quantitative fields to bar's size/bandSize.\n\nIf undefined (default), we will use the axis's size (width or height) - 1."
            case .maxFontSize: return "The default max value for mapping quantitative fields to text's size/fontSize.\n\n__Default value:__ `40`"
            case .maxOpacity: return "Default max opacity for mapping a field to opacity.\n\n__Default value:__ `0.8`"
            case .maxSize: return "Default max value for point size scale."
            case .maxStrokeWidth: return "Default max strokeWidth for the scale of strokeWidth for rule and line marks and of size for trail marks.\n\n__Default value:__ `4`"
            case .minBandSize: return "The default min value for mapping quantitative fields to bar and tick's size/bandSize scale with zero=false.\n\n__Default value:__ `2`"
            case .minFontSize: return "The default min value for mapping quantitative fields to tick's size/fontSize scale with zero=false\n\n__Default value:__ `8`"
            case .minOpacity: return "Default minimum opacity for mapping a field to opacity.\n\n__Default value:__ `0.3`"
            case .minSize: return "Default minimum value for point size scale with zero=false.\n\n__Default value:__ `9`"
            case .minStrokeWidth: return "Default minimum strokeWidth for the scale of strokeWidth for rule and line marks and of size for trail marks with zero=false.\n\n__Default value:__ `1`"
            case .pointPadding: return "Default outer padding for `x` and `y` point-ordinal scales.\n\n__Default value:__ `0.5` (which makes _width/height = number of unique values * step_)"
            case .quantileCount: return "Default range cardinality for [`quantile`](https://vega.github.io/vega-lite/docs/scale.html#quantile) scale.\n\n__Default value:__ `4`"
            case .quantizeCount: return "Default range cardinality for [`quantize`](https://vega.github.io/vega-lite/docs/scale.html#quantize) scale.\n\n__Default value:__ `4`"
            case .rectBandPaddingInner: return "Default inner padding for `x` and `y` band-ordinal scales of `\"rect\"` marks.\n\n__Default value:__ `0`"
            case .round: return "If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid. (Only available for `x`, `y`, and `size` scales.)"
            case .useUnaggregatedDomain: return "Use the source data range before aggregation as scale domain instead of aggregated data for aggregate axis.\n\nThis is equivalent to setting `domain` to `\"unaggregate\"` for aggregated _quantitative_ fields by default.\n\nThis property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n\n__Default value:__ `false`"
            case .xReverse: return "Reverse x-scale by default (useful for right-to-left charts)."
             } 
        }

        public typealias CodingOwner = ScaleConfig
    }
}

/// Generated by Curio
public struct ScaleDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The alignment of the steps within the scale range.
    /// This value must lie in the range `[0,1]`. A value of `0.5` indicates that the steps should be centered within the range. A value of `0` or `1` may be used to shift the bands to one side, say to position them adjacent to an axis.
    /// __Default value:__ `0.5`
    public var align: AlignChoice?
    /// The logarithm base of the `log` scale (default `10`).
    public var base: BaseChoice?
    /// Bin boundaries can be provided to scales as either an explicit array of bin boundaries or as a bin specification object. The legal values are:
    /// - An [array](../types/#Array) literal of bin boundary values. For example, `[0, 5, 10, 15, 20]`. The array must include both starting and ending boundaries. The previous example uses five values to indicate a total of four bin intervals: [0-5), [5-10), [10-15), [15-20]. Array literals may include signal references as elements.
    /// - A [bin specification object](https://vega.github.io/vega-lite/docs/scale.html#bins) that indicates the bin _step_ size, and optionally the _start_ and _stop_ boundaries.
    /// - An array of bin boundaries over the scale domain. If provided, axes and legends will use the bin boundaries to inform the choice of tick marks and text labels.
    public var bins: ScaleBins?
    /// If `true`, values that exceed the data domain are clamped to either the minimum or maximum range value
    /// __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/config.html#scale-config)'s `clamp` (`true` by default).
    public var clamp: ClampChoice?
    /// A constant determining the slope of the symlog function around zero. Only used for `symlog` scales.
    /// __Default value:__ `1`
    public var constant: ConstantChoice?
    /// Customized domain values in the form of constant values or dynamic values driven by a parameter.
    /// 1) Constant `domain` for _quantitative_ fields can take one of the following forms:
    /// - A two-element array with minimum and maximum values. To create a diverging scale, this two-element array can be combined with the `domainMid` property.
    /// - An array with more than two entries, for [Piecewise quantitative scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
    /// - A string value `"unaggregated"`, if the input field is aggregated, to indicate that the domain should include the raw data values prior to the aggregation.
    /// 2) Constant `domain` for _temporal_ fields can be a two-element array with minimum and maximum values, in the form of either timestamps or the [DateTime definition objects](https://vega.github.io/vega-lite/docs/types.html#datetime).
    /// 3) Constant `domain` for _ordinal_ and _nominal_ fields can be an array that lists valid input values.
    /// 4) To combine (union) specified constant domain with the field's values, `domain` can be an object with a `unionWith` property that specify constant domain to be combined. For example, `domain: {unionWith: [0, 100]}` for a quantitative scale means that the scale domain always includes `[0, 100]`, but will include other values in the fields beyond `[0, 100]`.
    /// 5) Domain can also takes an object defining a field or encoding of a parameter that [interactively determines](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale domain.
    public var domain: DomainChoice?
    /// Sets the maximum value in the scale domain, overriding the `domain` property. This property is only intended for use with scales having continuous domains.
    public var domainMax: DomainMaxChoice?
    /// Inserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for [diverging color scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise). The domainMid property is only intended for use with scales supporting continuous, piecewise domains.
    public var domainMid: DomainMidChoice?
    /// Sets the minimum value in the scale domain, overriding the domain property. This property is only intended for use with scales having continuous domains.
    public var domainMin: DomainMinChoice?
    /// The exponent of the `pow` scale.
    public var exponent: ExponentChoice?
    /// The interpolation method for range values. By default, a general interpolator for numbers, dates, strings and colors (in HCL space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include `rgb`, `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long' variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued _type_ property and an optional numeric _gamma_ property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate documentation](https://github.com/d3/d3-interpolate).
    /// * __Default value:__ `hcl`
    public var interpolate: InterpolateChoice?
    /// Extending the domain so that it starts and ends on nice round values. This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of _[0.201479…, 0.996679…]_, a nice domain might be _[0.2, 1.0]_.
    /// For quantitative scales such as linear, `nice` can be either a boolean flag or a number. If `nice` is a number, it will represent a desired tick count. This allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
    /// For temporal fields with time and utc scales, the `nice` value can be a string indicating the desired time interval. Legal values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, `time` and `utc` scales can accept an object-valued interval specifier of the form `{"interval": "month", "step": 3}`, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.
    /// __Default value:__ `true` for unbinned _quantitative_ fields; `false` otherwise.
    public var nice: NiceChoice?
    /// For _[continuous](https://vega.github.io/vega-lite/docs/scale.html#continuous)_ scales, expands the scale domain to accommodate the specified number of pixels on each of the scale range. The scale range must represent pixels for this parameter to function as intended. Padding adjustment is performed prior to all other adjustments, including the effects of the `zero`, `nice`, `domainMin`, and `domainMax` properties.
    /// For _[band](https://vega.github.io/vega-lite/docs/scale.html#band)_ scales, shortcut for setting `paddingInner` and `paddingOuter` to the same value.
    /// For _[point](https://vega.github.io/vega-lite/docs/scale.html#point)_ scales, alias for `paddingOuter`.
    /// __Default value:__ For _continuous_ scales, derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `continuousPadding`. For _band and point_ scales, see `paddingInner` and `paddingOuter`. By default, Vega-Lite sets padding such that _width/height = number of unique values * step_.
    public var padding: PaddingChoice?
    /// The inner padding (spacing) within each band step of band scales, as a fraction of the step size. This value must lie in the range [0,1].
    /// For point scale, this property is invalid as point scales do not have internal band widths (only step sizes between bands).
    /// __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingInner`.
    public var paddingInner: PaddingInnerChoice?
    /// The outer padding (spacing) at the ends of the range of band and point scales, as a fraction of the step size. This value must lie in the range [0,1].
    /// __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingOuter` for band scales and `pointPadding` for point scales. By default, Vega-Lite sets outer padding such that _width/height = number of unique values * step_.
    public var paddingOuter: PaddingOuterChoice?
    /// The range of the scale. One of:
    /// - A string indicating a [pre-defined named scale range](https://vega.github.io/vega-lite/docs/scale.html#range-config) (e.g., example, `"symbol"`, or `"diverging"`).
    /// - For [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous), two-element array indicating  minimum and maximum values, or an array with more than two entries for specifying a [piecewise scale](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
    /// - For [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) and [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales, an array of desired output values or an object with a `field` property representing the range values.  For example, if a field `color` contains CSS color names, we can set `range` to `{field: "color"}`.
    /// __Notes:__
    /// 1) For color scales you can also specify a color [`scheme`](https://vega.github.io/vega-lite/docs/scale.html#scheme) instead of `range`.
    /// 2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be customized via the view's corresponding [size](https://vega.github.io/vega-lite/docs/size.html) (`width` and `height`).
    public var range: RangeChoice?
    /// Sets the maximum value in the scale range, overriding the `range` property or the default range. This property is only intended for use with scales having continuous ranges.
    public var rangeMax: RangeMaxChoice?
    /// Sets the minimum value in the scale range, overriding the `range` property or the default range. This property is only intended for use with scales having continuous ranges.
    public var rangeMin: RangeMinChoice?
    /// If true, reverses the order of the scale range. __Default value:__ `false`.
    public var reverse: ReverseChoice?
    /// If `true`, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.
    /// __Default value:__ `false`.
    public var round: RoundChoice?
    /// A string indicating a color [scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme) name (e.g., `"category10"` or `"blues"`) or a [scheme parameter object](https://vega.github.io/vega-lite/docs/scale.html#scheme-params).
    /// Discrete color schemes may be used with [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) or [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales. Continuous color schemes are intended for use with color scales.
    /// For the full list of supported schemes, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
    public var scheme: SchemeChoice?
    /// The type of scale. Vega-Lite supports the following categories of scale types:
    /// 1) [**Continuous Scales**](https://vega.github.io/vega-lite/docs/scale.html#continuous) -- mapping continuous domains to continuous output ranges ([`"linear"`](https://vega.github.io/vega-lite/docs/scale.html#linear), [`"pow"`](https://vega.github.io/vega-lite/docs/scale.html#pow), [`"sqrt"`](https://vega.github.io/vega-lite/docs/scale.html#sqrt), [`"symlog"`](https://vega.github.io/vega-lite/docs/scale.html#symlog), [`"log"`](https://vega.github.io/vega-lite/docs/scale.html#log), [`"time"`](https://vega.github.io/vega-lite/docs/scale.html#time), [`"utc"`](https://vega.github.io/vega-lite/docs/scale.html#utc).
    /// 2) [**Discrete Scales**](https://vega.github.io/vega-lite/docs/scale.html#discrete) -- mapping discrete domains to discrete ([`"ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#ordinal)) or continuous ([`"band"`](https://vega.github.io/vega-lite/docs/scale.html#band) and [`"point"`](https://vega.github.io/vega-lite/docs/scale.html#point)) output ranges.
    /// 3) [**Discretizing Scales**](https://vega.github.io/vega-lite/docs/scale.html#discretizing) -- mapping continuous domains to discrete output ranges [`"bin-ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#bin-ordinal), [`"quantile"`](https://vega.github.io/vega-lite/docs/scale.html#quantile), [`"quantize"`](https://vega.github.io/vega-lite/docs/scale.html#quantize) and [`"threshold"`](https://vega.github.io/vega-lite/docs/scale.html#threshold).
    /// __Default value:__ please see the [scale type table](https://vega.github.io/vega-lite/docs/scale.html#type).
    public var type: ScaleType?
    /// If `true`, ensures that a zero baseline value is included in the scale domain.
    /// __Default value:__ `true` for x and y channels if the quantitative field is not binned and no custom `domain` is provided; `false` otherwise.
    /// __Note:__ Log, time, and utc scales do not support `zero`.
    public var zero: ZeroChoice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.base as KeyPath, \Self.bins as KeyPath, \Self.clamp as KeyPath, \Self.constant as KeyPath, \Self.domain as KeyPath, \Self.domainMax as KeyPath, \Self.domainMid as KeyPath, \Self.domainMin as KeyPath, \Self.exponent as KeyPath, \Self.interpolate as KeyPath, \Self.nice as KeyPath, \Self.padding as KeyPath, \Self.paddingInner as KeyPath, \Self.paddingOuter as KeyPath, \Self.range as KeyPath, \Self.rangeMax as KeyPath, \Self.rangeMin as KeyPath, \Self.reverse as KeyPath, \Self.round as KeyPath, \Self.scheme as KeyPath, \Self.type as KeyPath, \Self.zero as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.base as KeyPath : CodingKeys.base, \Self.bins as KeyPath : CodingKeys.bins, \Self.clamp as KeyPath : CodingKeys.clamp, \Self.constant as KeyPath : CodingKeys.constant, \Self.domain as KeyPath : CodingKeys.domain, \Self.domainMax as KeyPath : CodingKeys.domainMax, \Self.domainMid as KeyPath : CodingKeys.domainMid, \Self.domainMin as KeyPath : CodingKeys.domainMin, \Self.exponent as KeyPath : CodingKeys.exponent, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.nice as KeyPath : CodingKeys.nice, \Self.padding as KeyPath : CodingKeys.padding, \Self.paddingInner as KeyPath : CodingKeys.paddingInner, \Self.paddingOuter as KeyPath : CodingKeys.paddingOuter, \Self.range as KeyPath : CodingKeys.range, \Self.rangeMax as KeyPath : CodingKeys.rangeMax, \Self.rangeMin as KeyPath : CodingKeys.rangeMin, \Self.reverse as KeyPath : CodingKeys.reverse, \Self.round as KeyPath : CodingKeys.round, \Self.scheme as KeyPath : CodingKeys.scheme, \Self.type as KeyPath : CodingKeys.type, \Self.zero as KeyPath : CodingKeys.zero]

    public init(align: AlignChoice? = nil, base: BaseChoice? = nil, bins: ScaleBins? = nil, clamp: ClampChoice? = nil, constant: ConstantChoice? = nil, domain: DomainChoice? = nil, domainMax: DomainMaxChoice? = nil, domainMid: DomainMidChoice? = nil, domainMin: DomainMinChoice? = nil, exponent: ExponentChoice? = nil, interpolate: InterpolateChoice? = nil, nice: NiceChoice? = nil, padding: PaddingChoice? = nil, paddingInner: PaddingInnerChoice? = nil, paddingOuter: PaddingOuterChoice? = nil, range: RangeChoice? = nil, rangeMax: RangeMaxChoice? = nil, rangeMin: RangeMinChoice? = nil, reverse: ReverseChoice? = nil, round: RoundChoice? = nil, scheme: SchemeChoice? = nil, type: ScaleType? = nil, zero: ZeroChoice? = nil) {
        self.align = align 
        self.base = base 
        self.bins = bins 
        self.clamp = clamp 
        self.constant = constant 
        self.domain = domain 
        self.domainMax = domainMax 
        self.domainMid = domainMid 
        self.domainMin = domainMin 
        self.exponent = exponent 
        self.interpolate = interpolate 
        self.nice = nice 
        self.padding = padding 
        self.paddingInner = paddingInner 
        self.paddingOuter = paddingOuter 
        self.range = range 
        self.rangeMax = rangeMax 
        self.rangeMin = rangeMin 
        self.reverse = reverse 
        self.round = round 
        self.scheme = scheme 
        self.type = type 
        self.zero = zero 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.base = try values.decodeOptional(BaseChoice.self, forKey: .base) 
        self.bins = try values.decodeOptional(ScaleBins.self, forKey: .bins) 
        self.clamp = try values.decodeOptional(ClampChoice.self, forKey: .clamp) 
        self.constant = try values.decodeOptional(ConstantChoice.self, forKey: .constant) 
        self.domain = try values.decodeOptional(DomainChoice.self, forKey: .domain) 
        self.domainMax = try values.decodeOptional(DomainMaxChoice.self, forKey: .domainMax) 
        self.domainMid = try values.decodeOptional(DomainMidChoice.self, forKey: .domainMid) 
        self.domainMin = try values.decodeOptional(DomainMinChoice.self, forKey: .domainMin) 
        self.exponent = try values.decodeOptional(ExponentChoice.self, forKey: .exponent) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.nice = try values.decodeOptional(NiceChoice.self, forKey: .nice) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.paddingInner = try values.decodeOptional(PaddingInnerChoice.self, forKey: .paddingInner) 
        self.paddingOuter = try values.decodeOptional(PaddingOuterChoice.self, forKey: .paddingOuter) 
        self.range = try values.decodeOptional(RangeChoice.self, forKey: .range) 
        self.rangeMax = try values.decodeOptional(RangeMaxChoice.self, forKey: .rangeMax) 
        self.rangeMin = try values.decodeOptional(RangeMinChoice.self, forKey: .rangeMin) 
        self.reverse = try values.decodeOptional(ReverseChoice.self, forKey: .reverse) 
        self.round = try values.decodeOptional(RoundChoice.self, forKey: .round) 
        self.scheme = try values.decodeOptional(SchemeChoice.self, forKey: .scheme) 
        self.type = try values.decodeOptional(ScaleType.self, forKey: .type) 
        self.zero = try values.decodeOptional(ZeroChoice.self, forKey: .zero) 
    }

    /// The alignment of the steps within the scale range.
    /// This value must lie in the range `[0,1]`. A value of `0.5` indicates that the steps should be centered within the range. A value of `0` or `1` may be used to shift the bands to one side, say to position them adjacent to an axis.
    /// __Default value:__ `0.5`
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Double>.Or<ExprRef>

    /// The logarithm base of the `log` scale (default `10`).
    /// Generated by Curio
    public typealias BaseChoice = OneOf<Double>.Or<ExprRef>

    /// If `true`, values that exceed the data domain are clamped to either the minimum or maximum range value
    /// __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/config.html#scale-config)'s `clamp` (`true` by default).
    /// Generated by Curio
    public typealias ClampChoice = OneOf<Bool>.Or<ExprRef>

    /// A constant determining the slope of the symlog function around zero. Only used for `symlog` scales.
    /// __Default value:__ `1`
    /// Generated by Curio
    public typealias ConstantChoice = OneOf<Double>.Or<ExprRef>

    /// Customized domain values in the form of constant values or dynamic values driven by a parameter.
    /// 1) Constant `domain` for _quantitative_ fields can take one of the following forms:
    /// - A two-element array with minimum and maximum values. To create a diverging scale, this two-element array can be combined with the `domainMid` property.
    /// - An array with more than two entries, for [Piecewise quantitative scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
    /// - A string value `"unaggregated"`, if the input field is aggregated, to indicate that the domain should include the raw data values prior to the aggregation.
    /// 2) Constant `domain` for _temporal_ fields can be a two-element array with minimum and maximum values, in the form of either timestamps or the [DateTime definition objects](https://vega.github.io/vega-lite/docs/types.html#datetime).
    /// 3) Constant `domain` for _ordinal_ and _nominal_ fields can be an array that lists valid input values.
    /// 4) To combine (union) specified constant domain with the field's values, `domain` can be an object with a `unionWith` property that specify constant domain to be combined. For example, `domain: {unionWith: [0, 100]}` for a quantitative scale means that the scale domain always includes `[0, 100]`, but will include other values in the fields beyond `[0, 100]`.
    /// 5) Domain can also takes an object defining a field or encoding of a parameter that [interactively determines](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale domain.
    /// Generated by Curio
    public typealias DomainChoice = OneOf<[Nullable<OneOf<String>.Or<Double>.Or<Bool>.Or<DateTime>.Or<ExprRef>>]>.Or<LiteralUnaggregated>.Or<ParameterExtent>.Or<DomainUnionWith>.Or<ExprRef>
    /// Customized domain values in the form of constant values or dynamic values driven by a parameter.
    /// 1) Constant `domain` for _quantitative_ fields can take one of the following forms:
    /// - A two-element array with minimum and maximum values. To create a diverging scale, this two-element array can be combined with the `domainMid` property.
    /// - An array with more than two entries, for [Piecewise quantitative scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
    /// - A string value `"unaggregated"`, if the input field is aggregated, to indicate that the domain should include the raw data values prior to the aggregation.
    /// 2) Constant `domain` for _temporal_ fields can be a two-element array with minimum and maximum values, in the form of either timestamps or the [DateTime definition objects](https://vega.github.io/vega-lite/docs/types.html#datetime).
    /// 3) Constant `domain` for _ordinal_ and _nominal_ fields can be an array that lists valid input values.
    /// 4) To combine (union) specified constant domain with the field's values, `domain` can be an object with a `unionWith` property that specify constant domain to be combined. For example, `domain: {unionWith: [0, 100]}` for a quantitative scale means that the scale domain always includes `[0, 100]`, but will include other values in the fields beyond `[0, 100]`.
    /// 5) Domain can also takes an object defining a field or encoding of a parameter that [interactively determines](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale domain.
    /// Generated by Curio
    public enum LiteralUnaggregated : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case unaggregated
    }

    /// Sets the maximum value in the scale domain, overriding the `domain` property. This property is only intended for use with scales having continuous domains.
    /// Generated by Curio
    public typealias DomainMaxChoice = OneOf<Double>.Or<DateTime>.Or<ExprRef>

    /// Inserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for [diverging color scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise). The domainMid property is only intended for use with scales supporting continuous, piecewise domains.
    /// Generated by Curio
    public typealias DomainMidChoice = OneOf<Double>.Or<ExprRef>

    /// Sets the minimum value in the scale domain, overriding the domain property. This property is only intended for use with scales having continuous domains.
    /// Generated by Curio
    public typealias DomainMinChoice = OneOf<Double>.Or<DateTime>.Or<ExprRef>

    /// The exponent of the `pow` scale.
    /// Generated by Curio
    public typealias ExponentChoice = OneOf<Double>.Or<ExprRef>

    /// The interpolation method for range values. By default, a general interpolator for numbers, dates, strings and colors (in HCL space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include `rgb`, `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long' variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued _type_ property and an optional numeric _gamma_ property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate documentation](https://github.com/d3/d3-interpolate).
    /// * __Default value:__ `hcl`
    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<ScaleInterpolateEnum>.Or<ExprRef>.Or<ScaleInterpolateParams>

    /// Extending the domain so that it starts and ends on nice round values. This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of _[0.201479…, 0.996679…]_, a nice domain might be _[0.2, 1.0]_.
    /// For quantitative scales such as linear, `nice` can be either a boolean flag or a number. If `nice` is a number, it will represent a desired tick count. This allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
    /// For temporal fields with time and utc scales, the `nice` value can be a string indicating the desired time interval. Legal values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, `time` and `utc` scales can accept an object-valued interval specifier of the form `{"interval": "month", "step": 3}`, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.
    /// __Default value:__ `true` for unbinned _quantitative_ fields; `false` otherwise.
    /// Generated by Curio
    public typealias NiceChoice = OneOf<Bool>.Or<Double>.Or<TemporalUnit>.Or<TimeIntervalStep>.Or<ExprRef>

    /// For _[continuous](https://vega.github.io/vega-lite/docs/scale.html#continuous)_ scales, expands the scale domain to accommodate the specified number of pixels on each of the scale range. The scale range must represent pixels for this parameter to function as intended. Padding adjustment is performed prior to all other adjustments, including the effects of the `zero`, `nice`, `domainMin`, and `domainMax` properties.
    /// For _[band](https://vega.github.io/vega-lite/docs/scale.html#band)_ scales, shortcut for setting `paddingInner` and `paddingOuter` to the same value.
    /// For _[point](https://vega.github.io/vega-lite/docs/scale.html#point)_ scales, alias for `paddingOuter`.
    /// __Default value:__ For _continuous_ scales, derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `continuousPadding`. For _band and point_ scales, see `paddingInner` and `paddingOuter`. By default, Vega-Lite sets padding such that _width/height = number of unique values * step_.
    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Double>.Or<ExprRef>

    /// The inner padding (spacing) within each band step of band scales, as a fraction of the step size. This value must lie in the range [0,1].
    /// For point scale, this property is invalid as point scales do not have internal band widths (only step sizes between bands).
    /// __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingInner`.
    /// Generated by Curio
    public typealias PaddingInnerChoice = OneOf<Double>.Or<ExprRef>

    /// The outer padding (spacing) at the ends of the range of band and point scales, as a fraction of the step size. This value must lie in the range [0,1].
    /// __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingOuter` for band scales and `pointPadding` for point scales. By default, Vega-Lite sets outer padding such that _width/height = number of unique values * step_.
    /// Generated by Curio
    public typealias PaddingOuterChoice = OneOf<Double>.Or<ExprRef>

    /// The range of the scale. One of:
    /// - A string indicating a [pre-defined named scale range](https://vega.github.io/vega-lite/docs/scale.html#range-config) (e.g., example, `"symbol"`, or `"diverging"`).
    /// - For [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous), two-element array indicating  minimum and maximum values, or an array with more than two entries for specifying a [piecewise scale](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
    /// - For [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) and [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales, an array of desired output values or an object with a `field` property representing the range values.  For example, if a field `color` contains CSS color names, we can set `range` to `{field: "color"}`.
    /// __Notes:__
    /// 1) For color scales you can also specify a color [`scheme`](https://vega.github.io/vega-lite/docs/scale.html#scheme) instead of `range`.
    /// 2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be customized via the view's corresponding [size](https://vega.github.io/vega-lite/docs/size.html) (`width` and `height`).
    /// Generated by Curio
    public typealias RangeChoice = RangeTypes.Choice
    public enum RangeTypes {

        public typealias Choice = OneOf<RangeEnum>.Or<[OneOf<Double>.Or<String>.Or<[Double]>.Or<ExprRef>]>.Or<FieldType>

        /// Generated by Curio
        public struct FieldType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
            public var field: String
            public static let codingKeyPaths = (\Self.field as KeyPath)
            public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field]

            public init(field: String) {
                self.field = field 
            }

            public init(from decoder: Decoder) throws {
                try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
                let values = try decoder.container(keyedBy: CodingKeys.self) 
                self.field = try values.decode(String.self, forKey: .field) 
            }

            public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
                case field
                public var keyDescription: String? {
                    switch self {
                    case .field: return nil
                     } 
                }

                public typealias CodingOwner = FieldType
            }
        }
    }

    /// Sets the maximum value in the scale range, overriding the `range` property or the default range. This property is only intended for use with scales having continuous ranges.
    /// Generated by Curio
    public typealias RangeMaxChoice = OneOf<Double>.Or<String>.Or<ExprRef>

    /// Sets the minimum value in the scale range, overriding the `range` property or the default range. This property is only intended for use with scales having continuous ranges.
    /// Generated by Curio
    public typealias RangeMinChoice = OneOf<Double>.Or<String>.Or<ExprRef>

    /// If true, reverses the order of the scale range. __Default value:__ `false`.
    /// Generated by Curio
    public typealias ReverseChoice = OneOf<Bool>.Or<ExprRef>

    /// If `true`, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.
    /// __Default value:__ `false`.
    /// Generated by Curio
    public typealias RoundChoice = OneOf<Bool>.Or<ExprRef>

    /// A string indicating a color [scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme) name (e.g., `"category10"` or `"blues"`) or a [scheme parameter object](https://vega.github.io/vega-lite/docs/scale.html#scheme-params).
    /// Discrete color schemes may be used with [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) or [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales. Continuous color schemes are intended for use with color scales.
    /// For the full list of supported schemes, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
    /// Generated by Curio
    public typealias SchemeChoice = OneOf<String>.Or<SchemeParams>.Or<ExprRef>

    /// If `true`, ensures that a zero baseline value is included in the scale domain.
    /// __Default value:__ `true` for x and y channels if the quantitative field is not binned and no custom `domain` is provided; `false` otherwise.
    /// __Note:__ Log, time, and utc scales do not support `zero`.
    /// Generated by Curio
    public typealias ZeroChoice = OneOf<Bool>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case base
        case bins
        case clamp
        case constant
        case domain
        case domainMax
        case domainMid
        case domainMin
        case exponent
        case interpolate
        case nice
        case padding
        case paddingInner
        case paddingOuter
        case range
        case rangeMax
        case rangeMin
        case reverse
        case round
        case scheme
        case type
        case zero
        public var keyDescription: String? {
            switch self {
            case .align: return "The alignment of the steps within the scale range.\n\nThis value must lie in the range `[0,1]`. A value of `0.5` indicates that the steps should be centered within the range. A value of `0` or `1` may be used to shift the bands to one side, say to position them adjacent to an axis.\n\n__Default value:__ `0.5`"
            case .base: return "The logarithm base of the `log` scale (default `10`)."
            case .bins: return "Bin boundaries can be provided to scales as either an explicit array of bin boundaries or as a bin specification object. The legal values are:\n- An [array](../types/#Array) literal of bin boundary values. For example, `[0, 5, 10, 15, 20]`. The array must include both starting and ending boundaries. The previous example uses five values to indicate a total of four bin intervals: [0-5), [5-10), [10-15), [15-20]. Array literals may include signal references as elements.\n- A [bin specification object](https://vega.github.io/vega-lite/docs/scale.html#bins) that indicates the bin _step_ size, and optionally the _start_ and _stop_ boundaries.\n- An array of bin boundaries over the scale domain. If provided, axes and legends will use the bin boundaries to inform the choice of tick marks and text labels."
            case .clamp: return "If `true`, values that exceed the data domain are clamped to either the minimum or maximum range value\n\n__Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/config.html#scale-config)'s `clamp` (`true` by default)."
            case .constant: return "A constant determining the slope of the symlog function around zero. Only used for `symlog` scales.\n\n__Default value:__ `1`"
            case .domain: return "Customized domain values in the form of constant values or dynamic values driven by a parameter.\n\n1) Constant `domain` for _quantitative_ fields can take one of the following forms:\n\n- A two-element array with minimum and maximum values. To create a diverging scale, this two-element array can be combined with the `domainMid` property.\n- An array with more than two entries, for [Piecewise quantitative scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise).\n- A string value `\"unaggregated\"`, if the input field is aggregated, to indicate that the domain should include the raw data values prior to the aggregation.\n\n2) Constant `domain` for _temporal_ fields can be a two-element array with minimum and maximum values, in the form of either timestamps or the [DateTime definition objects](https://vega.github.io/vega-lite/docs/types.html#datetime).\n\n3) Constant `domain` for _ordinal_ and _nominal_ fields can be an array that lists valid input values.\n\n4) To combine (union) specified constant domain with the field's values, `domain` can be an object with a `unionWith` property that specify constant domain to be combined. For example, `domain: {unionWith: [0, 100]}` for a quantitative scale means that the scale domain always includes `[0, 100]`, but will include other values in the fields beyond `[0, 100]`.\n\n5) Domain can also takes an object defining a field or encoding of a parameter that [interactively determines](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale domain."
            case .domainMax: return "Sets the maximum value in the scale domain, overriding the `domain` property. This property is only intended for use with scales having continuous domains."
            case .domainMid: return "Inserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for [diverging color scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise). The domainMid property is only intended for use with scales supporting continuous, piecewise domains."
            case .domainMin: return "Sets the minimum value in the scale domain, overriding the domain property. This property is only intended for use with scales having continuous domains."
            case .exponent: return "The exponent of the `pow` scale."
            case .interpolate: return "The interpolation method for range values. By default, a general interpolator for numbers, dates, strings and colors (in HCL space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include `rgb`, `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long' variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued _type_ property and an optional numeric _gamma_ property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate documentation](https://github.com/d3/d3-interpolate).\n\n* __Default value:__ `hcl`"
            case .nice: return "Extending the domain so that it starts and ends on nice round values. This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of _[0.201479…, 0.996679…]_, a nice domain might be _[0.2, 1.0]_.\n\nFor quantitative scales such as linear, `nice` can be either a boolean flag or a number. If `nice` is a number, it will represent a desired tick count. This allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.\n\nFor temporal fields with time and utc scales, the `nice` value can be a string indicating the desired time interval. Legal values are `\"millisecond\"`, `\"second\"`, `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`. Alternatively, `time` and `utc` scales can accept an object-valued interval specifier of the form `{\"interval\": \"month\", \"step\": 3}`, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.\n\n__Default value:__ `true` for unbinned _quantitative_ fields; `false` otherwise."
            case .padding: return "For _[continuous](https://vega.github.io/vega-lite/docs/scale.html#continuous)_ scales, expands the scale domain to accommodate the specified number of pixels on each of the scale range. The scale range must represent pixels for this parameter to function as intended. Padding adjustment is performed prior to all other adjustments, including the effects of the `zero`, `nice`, `domainMin`, and `domainMax` properties.\n\nFor _[band](https://vega.github.io/vega-lite/docs/scale.html#band)_ scales, shortcut for setting `paddingInner` and `paddingOuter` to the same value.\n\nFor _[point](https://vega.github.io/vega-lite/docs/scale.html#point)_ scales, alias for `paddingOuter`.\n\n__Default value:__ For _continuous_ scales, derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `continuousPadding`. For _band and point_ scales, see `paddingInner` and `paddingOuter`. By default, Vega-Lite sets padding such that _width/height = number of unique values * step_."
            case .paddingInner: return "The inner padding (spacing) within each band step of band scales, as a fraction of the step size. This value must lie in the range [0,1].\n\nFor point scale, this property is invalid as point scales do not have internal band widths (only step sizes between bands).\n\n__Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingInner`."
            case .paddingOuter: return "The outer padding (spacing) at the ends of the range of band and point scales, as a fraction of the step size. This value must lie in the range [0,1].\n\n__Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingOuter` for band scales and `pointPadding` for point scales. By default, Vega-Lite sets outer padding such that _width/height = number of unique values * step_."
            case .range: return "The range of the scale. One of:\n\n- A string indicating a [pre-defined named scale range](https://vega.github.io/vega-lite/docs/scale.html#range-config) (e.g., example, `\"symbol\"`, or `\"diverging\"`).\n\n- For [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous), two-element array indicating  minimum and maximum values, or an array with more than two entries for specifying a [piecewise scale](https://vega.github.io/vega-lite/docs/scale.html#piecewise).\n\n- For [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) and [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales, an array of desired output values or an object with a `field` property representing the range values.  For example, if a field `color` contains CSS color names, we can set `range` to `{field: \"color\"}`.\n\n__Notes:__\n\n1) For color scales you can also specify a color [`scheme`](https://vega.github.io/vega-lite/docs/scale.html#scheme) instead of `range`.\n\n2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be customized via the view's corresponding [size](https://vega.github.io/vega-lite/docs/size.html) (`width` and `height`)."
            case .rangeMax: return "Sets the maximum value in the scale range, overriding the `range` property or the default range. This property is only intended for use with scales having continuous ranges."
            case .rangeMin: return "Sets the minimum value in the scale range, overriding the `range` property or the default range. This property is only intended for use with scales having continuous ranges."
            case .reverse: return "If true, reverses the order of the scale range. __Default value:__ `false`."
            case .round: return "If `true`, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.\n\n__Default value:__ `false`."
            case .scheme: return "A string indicating a color [scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme) name (e.g., `\"category10\"` or `\"blues\"`) or a [scheme parameter object](https://vega.github.io/vega-lite/docs/scale.html#scheme-params).\n\nDiscrete color schemes may be used with [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) or [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales. Continuous color schemes are intended for use with color scales.\n\nFor the full list of supported schemes, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference."
            case .type: return "The type of scale. Vega-Lite supports the following categories of scale types:\n\n1) [**Continuous Scales**](https://vega.github.io/vega-lite/docs/scale.html#continuous) -- mapping continuous domains to continuous output ranges ([`\"linear\"`](https://vega.github.io/vega-lite/docs/scale.html#linear), [`\"pow\"`](https://vega.github.io/vega-lite/docs/scale.html#pow), [`\"sqrt\"`](https://vega.github.io/vega-lite/docs/scale.html#sqrt), [`\"symlog\"`](https://vega.github.io/vega-lite/docs/scale.html#symlog), [`\"log\"`](https://vega.github.io/vega-lite/docs/scale.html#log), [`\"time\"`](https://vega.github.io/vega-lite/docs/scale.html#time), [`\"utc\"`](https://vega.github.io/vega-lite/docs/scale.html#utc).\n\n2) [**Discrete Scales**](https://vega.github.io/vega-lite/docs/scale.html#discrete) -- mapping discrete domains to discrete ([`\"ordinal\"`](https://vega.github.io/vega-lite/docs/scale.html#ordinal)) or continuous ([`\"band\"`](https://vega.github.io/vega-lite/docs/scale.html#band) and [`\"point\"`](https://vega.github.io/vega-lite/docs/scale.html#point)) output ranges.\n\n3) [**Discretizing Scales**](https://vega.github.io/vega-lite/docs/scale.html#discretizing) -- mapping continuous domains to discrete output ranges [`\"bin-ordinal\"`](https://vega.github.io/vega-lite/docs/scale.html#bin-ordinal), [`\"quantile\"`](https://vega.github.io/vega-lite/docs/scale.html#quantile), [`\"quantize\"`](https://vega.github.io/vega-lite/docs/scale.html#quantize) and [`\"threshold\"`](https://vega.github.io/vega-lite/docs/scale.html#threshold).\n\n__Default value:__ please see the [scale type table](https://vega.github.io/vega-lite/docs/scale.html#type)."
            case .zero: return "If `true`, ensures that a zero baseline value is included in the scale domain.\n\n__Default value:__ `true` for x and y channels if the quantitative field is not binned and no custom `domain` is provided; `false` otherwise.\n\n__Note:__ Log, time, and utc scales do not support `zero`."
             } 
        }

        public typealias CodingOwner = ScaleDef
    }
}

/// Generated by Curio
public struct ScaleInterpolateParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var gamma: Double?
    public var type: LiteralRgbOrCubehelixOrCubehelixLong
    public static let codingKeyPaths = (\Self.gamma as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.gamma as KeyPath : CodingKeys.gamma, \Self.type as KeyPath : CodingKeys.type]

    public init(gamma: Double? = nil, type: LiteralRgbOrCubehelixOrCubehelixLong) {
        self.gamma = gamma 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.gamma = try values.decodeOptional(Double.self, forKey: .gamma) 
        self.type = try values.decode(LiteralRgbOrCubehelixOrCubehelixLong.self, forKey: .type) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case gamma
        case type
        public var keyDescription: String? {
            switch self {
            case .gamma: return nil
            case .type: return nil
             } 
        }

        public typealias CodingOwner = ScaleInterpolateParams
    }

    /// Generated by Curio
    public enum LiteralRgbOrCubehelixOrCubehelixLong : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case rgb
        case cubehelix
        case cubehelixLong = "cubehelix-long"
    }
}

/// Generated by Curio
public struct ScaleResolveMap : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var angle: ResolveMode?
    public var color: ResolveMode?
    public var fill: ResolveMode?
    public var fillOpacity: ResolveMode?
    public var opacity: ResolveMode?
    public var radius: ResolveMode?
    public var shape: ResolveMode?
    public var size: ResolveMode?
    public var stroke: ResolveMode?
    public var strokeDash: ResolveMode?
    public var strokeOpacity: ResolveMode?
    public var strokeWidth: ResolveMode?
    public var theta: ResolveMode?
    public var x: ResolveMode?
    public var y: ResolveMode?
    public static let codingKeyPaths = (\Self.angle as KeyPath, \Self.color as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.opacity as KeyPath, \Self.radius as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.stroke as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.theta as KeyPath, \Self.x as KeyPath, \Self.y as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.angle as KeyPath : CodingKeys.angle, \Self.color as KeyPath : CodingKeys.color, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.radius as KeyPath : CodingKeys.radius, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.theta as KeyPath : CodingKeys.theta, \Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y]

    public init(angle: ResolveMode? = nil, color: ResolveMode? = nil, fill: ResolveMode? = nil, fillOpacity: ResolveMode? = nil, opacity: ResolveMode? = nil, radius: ResolveMode? = nil, shape: ResolveMode? = nil, size: ResolveMode? = nil, stroke: ResolveMode? = nil, strokeDash: ResolveMode? = nil, strokeOpacity: ResolveMode? = nil, strokeWidth: ResolveMode? = nil, theta: ResolveMode? = nil, x: ResolveMode? = nil, y: ResolveMode? = nil) {
        self.angle = angle 
        self.color = color 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.opacity = opacity 
        self.radius = radius 
        self.shape = shape 
        self.size = size 
        self.stroke = stroke 
        self.strokeDash = strokeDash 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.theta = theta 
        self.x = x 
        self.y = y 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.angle = try values.decodeOptional(ResolveMode.self, forKey: .angle) 
        self.color = try values.decodeOptional(ResolveMode.self, forKey: .color) 
        self.fill = try values.decodeOptional(ResolveMode.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(ResolveMode.self, forKey: .fillOpacity) 
        self.opacity = try values.decodeOptional(ResolveMode.self, forKey: .opacity) 
        self.radius = try values.decodeOptional(ResolveMode.self, forKey: .radius) 
        self.shape = try values.decodeOptional(ResolveMode.self, forKey: .shape) 
        self.size = try values.decodeOptional(ResolveMode.self, forKey: .size) 
        self.stroke = try values.decodeOptional(ResolveMode.self, forKey: .stroke) 
        self.strokeDash = try values.decodeOptional(ResolveMode.self, forKey: .strokeDash) 
        self.strokeOpacity = try values.decodeOptional(ResolveMode.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(ResolveMode.self, forKey: .strokeWidth) 
        self.theta = try values.decodeOptional(ResolveMode.self, forKey: .theta) 
        self.x = try values.decodeOptional(ResolveMode.self, forKey: .x) 
        self.y = try values.decodeOptional(ResolveMode.self, forKey: .y) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case angle
        case color
        case fill
        case fillOpacity
        case opacity
        case radius
        case shape
        case size
        case stroke
        case strokeDash
        case strokeOpacity
        case strokeWidth
        case theta
        case x
        case y
        public var keyDescription: String? {
            switch self {
            case .angle: return nil
            case .color: return nil
            case .fill: return nil
            case .fillOpacity: return nil
            case .opacity: return nil
            case .radius: return nil
            case .shape: return nil
            case .size: return nil
            case .stroke: return nil
            case .strokeDash: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .theta: return nil
            case .x: return nil
            case .y: return nil
             } 
        }

        public typealias CodingOwner = ScaleResolveMap
    }
}

/// Generated by Curio
public struct SchemeParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The number of colors to use in the scheme. This can be useful for scale types such as `"quantize"`, which use the length of the scale range to determine the number of discrete bins for the scale domain.
    public var count: Double?
    /// The extent of the color range to use. For example `[0.2, 1]` will rescale the color scheme such that color values in the range _[0, 0.2)_ are excluded from the scheme.
    public var extent: [ExtentItem]?
    /// A color scheme name for ordinal scales (e.g., `"category10"` or `"blues"`).
    /// For the full list of supported schemes, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
    public var name: String
    public static let codingKeyPaths = (\Self.count as KeyPath, \Self.extent as KeyPath, \Self.name as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.count as KeyPath : CodingKeys.count, \Self.extent as KeyPath : CodingKeys.extent, \Self.name as KeyPath : CodingKeys.name]

    public init(count: Double? = nil, extent: [ExtentItem]? = nil, name: String) {
        self.count = count 
        self.extent = extent 
        self.name = name 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.count = try values.decodeOptional(Double.self, forKey: .count) 
        self.extent = try values.decodeOptional([ExtentItem].self, forKey: .extent) 
        self.name = try values.decode(String.self, forKey: .name) 
    }

    public typealias ExtentItem = Double

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case count
        case extent
        case name
        public var keyDescription: String? {
            switch self {
            case .count: return "The number of colors to use in the scheme. This can be useful for scale types such as `\"quantize\"`, which use the length of the scale range to determine the number of discrete bins for the scale domain."
            case .extent: return "The extent of the color range to use. For example `[0.2, 1]` will rescale the color scheme such that color values in the range _[0, 0.2)_ are excluded from the scheme."
            case .name: return "A color scheme name for ordinal scales (e.g., `\"category10\"` or `\"blues\"`).\n\nFor the full list of supported schemes, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference."
             } 
        }

        public typealias CodingOwner = SchemeParams
    }
}

/// A field definition of a secondary channel that shares a scale with another primary channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
/// Generated by Curio
public struct SecondaryFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: ExplicitNull?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.timeUnit = timeUnit 
        self.title = title 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
    }

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case field
        case timeUnit
        case title
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
             } 
        }

        public typealias CodingOwner = SecondaryFieldDef
    }
}

/// Generated by Curio
public struct SelectionConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The default definition for an [`interval`](https://vega.github.io/vega-lite/docs/parameter.html#select) selection. All properties and transformations for an interval selection definition (except `type`) may be specified here.
    /// For instance, setting `interval` to `{"translate": false}` disables the ability to move interval selections by default.
    public var interval: IntervalSelectionConfigWithoutType?
    /// The default definition for a [`point`](https://vega.github.io/vega-lite/docs/parameter.html#select) selection. All properties and transformations  for a point selection definition (except `type`) may be specified here.
    /// For instance, setting `point` to `{"on": "dblclick"}` populates point selections on double-click by default.
    public var point: PointSelectionConfigWithoutType?
    public static let codingKeyPaths = (\Self.interval as KeyPath, \Self.point as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.interval as KeyPath : CodingKeys.interval, \Self.point as KeyPath : CodingKeys.point]

    public init(interval: IntervalSelectionConfigWithoutType? = nil, point: PointSelectionConfigWithoutType? = nil) {
        self.interval = interval 
        self.point = point 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.interval = try values.decodeOptional(IntervalSelectionConfigWithoutType.self, forKey: .interval) 
        self.point = try values.decodeOptional(PointSelectionConfigWithoutType.self, forKey: .point) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case interval
        case point
        public var keyDescription: String? {
            switch self {
            case .interval: return "The default definition for an [`interval`](https://vega.github.io/vega-lite/docs/parameter.html#select) selection. All properties and transformations for an interval selection definition (except `type`) may be specified here.\n\nFor instance, setting `interval` to `{\"translate\": false}` disables the ability to move interval selections by default."
            case .point: return "The default definition for a [`point`](https://vega.github.io/vega-lite/docs/parameter.html#select) selection. All properties and transformations  for a point selection definition (except `type`) may be specified here.\n\nFor instance, setting `point` to `{\"on\": \"dblclick\"}` populates point selections on double-click by default."
             } 
        }

        public typealias CodingOwner = SelectionConfig
    }
}

public struct SelectionInit : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<PrimitiveValue>.Or<DateTime>

    public init(rawValue: OneOf<PrimitiveValue>.Or<DateTime>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<PrimitiveValue>.Or<DateTime>) {
        self.rawValue = rawValue 
    }
}

public struct SelectionInitInterval : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Vector2Boolean>.Or<Vector2Number>.Or<Vector2String>.Or<Vector2DateTime>

    public init(rawValue: OneOf<Vector2Boolean>.Or<Vector2Number>.Or<Vector2String>.Or<Vector2DateTime>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Vector2Boolean>.Or<Vector2Number>.Or<Vector2String>.Or<Vector2DateTime>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct SelectionParameter : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: ParameterId?
    /// When set, a selection is populated by input elements (also known as dynamic query widgets) or by interacting with the corresponding legend. Direct manipulation interaction is disabled by default; to re-enable it, set the selection's [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties) property.
    /// Legend bindings are restricted to selections that only specify a single field or encoding.
    /// Query widget binding takes the form of Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between projected field/encodings and binding definitions.
    /// __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
    public var bind: BindChoice?
    /// Required. A unique name for the selection parameter. Selection names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or "$", or "_") and may not start with a digit. Reserved keywords that may not be used as parameter names are "datum", "event", "item", and "parent".
    public var name: ParameterName
    /// Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:
    /// - `"point"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.
    /// - `"interval"` -- to select a continuous range of data values on `drag`.
    public var select: SelectChoice
    /// Initialize the selection with a mapping between [projected channels or field names](https://vega.github.io/vega-lite/docs/selection.html#project) and initial values.
    /// __See also:__ [`init`](https://vega.github.io/vega-lite/docs/value.html) documentation.
    public var value: ValueChoice?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.bind as KeyPath, \Self.name as KeyPath, \Self.select as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.bind as KeyPath : CodingKeys.bind, \Self.name as KeyPath : CodingKeys.name, \Self.select as KeyPath : CodingKeys.select, \Self.value as KeyPath : CodingKeys.value]

    public init(id: ParameterId? = nil, bind: BindChoice? = nil, name: ParameterName, select: SelectChoice, value: ValueChoice? = nil) {
        self.id = id 
        self.bind = bind 
        self.name = name 
        self.select = select 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(ParameterId.self, forKey: .id) 
        self.bind = try values.decodeOptional(BindChoice.self, forKey: .bind) 
        self.name = try values.decode(ParameterName.self, forKey: .name) 
        self.select = try values.decode(SelectChoice.self, forKey: .select) 
        self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
    }

    /// When set, a selection is populated by input elements (also known as dynamic query widgets) or by interacting with the corresponding legend. Direct manipulation interaction is disabled by default; to re-enable it, set the selection's [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties) property.
    /// Legend bindings are restricted to selections that only specify a single field or encoding.
    /// Query widget binding takes the form of Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between projected field/encodings and binding definitions.
    /// __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
    /// Generated by Curio
    public typealias BindChoice = BindTypes.Choice
    public enum BindTypes {

        public typealias Choice = OneOf<BindControl>.Or<Type1>.Or<LegendBinding>.Or<LiteralScales>

        public typealias Type1 = Dictionary<String, Type1Value>
        public typealias Type1Value = BindControl

        /// When set, a selection is populated by input elements (also known as dynamic query widgets) or by interacting with the corresponding legend. Direct manipulation interaction is disabled by default; to re-enable it, set the selection's [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties) property.
        /// Legend bindings are restricted to selections that only specify a single field or encoding.
        /// Query widget binding takes the form of Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between projected field/encodings and binding definitions.
        /// __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
        /// Generated by Curio
        public enum LiteralScales : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
            case scales
        }
    }

    /// Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:
    /// - `"point"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.
    /// - `"interval"` -- to select a continuous range of data values on `drag`.
    /// Generated by Curio
    public typealias SelectChoice = OneOf<SelectionType>.Or<PointSelectionConfig>.Or<IntervalSelectionConfig>

    /// Initialize the selection with a mapping between [projected channels or field names](https://vega.github.io/vega-lite/docs/selection.html#project) and initial values.
    /// __See also:__ [`init`](https://vega.github.io/vega-lite/docs/value.html) documentation.
    /// Generated by Curio
    public typealias ValueChoice = OneOf<SelectionInit>.Or<[SelectionInitMapping]>.Or<SelectionInitIntervalMapping>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case bind
        case name
        case select
        case value
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .bind: return "When set, a selection is populated by input elements (also known as dynamic query widgets) or by interacting with the corresponding legend. Direct manipulation interaction is disabled by default; to re-enable it, set the selection's [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties) property.\n\nLegend bindings are restricted to selections that only specify a single field or encoding.\n\nQuery widget binding takes the form of Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between projected field/encodings and binding definitions.\n\n__See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation."
            case .name: return "Required. A unique name for the selection parameter. Selection names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or \"$\", or \"_\") and may not start with a digit. Reserved keywords that may not be used as parameter names are \"datum\", \"event\", \"item\", and \"parent\"."
            case .select: return "Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:\n\n- `\"point\"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.\n- `\"interval\"` -- to select a continuous range of data values on `drag`."
            case .value: return "Initialize the selection with a mapping between [projected channels or field names](https://vega.github.io/vega-lite/docs/selection.html#project) and initial values.\n\n__See also:__ [`init`](https://vega.github.io/vega-lite/docs/value.html) documentation."
             } 
        }

        public typealias CodingOwner = SelectionParameter
    }
}

/// Generated by Curio
public struct SequenceGenerator : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Provide a placeholder name and bind data at runtime.
    public var name: String?
    /// Generate a sequence of numbers.
    public var sequence: SequenceParams
    public static let codingKeyPaths = (\Self.name as KeyPath, \Self.sequence as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.name as KeyPath : CodingKeys.name, \Self.sequence as KeyPath : CodingKeys.sequence]

    public init(name: String? = nil, sequence: SequenceParams) {
        self.name = name 
        self.sequence = sequence 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.sequence = try values.decode(SequenceParams.self, forKey: .sequence) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case name
        case sequence
        public var keyDescription: String? {
            switch self {
            case .name: return "Provide a placeholder name and bind data at runtime."
            case .sequence: return "Generate a sequence of numbers."
             } 
        }

        public typealias CodingOwner = SequenceGenerator
    }
}

/// Generated by Curio
public struct SequenceParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The name of the generated sequence field.
    /// __Default value:__ `"data"`
    public var `as`: FieldName?
    /// The starting value of the sequence (inclusive).
    public var start: Double
    /// The step value between sequence entries.
    /// __Default value:__ `1`
    public var step: Double?
    /// The ending value of the sequence (exclusive).
    public var stop: Double
    public static let codingKeyPaths = (\Self.`as` as KeyPath, \Self.start as KeyPath, \Self.step as KeyPath, \Self.stop as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.`as` as KeyPath : CodingKeys.`as`, \Self.start as KeyPath : CodingKeys.start, \Self.step as KeyPath : CodingKeys.step, \Self.stop as KeyPath : CodingKeys.stop]

    public init(`as`: FieldName? = nil, start: Double, step: Double? = nil, stop: Double) {
        self.`as` = `as` 
        self.start = start 
        self.step = step 
        self.stop = stop 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.`as` = try values.decodeOptional(FieldName.self, forKey: .`as`) 
        self.start = try values.decode(Double.self, forKey: .start) 
        self.step = try values.decodeOptional(Double.self, forKey: .step) 
        self.stop = try values.decode(Double.self, forKey: .stop) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case `as`
        case start
        case step
        case stop
        public var keyDescription: String? {
            switch self {
            case .`as`: return "The name of the generated sequence field.\n\n__Default value:__ `\"data\"`"
            case .start: return "The starting value of the sequence (inclusive)."
            case .step: return "The step value between sequence entries.\n\n__Default value:__ `1`"
            case .stop: return "The ending value of the sequence (exclusive)."
             } 
        }

        public typealias CodingOwner = SequenceParams
    }
}

/// Generated by Curio
public struct SharedEncoding : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var angle: Angle?
    public var color: Color?
    public var description: Description?
    /// Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel.
    public var detail: DetailChoice?
    public var fill: Fill?
    public var fillOpacity: FillOpacity?
    public var href: Href?
    public var key: Key?
    public var latitude: Latitude?
    public var latitude2: Latitude2?
    public var longitude: Longitude?
    public var longitude2: Longitude2?
    public var opacity: Opacity?
    /// Order of the marks.
    /// - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).
    /// - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{"value": null}` makes the line marks use the original order in the data sources.
    /// - Otherwise, this `order` channel encodes layer order of the marks.
    /// __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.
    public var order: OrderChoice?
    public var radius: Radius?
    public var radius2: Radius2?
    public var shape: Shape?
    public var size: Size?
    public var stroke: Stroke?
    public var strokeDash: StrokeDash?
    public var strokeOpacity: StrokeOpacity?
    public var strokeWidth: StrokeWidth?
    public var text: Text?
    public var theta: Theta?
    public var theta2: Theta2?
    /// The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite.
    public var tooltip: TooltipChoice?
    public var url: Url?
    public var x: X?
    public var x2: X2?
    public var xError: XError?
    public var xError2: XError2?
    public var y: Y?
    public var y2: Y2?
    public var yError: YError?
    public var yError2: YError2?
    public static let codingKeyPaths = (\Self.angle as KeyPath, \Self.color as KeyPath, \Self.description as KeyPath, \Self.detail as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.href as KeyPath, \Self.key as KeyPath, \Self.latitude as KeyPath, \Self.latitude2 as KeyPath, \Self.longitude as KeyPath, \Self.longitude2 as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.stroke as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.xError as KeyPath, \Self.xError2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath, \Self.yError as KeyPath, \Self.yError2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.angle as KeyPath : CodingKeys.angle, \Self.color as KeyPath : CodingKeys.color, \Self.description as KeyPath : CodingKeys.description, \Self.detail as KeyPath : CodingKeys.detail, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.href as KeyPath : CodingKeys.href, \Self.key as KeyPath : CodingKeys.key, \Self.latitude as KeyPath : CodingKeys.latitude, \Self.latitude2 as KeyPath : CodingKeys.latitude2, \Self.longitude as KeyPath : CodingKeys.longitude, \Self.longitude2 as KeyPath : CodingKeys.longitude2, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.xError as KeyPath : CodingKeys.xError, \Self.xError2 as KeyPath : CodingKeys.xError2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2, \Self.yError as KeyPath : CodingKeys.yError, \Self.yError2 as KeyPath : CodingKeys.yError2]

    public init(angle: Angle? = nil, color: Color? = nil, description: Description? = nil, detail: DetailChoice? = nil, fill: Fill? = nil, fillOpacity: FillOpacity? = nil, href: Href? = nil, key: Key? = nil, latitude: Latitude? = nil, latitude2: Latitude2? = nil, longitude: Longitude? = nil, longitude2: Longitude2? = nil, opacity: Opacity? = nil, order: OrderChoice? = nil, radius: Radius? = nil, radius2: Radius2? = nil, shape: Shape? = nil, size: Size? = nil, stroke: Stroke? = nil, strokeDash: StrokeDash? = nil, strokeOpacity: StrokeOpacity? = nil, strokeWidth: StrokeWidth? = nil, text: Text? = nil, theta: Theta? = nil, theta2: Theta2? = nil, tooltip: TooltipChoice? = nil, url: Url? = nil, x: X? = nil, x2: X2? = nil, xError: XError? = nil, xError2: XError2? = nil, y: Y? = nil, y2: Y2? = nil, yError: YError? = nil, yError2: YError2? = nil) {
        self.angle = angle 
        self.color = color 
        self.description = description 
        self.detail = detail 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.href = href 
        self.key = key 
        self.latitude = latitude 
        self.latitude2 = latitude2 
        self.longitude = longitude 
        self.longitude2 = longitude2 
        self.opacity = opacity 
        self.order = order 
        self.radius = radius 
        self.radius2 = radius2 
        self.shape = shape 
        self.size = size 
        self.stroke = stroke 
        self.strokeDash = strokeDash 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.tooltip = tooltip 
        self.url = url 
        self.x = x 
        self.x2 = x2 
        self.xError = xError 
        self.xError2 = xError2 
        self.y = y 
        self.y2 = y2 
        self.yError = yError 
        self.yError2 = yError2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.angle = try values.decodeOptional(Angle.self, forKey: .angle) 
        self.color = try values.decodeOptional(Color.self, forKey: .color) 
        self.description = try values.decodeOptional(Description.self, forKey: .description) 
        self.detail = try values.decodeOptional(DetailChoice.self, forKey: .detail) 
        self.fill = try values.decodeOptional(Fill.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacity.self, forKey: .fillOpacity) 
        self.href = try values.decodeOptional(Href.self, forKey: .href) 
        self.key = try values.decodeOptional(Key.self, forKey: .key) 
        self.latitude = try values.decodeOptional(Latitude.self, forKey: .latitude) 
        self.latitude2 = try values.decodeOptional(Latitude2.self, forKey: .latitude2) 
        self.longitude = try values.decodeOptional(Longitude.self, forKey: .longitude) 
        self.longitude2 = try values.decodeOptional(Longitude2.self, forKey: .longitude2) 
        self.opacity = try values.decodeOptional(Opacity.self, forKey: .opacity) 
        self.order = try values.decodeOptional(OrderChoice.self, forKey: .order) 
        self.radius = try values.decodeOptional(Radius.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2.self, forKey: .radius2) 
        self.shape = try values.decodeOptional(Shape.self, forKey: .shape) 
        self.size = try values.decodeOptional(Size.self, forKey: .size) 
        self.stroke = try values.decodeOptional(Stroke.self, forKey: .stroke) 
        self.strokeDash = try values.decodeOptional(StrokeDash.self, forKey: .strokeDash) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacity.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidth.self, forKey: .strokeWidth) 
        self.text = try values.decodeOptional(Text.self, forKey: .text) 
        self.theta = try values.decodeOptional(Theta.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2.self, forKey: .theta2) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(Url.self, forKey: .url) 
        self.x = try values.decodeOptional(X.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2.self, forKey: .x2) 
        self.xError = try values.decodeOptional(XError.self, forKey: .xError) 
        self.xError2 = try values.decodeOptional(XError2.self, forKey: .xError2) 
        self.y = try values.decodeOptional(Y.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2.self, forKey: .y2) 
        self.yError = try values.decodeOptional(YError.self, forKey: .yError) 
        self.yError2 = try values.decodeOptional(YError2.self, forKey: .yError2) 
    }

    /// Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel.
    /// Generated by Curio
    public typealias DetailChoice = OneOrMany<FieldDefWithoutScale>

    /// Order of the marks.
    /// - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).
    /// - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{"value": null}` makes the line marks use the original order in the data sources.
    /// - Otherwise, this `order` channel encodes layer order of the marks.
    /// __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.
    /// Generated by Curio
    public typealias OrderChoice = OneOf<OneOrMany<OrderFieldDef>>.Or<OrderValueDef>

    /// The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite.
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<StringFieldDefWithCondition>.Or<StringValueDefWithCondition>.Or<[StringFieldDef]>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case angle
        case color
        case description
        case detail
        case fill
        case fillOpacity
        case href
        case key
        case latitude
        case latitude2
        case longitude
        case longitude2
        case opacity
        case order
        case radius
        case radius2
        case shape
        case size
        case stroke
        case strokeDash
        case strokeOpacity
        case strokeWidth
        case text
        case theta
        case theta2
        case tooltip
        case url
        case x
        case x2
        case xError
        case xError2
        case y
        case y2
        case yError
        case yError2
        public var keyDescription: String? {
            switch self {
            case .angle: return nil
            case .color: return nil
            case .description: return nil
            case .detail: return "Additional levels of detail for grouping data in aggregate views and in line, trail, and area marks without mapping data to a specific visual channel."
            case .fill: return nil
            case .fillOpacity: return nil
            case .href: return nil
            case .key: return nil
            case .latitude: return nil
            case .latitude2: return nil
            case .longitude: return nil
            case .longitude2: return nil
            case .opacity: return nil
            case .order: return "Order of the marks.\n- For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).\n- For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{\"value\": null}` makes the line marks use the original order in the data sources.\n- Otherwise, this `order` channel encodes layer order of the marks.\n\n__Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping."
            case .radius: return nil
            case .radius2: return nil
            case .shape: return nil
            case .size: return nil
            case .stroke: return nil
            case .strokeDash: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .text: return nil
            case .theta: return nil
            case .theta2: return nil
            case .tooltip: return "The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite."
            case .url: return nil
            case .x: return nil
            case .x2: return nil
            case .xError: return nil
            case .xError2: return nil
            case .y: return nil
            case .y2: return nil
            case .yError: return nil
            case .yError2: return nil
             } 
        }

        public typealias CodingOwner = SharedEncoding
    }

    /// Generated by Curio
    public struct Angle : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefNumberExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Angle
        }
    }

    /// Generated by Curio
    public struct Color : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefGradientStringNullExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefGradientStringNullExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<OneOf<ColorGradient>.Or<String>.Or<ExprRef>>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Color
        }
    }

    /// Generated by Curio
    public struct Description : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
        /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
        /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
        /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
        /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
        public var format: FormatChoice?
        /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
        /// __Default value:__
        /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
        /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
        public var formatType: String?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: StandardMeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.field = field 
            self.format = format 
            self.formatType = formatType 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
            self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefStringExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefStringNullExprRef>>>

        /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
        /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
        /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
        /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
        /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
        /// Generated by Curio
        public typealias FormatChoice = OneOf<String>.Or<Dict>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<OneOf<String>.Or<ExprRef>>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case field
            case format
            case formatType
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
                case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Description
        }
    }

    /// Generated by Curio
    public struct Fill : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefGradientStringNullExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefGradientStringNullExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<OneOf<ColorGradient>.Or<String>.Or<ExprRef>>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Fill
        }
    }

    /// Generated by Curio
    public struct FillOpacity : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefNumberExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = FillOpacity
        }
    }

    /// Generated by Curio
    public struct Href : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
        /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
        /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
        /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
        /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
        public var format: FormatChoice?
        /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
        /// __Default value:__
        /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
        /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
        public var formatType: String?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: StandardMeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.field = field 
            self.format = format 
            self.formatType = formatType 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
            self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefStringExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefStringNullExprRef>>>

        /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
        /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
        /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
        /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
        /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
        /// Generated by Curio
        public typealias FormatChoice = OneOf<String>.Or<Dict>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<OneOf<String>.Or<ExprRef>>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case field
            case format
            case formatType
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
                case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Href
        }
    }

    /// Generated by Curio
    public struct Key : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: StandardMeasureType?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case field
            case timeUnit
            case title
            case type
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Key
        }
    }

    /// Generated by Curio
    public struct Latitude : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<LiteralQuantitative>.Or<MeasureType>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case timeUnit
            case title
            case type
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Latitude
        }
    }

    /// Generated by Curio
    public struct Latitude2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: MeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Latitude2
        }
    }

    /// Generated by Curio
    public struct Longitude : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<LiteralQuantitative>.Or<MeasureType>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case timeUnit
            case title
            case type
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                 } 
            }

            public typealias CodingOwner = Longitude
        }
    }

    /// Generated by Curio
    public struct Longitude2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: MeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Longitude2
        }
    }

    /// Generated by Curio
    public struct Opacity : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefNumberExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Opacity
        }
    }

    /// Generated by Curio
    public struct Radius : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        /// `stack` can be one of the following values:
        /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
        /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
        /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
        public var stack: StackChoice?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.stack as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.stack as KeyPath : CodingKeys.stack, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, stack: StackChoice? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.scale = scale 
            self.sort = sort 
            self.stack = stack 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.stack = try values.decodeOptional(StackChoice.self, forKey: .stack) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        /// `stack` can be one of the following values:
        /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
        /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
        /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
        /// Generated by Curio
        public typealias StackChoice = Nullable<OneOf<StackOffset>.Or<Bool>>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case scale
            case sort
            case stack
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .stack: return "Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n- `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.\n\n__See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Radius
        }
    }

    /// Generated by Curio
    public struct Radius2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: MeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Radius2
        }
    }

    /// Generated by Curio
    public struct Shape : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefStringNullExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDefTypeForShape>.Or<OneOrMany<ConditionalValueDefStringNullExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<TypeForShape>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<OneOf<String>.Or<ExprRef>>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Shape
        }
    }

    /// Generated by Curio
    public struct Size : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefNumberExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Size
        }
    }

    /// Generated by Curio
    public struct Stroke : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefGradientStringNullExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefGradientStringNullExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<OneOf<ColorGradient>.Or<String>.Or<ExprRef>>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Stroke
        }
    }

    /// Generated by Curio
    public struct StrokeDash : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefNumberArrayExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberArrayExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<[Double]>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = StrokeDash
        }
    }

    /// Generated by Curio
    public struct StrokeOpacity : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefNumberExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = StrokeOpacity
        }
    }

    /// Generated by Curio
    public struct StrokeWidth : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        public var legend: LegendChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.legend as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.legend as KeyPath : CodingKeys.legend, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, legend: LegendChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.legend = legend 
            self.scale = scale 
            self.sort = sort 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.legend = try values.decodeOptional(LegendChoice.self, forKey: .legend) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefNumberExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
        /// Generated by Curio
        public typealias LegendChoice = Nullable<LegendDef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case legend
            case scale
            case sort
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .legend: return "An object defining properties of the legend. If `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n\n__See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = StrokeWidth
        }
    }

    /// Generated by Curio
    public struct Text : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
        /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
        /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
        /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
        /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
        public var format: FormatChoice?
        /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
        /// __Default value:__
        /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
        /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
        public var formatType: String?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.datum = datum 
            self.field = field 
            self.format = format 
            self.formatType = formatType 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
            self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefTextExprRef>>.Or<OneOf<ConditionalStringFieldDef>.Or<OneOrMany<ConditionalValueDefTextExprRef>>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
        /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
        /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
        /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
        /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
        /// Generated by Curio
        public typealias FormatChoice = OneOf<String>.Or<Dict>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<StringList>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case datum
            case field
            case format
            case formatType
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
                case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Text
        }
    }

    /// Generated by Curio
    public struct Theta : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        /// `stack` can be one of the following values:
        /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
        /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
        /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
        public var stack: StackChoice?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.stack as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.stack as KeyPath : CodingKeys.stack, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, stack: StackChoice? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.scale = scale 
            self.sort = sort 
            self.stack = stack 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.stack = try values.decodeOptional(StackChoice.self, forKey: .stack) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        /// `stack` can be one of the following values:
        /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
        /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
        /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
        /// Generated by Curio
        public typealias StackChoice = Nullable<OneOf<StackOffset>.Or<Bool>>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case scale
            case sort
            case stack
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .stack: return "Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n- `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.\n\n__See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Theta
        }
    }

    /// Generated by Curio
    public struct Theta2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: MeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Theta2
        }
    }

    /// Generated by Curio
    public struct Url : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        public var condition: ConditionChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
        /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
        /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
        /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
        /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
        public var format: FormatChoice?
        /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
        /// __Default value:__
        /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
        /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
        public var formatType: String?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: StandardMeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.condition as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.condition as KeyPath : CodingKeys.condition, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, condition: ConditionChoice? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.condition = condition 
            self.field = field 
            self.format = format 
            self.formatType = formatType 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
            self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).
        /// __Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel.
        /// Generated by Curio
        public typealias ConditionChoice = OneOf<OneOrMany<ConditionalValueDefStringExprRef>>.Or<OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefStringNullExprRef>>>

        /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
        /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
        /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
        /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
        /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
        /// Generated by Curio
        public typealias FormatChoice = OneOf<String>.Or<Dict>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = Nullable<OneOf<String>.Or<ExprRef>>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case condition
            case field
            case format
            case formatType
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .condition: return "One or more value definition(s) with [a parameter or a test predicate](https://vega.github.io/vega-lite/docs/condition.html).\n\n__Note:__ A field definition's `condition` property can only contain [conditional value definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite only allows at most one encoded field per encoding channel."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
                case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Url
        }
    }

    /// Generated by Curio
    public struct X : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
        /// __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
        public var axis: AxisChoice?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.
        /// __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
        public var impute: ImputeChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        /// `stack` can be one of the following values:
        /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
        /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
        /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
        public var stack: StackChoice?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.axis as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.impute as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.stack as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.axis as KeyPath : CodingKeys.axis, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.impute as KeyPath : CodingKeys.impute, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.stack as KeyPath : CodingKeys.stack, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, axis: AxisChoice? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, impute: ImputeChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, stack: StackChoice? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.axis = axis 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.impute = impute 
            self.scale = scale 
            self.sort = sort 
            self.stack = stack 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.axis = try values.decodeOptional(AxisChoice.self, forKey: .axis) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.impute = try values.decodeOptional(ImputeChoice.self, forKey: .impute) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.stack = try values.decodeOptional(StackChoice.self, forKey: .stack) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
        /// __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
        /// Generated by Curio
        public typealias AxisChoice = Nullable<AxisDef>

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.
        /// __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
        /// Generated by Curio
        public typealias ImputeChoice = Nullable<ImputeParams>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        /// `stack` can be one of the following values:
        /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
        /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
        /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
        /// Generated by Curio
        public typealias StackChoice = Nullable<OneOf<StackOffset>.Or<Bool>>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case axis
            case bandPosition
            case bin
            case datum
            case field
            case impute
            case scale
            case sort
            case stack
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .axis: return "An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.\n\n__See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .impute: return "An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.\n\n__See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .stack: return "Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n- `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.\n\n__See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = X
        }
    }

    /// Generated by Curio
    public struct X2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: MeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = X2
        }
    }

    /// Generated by Curio
    public struct XError : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: Double?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, value: Double? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.value = try values.decodeOptional(Double.self, forKey: .value) 
        }

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case field
            case timeUnit
            case title
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = XError
        }
    }

    /// Generated by Curio
    public struct XError2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: Double?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, value: Double? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.value = try values.decodeOptional(Double.self, forKey: .value) 
        }

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case field
            case timeUnit
            case title
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = XError2
        }
    }

    /// Generated by Curio
    public struct Y : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
        /// __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
        public var axis: AxisChoice?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: BinChoice?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.
        /// __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
        public var impute: ImputeChoice?
        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        public var scale: ScaleChoice?
        /// Sort order for the encoded field.
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or `"descending"`.
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in JavaScript.
        /// - [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order": "descending"}`.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.
        /// - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `"month"` and `"day"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        /// __Default value:__ `"ascending"`
        /// __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
        /// __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
        public var sort: Sort?
        /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        /// `stack` can be one of the following values:
        /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
        /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
        /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
        public var stack: StackChoice?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: TypeChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.axis as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.impute as KeyPath, \Self.scale as KeyPath, \Self.sort as KeyPath, \Self.stack as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.axis as KeyPath : CodingKeys.axis, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.impute as KeyPath : CodingKeys.impute, \Self.scale as KeyPath : CodingKeys.scale, \Self.sort as KeyPath : CodingKeys.sort, \Self.stack as KeyPath : CodingKeys.stack, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, axis: AxisChoice? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, impute: ImputeChoice? = nil, scale: ScaleChoice? = nil, sort: Sort? = nil, stack: StackChoice? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: TypeChoice? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.axis = axis 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.impute = impute 
            self.scale = scale 
            self.sort = sort 
            self.stack = stack 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.axis = try values.decodeOptional(AxisChoice.self, forKey: .axis) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.impute = try values.decodeOptional(ImputeChoice.self, forKey: .impute) 
            self.scale = try values.decodeOptional(ScaleChoice.self, forKey: .scale) 
            self.sort = try values.decodeOptional(Sort.self, forKey: .sort) 
            self.stack = try values.decodeOptional(StackChoice.self, forKey: .stack) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(TypeChoice.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.
        /// __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
        /// __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
        /// Generated by Curio
        public typealias AxisChoice = Nullable<AxisDef>

        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        /// Generated by Curio
        public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.
        /// __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
        /// Generated by Curio
        public typealias ImputeChoice = Nullable<ImputeParams>

        /// An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
        /// If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        /// __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
        /// Generated by Curio
        public typealias ScaleChoice = Nullable<ScaleDef>

        /// Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        /// `stack` can be one of the following values:
        /// - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.
        /// __Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.
        /// __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
        /// Generated by Curio
        public typealias StackChoice = Nullable<OneOf<StackOffset>.Or<Bool>>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        /// Generated by Curio
        public typealias TypeChoice = OneOf<StandardMeasureType>.Or<MeasureType>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case axis
            case bandPosition
            case bin
            case datum
            case field
            case impute
            case scale
            case sort
            case stack
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .axis: return "An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.\n\n__See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .impute: return "An object defining the properties of the Impute Operation to be applied. The field value of the other positional channel is taken as `key` of the `Impute` Operation. The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.\n\n__See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation."
                case .scale: return "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\nIf `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n\n__Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n\n__See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation."
                case .sort: return "Sort order for the encoded field.\n\nFor continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n\nFor discrete fields, `sort` can be one of the following:\n- `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in JavaScript.\n- [A string indicating an encoding channel name to sort by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `\"x\"` or `\"y\"`) with an optional minus prefix for descending sort (e.g., `\"-x\"` to sort by x-field, descending). This channel string is short-form of [a sort-by-encoding definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For example, `\"sort\": \"-x\"` is equivalent to `\"sort\": {\"encoding\": \"x\", \"order\": \"descending\"}`.\n- [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n- [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order. For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n- `null` indicating no sort.\n\n__Default value:__ `\"ascending\"`\n\n__Note:__ `null` and sorting by another channel is not supported for `row` and `column`.\n\n__See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation."
                case .stack: return "Type of stacking offset if the field should be stacked. `stack` is only applicable for `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"` or `true`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n- `null` or `false` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true: (1) the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a linear scale; (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y. Otherwise, `null` by default.\n\n__See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Y
        }
    }

    /// Generated by Curio
    public struct Y2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// A constant value in data domain.
        public var datum: DatumChoice?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
        /// __Default value:__
        /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
        /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
        /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
        /// 2) For a constant value in data domain (`datum`):
        /// - `"quantitative"` if the datum is a number
        /// - `"nominal"` if the datum is a string
        /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
        /// __Note:__
        /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
        /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
        /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
        /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
        /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
        /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
        public var type: MeasureType?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: ValueChoice?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.datum as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.datum as KeyPath : CodingKeys.datum, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, datum: DatumChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: MeasureType? = nil, value: ValueChoice? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.datum = datum 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.type = type 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.datum = try values.decodeOptional(DatumChoice.self, forKey: .datum) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.type = try values.decodeOptional(MeasureType.self, forKey: .type) 
            self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        }

        /// A constant value in data domain.
        /// Generated by Curio
        public typealias DatumChoice = OneOf<PrimitiveValue>.Or<DateTime>.Or<ExprRef>.Or<RepeatRef>

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        /// Generated by Curio
        public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case datum
            case field
            case timeUnit
            case title
            case type
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .datum: return "A constant value in data domain."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = Y2
        }
    }

    /// Generated by Curio
    public struct YError : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: Double?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, value: Double? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.value = try values.decodeOptional(Double.self, forKey: .value) 
        }

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case field
            case timeUnit
            case title
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = YError
        }
    }

    /// Generated by Curio
    public struct YError2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
        public var aggregate: Aggregate?
        /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
        public var bandPosition: Double?
        /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
        /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        /// __Default value:__ `false`
        /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
        public var bin: ExplicitNull?
        /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
        /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
        public var field: SourceColumnRef?
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        public var timeUnit: TimeUnitChoice?
        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        public var title: TitleChoice?
        /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
        public var value: Double?
        public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.value as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.value as KeyPath : CodingKeys.value]

        public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: ExplicitNull? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, value: Double? = nil) {
            self.aggregate = aggregate 
            self.bandPosition = bandPosition 
            self.bin = bin 
            self.field = field 
            self.timeUnit = timeUnit 
            self.title = title 
            self.value = value 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
            self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
            self.bin = try values.decodeOptional(ExplicitNull.self, forKey: .bin) 
            self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
            self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.value = try values.decodeOptional(Double.self, forKey: .value) 
        }

        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        /// __Default value:__ `undefined` (None)
        /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
        /// Generated by Curio
        public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

        /// A title for the field. If `null`, the title will be removed.
        /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
        /// __Notes__:
        /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
        /// Generated by Curio
        public typealias TitleChoice = Nullable<StringList>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case aggregate
            case bandPosition
            case bin
            case field
            case timeUnit
            case title
            case value
            public var keyDescription: String? {
                switch self {
                case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
                case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
                case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
                case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
                case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
                case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
                case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
                 } 
            }

            public typealias CodingOwner = YError2
        }
    }
}

public struct SingleTimeUnit : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<LocalSingleTimeUnit>.Or<UtcSingleTimeUnit>

    public init(rawValue: OneOf<LocalSingleTimeUnit>.Or<UtcSingleTimeUnit>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<LocalSingleTimeUnit>.Or<UtcSingleTimeUnit>) {
        self.rawValue = rawValue 
    }
}

public struct Sort : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: Nullable<OneOf<SortArray>.Or<AllSortString>.Or<EncodingSortField>.Or<SortByEncoding>>

    public init(rawValue: Nullable<OneOf<SortArray>.Or<AllSortString>.Or<EncodingSortField>.Or<SortByEncoding>>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: Nullable<OneOf<SortArray>.Or<AllSortString>.Or<EncodingSortField>.Or<SortByEncoding>>) {
        self.rawValue = rawValue 
    }
}

public struct SortArray : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[DateTime]>

    public init(rawValue: OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[DateTime]>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<[Double]>.Or<[String]>.Or<[Bool]>.Or<[DateTime]>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct SortByEncoding : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The [encoding channel](https://vega.github.io/vega-lite/docs/encoding.html#channels) to sort by (e.g., `"x"`, `"y"`)
    public var encoding: SortByChannel
    /// The sort order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
    public var order: OrderChoice?
    public static let codingKeyPaths = (\Self.encoding as KeyPath, \Self.order as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.encoding as KeyPath : CodingKeys.encoding, \Self.order as KeyPath : CodingKeys.order]

    public init(encoding: SortByChannel, order: OrderChoice? = nil) {
        self.encoding = encoding 
        self.order = order 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.encoding = try values.decode(SortByChannel.self, forKey: .encoding) 
        self.order = try values.decodeOptional(OrderChoice.self, forKey: .order) 
    }

    /// The sort order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
    /// Generated by Curio
    public typealias OrderChoice = Nullable<SortOrder>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case encoding
        case order
        public var keyDescription: String? {
            switch self {
            case .encoding: return "The [encoding channel](https://vega.github.io/vega-lite/docs/encoding.html#channels) to sort by (e.g., `\"x\"`, `\"y\"`)"
            case .order: return "The sort order. One of `\"ascending\"` (default), `\"descending\"`, or `null` (no not sort)."
             } 
        }

        public typealias CodingOwner = SortByEncoding
    }
}

/// A sort definition for transform
/// Generated by Curio
public struct SortField : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The name of the field to sort.
    public var field: FieldName
    /// Whether to sort the field in ascending or descending order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
    public var order: OrderChoice?
    public static let codingKeyPaths = (\Self.field as KeyPath, \Self.order as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.field as KeyPath : CodingKeys.field, \Self.order as KeyPath : CodingKeys.order]

    public init(field: FieldName, order: OrderChoice? = nil) {
        self.field = field 
        self.order = order 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.order = try values.decodeOptional(OrderChoice.self, forKey: .order) 
    }

    /// Whether to sort the field in ascending or descending order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
    /// Generated by Curio
    public typealias OrderChoice = Nullable<SortOrder>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case field
        case order
        public var keyDescription: String? {
            switch self {
            case .field: return "The name of the field to sort."
            case .order: return "Whether to sort the field in ascending or descending order. One of `\"ascending\"` (default), `\"descending\"`, or `null` (no not sort)."
             } 
        }

        public typealias CodingOwner = SortField
    }
}

public struct SourceColumnRef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FieldName>.Or<RepeatRef>

    public init(rawValue: OneOf<FieldName>.Or<RepeatRef>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FieldName>.Or<RepeatRef>) {
        self.rawValue = rawValue 
    }
}

public struct Spec : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FacetedUnitSpec>.Or<LayerSpec>.Or<RepeatSpec>.Or<FacetSpec>.Or<ConcatSpecGenericSpec>.Or<VConcatSpecGenericSpec>.Or<HConcatSpecGenericSpec>

    public init(rawValue: OneOf<FacetedUnitSpec>.Or<LayerSpec>.Or<RepeatSpec>.Or<FacetSpec>.Or<ConcatSpecGenericSpec>.Or<VConcatSpecGenericSpec>.Or<HConcatSpecGenericSpec>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FacetedUnitSpec>.Or<LayerSpec>.Or<RepeatSpec>.Or<FacetSpec>.Or<ConcatSpecGenericSpec>.Or<VConcatSpecGenericSpec>.Or<HConcatSpecGenericSpec>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct SphereGenerator : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Provide a placeholder name and bind data at runtime.
    public var name: String?
    /// Generate sphere GeoJSON data for the full globe.
    public var sphere: SphereChoice
    public static let codingKeyPaths = (\Self.name as KeyPath, \Self.sphere as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.name as KeyPath : CodingKeys.name, \Self.sphere as KeyPath : CodingKeys.sphere]

    public init(name: String? = nil, sphere: SphereChoice) {
        self.name = name 
        self.sphere = sphere 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.sphere = try values.decode(SphereChoice.self, forKey: .sphere) 
    }

    /// Generate sphere GeoJSON data for the full globe.
    /// Generated by Curio
    public typealias SphereChoice = OneOf<Bool>.Or<Bric>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case name
        case sphere
        public var keyDescription: String? {
            switch self {
            case .name: return "Provide a placeholder name and bind data at runtime."
            case .sphere: return "Generate sphere GeoJSON data for the full globe."
             } 
        }

        public typealias CodingOwner = SphereGenerator
    }
}

/// Generated by Curio
public struct StackTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// Output field names. This can be either a string or an array of strings with two elements denoting the name for the fields for stack start and stack end respectively. If a single string(e.g., `"val"`) is provided, the end field will be `"val_end"`.
    public var `as`: AsChoice
    /// The data fields to group by.
    public var groupby: [FieldName]
    /// Mode for stacking marks. One of `"zero"` (default), `"center"`, or `"normalize"`. The `"zero"` offset will stack starting at `0`. The `"center"` offset will center the stacks. The `"normalize"` offset will compute percentage values for each stack point, with output values in the range `[0,1]`.
    /// __Default value:__ `"zero"`
    public var offset: LiteralZeroOrCenterOrNormalize?
    /// Field that determines the order of leaves in the stacked charts.
    public var sort: [SortField]?
    /// The field which is stacked.
    public var stack: FieldName
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.groupby as KeyPath, \Self.offset as KeyPath, \Self.sort as KeyPath, \Self.stack as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.offset as KeyPath : CodingKeys.offset, \Self.sort as KeyPath : CodingKeys.sort, \Self.stack as KeyPath : CodingKeys.stack]

    public init(id: TransformId? = nil, `as`: AsChoice, groupby: [FieldName] = [], offset: LiteralZeroOrCenterOrNormalize? = nil, sort: [SortField]? = nil, stack: FieldName) {
        self.id = id 
        self.`as` = `as` 
        self.groupby = groupby 
        self.offset = offset 
        self.sort = sort 
        self.stack = stack 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decode(AsChoice.self, forKey: .`as`) 
        self.groupby = try values.decode([FieldName].self, forKey: .groupby) 
        self.offset = try values.decodeOptional(LiteralZeroOrCenterOrNormalize.self, forKey: .offset) 
        self.sort = try values.decodeOptional([SortField].self, forKey: .sort) 
        self.stack = try values.decode(FieldName.self, forKey: .stack) 
    }

    /// Output field names. This can be either a string or an array of strings with two elements denoting the name for the fields for stack start and stack end respectively. If a single string(e.g., `"val"`) is provided, the end field will be `"val_end"`.
    /// Generated by Curio
    public typealias AsChoice = OneOrMany<FieldName>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case groupby
        case offset
        case sort
        case stack
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "Output field names. This can be either a string or an array of strings with two elements denoting the name for the fields for stack start and stack end respectively. If a single string(e.g., `\"val\"`) is provided, the end field will be `\"val_end\"`."
            case .groupby: return "The data fields to group by."
            case .offset: return "Mode for stacking marks. One of `\"zero\"` (default), `\"center\"`, or `\"normalize\"`. The `\"zero\"` offset will stack starting at `0`. The `\"center\"` offset will center the stacks. The `\"normalize\"` offset will compute percentage values for each stack point, with output values in the range `[0,1]`.\n\n__Default value:__ `\"zero\"`"
            case .sort: return "Field that determines the order of leaves in the stacked charts."
            case .stack: return "The field which is stacked."
             } 
        }

        public typealias CodingOwner = StackTransform
    }

    /// Mode for stacking marks. One of `"zero"` (default), `"center"`, or `"normalize"`. The `"zero"` offset will stack starting at `0`. The `"center"` offset will center the stacks. The `"normalize"` offset will compute percentage values for each stack point, with output values in the range `[0,1]`.
    /// __Default value:__ `"zero"`
    /// Generated by Curio
    public enum LiteralZeroOrCenterOrNormalize : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case zero
        case center
        case normalize
    }
}

/// Generated by Curio
public struct Step : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The size (width/height) per discrete step.
    public var step: Double
    public static let codingKeyPaths = (\Self.step as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.step as KeyPath : CodingKeys.step]

    public init(step: Double) {
        self.step = step 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.step = try values.decode(Double.self, forKey: .step) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case step
        public var keyDescription: String? {
            switch self {
            case .step: return "The size (width/height) per discrete step."
             } 
        }

        public typealias CodingOwner = Step
    }
}

public struct Stream : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<EventStream>.Or<DerivedStream>.Or<MergedStream>

    public init(rawValue: OneOf<EventStream>.Or<DerivedStream>.Or<MergedStream>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<EventStream>.Or<DerivedStream>.Or<MergedStream>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct StringFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    public var format: FormatChoice?
    /// The format type for labels. One of `"number"`, `"time"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
    /// __Default value:__
    /// - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
    /// - `"number"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`.
    public var formatType: String?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.format as KeyPath, \Self.formatType as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.format as KeyPath : CodingKeys.format, \Self.formatType as KeyPath : CodingKeys.formatType, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, format: FormatChoice? = nil, formatType: String? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.format = format 
        self.formatType = formatType 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.format = try values.decodeOptional(FormatChoice.self, forKey: .format) 
        self.formatType = try values.decodeOptional(String.self, forKey: .formatType) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// When used with the default `"number"` and `"time"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.
    /// - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).
    /// - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).
    /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.
    /// When used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.
    /// __Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format.
    /// Generated by Curio
    public typealias FormatChoice = OneOf<String>.Or<Dict>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case field
        case format
        case formatType
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .format: return "When used with the default `\"number\"` and `\"time\"` format type, the text formatting pattern for labels of guides (axes, legends, headers) and text marks.\n\n- If the format type is `\"number\"` (e.g., for quantitative fields), this is D3's [number format pattern](https://github.com/d3/d3-format#locale_format).\n- If the format type is `\"time\"` (e.g., for temporal fields), this is D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\nSee the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more examples.\n\nWhen used with a [custom `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this value will be passed as `format` alongside `datum.value` to the registered function.\n\n__Default value:__  Derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for number format and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time format."
            case .formatType: return "The format type for labels. One of `\"number\"`, `\"time\"`, or a [registered custom format type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).\n\n__Default value:__\n- `\"time\"` for temporal fields and ordinal and nominal fields with `timeUnit`.\n- `\"number\"` for quantitative fields as well as ordinal and nominal fields without `timeUnit`."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = StringFieldDef
    }
}

public struct StringList : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOrMany<String>

    public init(rawValue: OneOrMany<String>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOrMany<String>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct StyleConfigIndex : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    private var _arc: Indirect<RectConfig>?
    /// Arc-specific Config
    public var arc: RectConfig? {
        get { return _arc?.wrappedValue }
        set { _arc = newValue.indirect() }
    }
    private var _area: Indirect<AreaConfig>?
    /// Area-Specific Config
    public var area: AreaConfig? {
        get { return _area?.wrappedValue }
        set { _area = newValue.indirect() }
    }
    private var _bar: Indirect<BarConfig>?
    /// Bar-Specific Config
    public var bar: BarConfig? {
        get { return _bar?.wrappedValue }
        set { _bar = newValue.indirect() }
    }
    private var _circle: Indirect<MarkConfig>?
    /// Circle-Specific Config
    public var circle: MarkConfig? {
        get { return _circle?.wrappedValue }
        set { _circle = newValue.indirect() }
    }
    private var _geoshape: Indirect<MarkConfig>?
    /// Geoshape-Specific Config
    public var geoshape: MarkConfig? {
        get { return _geoshape?.wrappedValue }
        set { _geoshape = newValue.indirect() }
    }
    private var _groupsubtitle: Indirect<MarkConfig>?
    /// Default style for chart subtitles
    public var groupsubtitle: MarkConfig? {
        get { return _groupsubtitle?.wrappedValue }
        set { _groupsubtitle = newValue.indirect() }
    }
    private var _grouptitle: Indirect<MarkConfig>?
    /// Default style for chart titles
    public var grouptitle: MarkConfig? {
        get { return _grouptitle?.wrappedValue }
        set { _grouptitle = newValue.indirect() }
    }
    private var _guidelabel: Indirect<MarkConfig>?
    /// Default style for axis, legend, and header labels.
    public var guidelabel: MarkConfig? {
        get { return _guidelabel?.wrappedValue }
        set { _guidelabel = newValue.indirect() }
    }
    private var _guidetitle: Indirect<MarkConfig>?
    /// Default style for axis, legend, and header titles.
    public var guidetitle: MarkConfig? {
        get { return _guidetitle?.wrappedValue }
        set { _guidetitle = newValue.indirect() }
    }
    private var _image: Indirect<RectConfig>?
    /// Image-specific Config
    public var image: RectConfig? {
        get { return _image?.wrappedValue }
        set { _image = newValue.indirect() }
    }
    private var _line: Indirect<LineConfig>?
    /// Line-Specific Config
    public var line: LineConfig? {
        get { return _line?.wrappedValue }
        set { _line = newValue.indirect() }
    }
    private var _mark: Indirect<MarkConfig>?
    /// Mark Config
    public var mark: MarkConfig? {
        get { return _mark?.wrappedValue }
        set { _mark = newValue.indirect() }
    }
    private var _point: Indirect<MarkConfig>?
    /// Point-Specific Config
    public var point: MarkConfig? {
        get { return _point?.wrappedValue }
        set { _point = newValue.indirect() }
    }
    private var _rect: Indirect<RectConfig>?
    /// Rect-Specific Config
    public var rect: RectConfig? {
        get { return _rect?.wrappedValue }
        set { _rect = newValue.indirect() }
    }
    private var _rule: Indirect<MarkConfig>?
    /// Rule-Specific Config
    public var rule: MarkConfig? {
        get { return _rule?.wrappedValue }
        set { _rule = newValue.indirect() }
    }
    private var _square: Indirect<MarkConfig>?
    /// Square-Specific Config
    public var square: MarkConfig? {
        get { return _square?.wrappedValue }
        set { _square = newValue.indirect() }
    }
    private var _text: Indirect<MarkConfig>?
    /// Text-Specific Config
    public var text: MarkConfig? {
        get { return _text?.wrappedValue }
        set { _text = newValue.indirect() }
    }
    private var _tick: Indirect<TickConfig>?
    /// Tick-Specific Config
    public var tick: TickConfig? {
        get { return _tick?.wrappedValue }
        set { _tick = newValue.indirect() }
    }
    private var _trail: Indirect<LineConfig>?
    /// Trail-Specific Config
    public var trail: LineConfig? {
        get { return _trail?.wrappedValue }
        set { _trail = newValue.indirect() }
    }
    public static let codingKeyPaths = (\Self._arc as KeyPath, \Self._area as KeyPath, \Self._bar as KeyPath, \Self._circle as KeyPath, \Self._geoshape as KeyPath, \Self._groupsubtitle as KeyPath, \Self._grouptitle as KeyPath, \Self._guidelabel as KeyPath, \Self._guidetitle as KeyPath, \Self._image as KeyPath, \Self._line as KeyPath, \Self._mark as KeyPath, \Self._point as KeyPath, \Self._rect as KeyPath, \Self._rule as KeyPath, \Self._square as KeyPath, \Self._text as KeyPath, \Self._tick as KeyPath, \Self._trail as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self._arc as KeyPath : CodingKeys._arc, \Self._area as KeyPath : CodingKeys._area, \Self._bar as KeyPath : CodingKeys._bar, \Self._circle as KeyPath : CodingKeys._circle, \Self._geoshape as KeyPath : CodingKeys._geoshape, \Self._groupsubtitle as KeyPath : CodingKeys._groupsubtitle, \Self._grouptitle as KeyPath : CodingKeys._grouptitle, \Self._guidelabel as KeyPath : CodingKeys._guidelabel, \Self._guidetitle as KeyPath : CodingKeys._guidetitle, \Self._image as KeyPath : CodingKeys._image, \Self._line as KeyPath : CodingKeys._line, \Self._mark as KeyPath : CodingKeys._mark, \Self._point as KeyPath : CodingKeys._point, \Self._rect as KeyPath : CodingKeys._rect, \Self._rule as KeyPath : CodingKeys._rule, \Self._square as KeyPath : CodingKeys._square, \Self._text as KeyPath : CodingKeys._text, \Self._tick as KeyPath : CodingKeys._tick, \Self._trail as KeyPath : CodingKeys._trail]

    public init(arc: RectConfig? = nil, area: AreaConfig? = nil, bar: BarConfig? = nil, circle: MarkConfig? = nil, geoshape: MarkConfig? = nil, groupsubtitle: MarkConfig? = nil, grouptitle: MarkConfig? = nil, guidelabel: MarkConfig? = nil, guidetitle: MarkConfig? = nil, image: RectConfig? = nil, line: LineConfig? = nil, mark: MarkConfig? = nil, point: MarkConfig? = nil, rect: RectConfig? = nil, rule: MarkConfig? = nil, square: MarkConfig? = nil, text: MarkConfig? = nil, tick: TickConfig? = nil, trail: LineConfig? = nil) {
        self._arc = arc.indirect() 
        self._area = area.indirect() 
        self._bar = bar.indirect() 
        self._circle = circle.indirect() 
        self._geoshape = geoshape.indirect() 
        self._groupsubtitle = groupsubtitle.indirect() 
        self._grouptitle = grouptitle.indirect() 
        self._guidelabel = guidelabel.indirect() 
        self._guidetitle = guidetitle.indirect() 
        self._image = image.indirect() 
        self._line = line.indirect() 
        self._mark = mark.indirect() 
        self._point = point.indirect() 
        self._rect = rect.indirect() 
        self._rule = rule.indirect() 
        self._square = square.indirect() 
        self._text = text.indirect() 
        self._tick = tick.indirect() 
        self._trail = trail.indirect() 
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self._arc = try values.decodeOptional(Indirect<RectConfig>.self, forKey: ._arc) 
        self._area = try values.decodeOptional(Indirect<AreaConfig>.self, forKey: ._area) 
        self._bar = try values.decodeOptional(Indirect<BarConfig>.self, forKey: ._bar) 
        self._circle = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._circle) 
        self._geoshape = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._geoshape) 
        self._groupsubtitle = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._groupsubtitle) 
        self._grouptitle = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._grouptitle) 
        self._guidelabel = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._guidelabel) 
        self._guidetitle = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._guidetitle) 
        self._image = try values.decodeOptional(Indirect<RectConfig>.self, forKey: ._image) 
        self._line = try values.decodeOptional(Indirect<LineConfig>.self, forKey: ._line) 
        self._mark = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._mark) 
        self._point = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._point) 
        self._rect = try values.decodeOptional(Indirect<RectConfig>.self, forKey: ._rect) 
        self._rule = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._rule) 
        self._square = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._square) 
        self._text = try values.decodeOptional(Indirect<MarkConfig>.self, forKey: ._text) 
        self._tick = try values.decodeOptional(Indirect<TickConfig>.self, forKey: ._tick) 
        self._trail = try values.decodeOptional(Indirect<LineConfig>.self, forKey: ._trail) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case _arc = "arc"
        case _area = "area"
        case _bar = "bar"
        case _circle = "circle"
        case _geoshape = "geoshape"
        case _groupsubtitle = "group-subtitle"
        case _grouptitle = "group-title"
        case _guidelabel = "guide-label"
        case _guidetitle = "guide-title"
        case _image = "image"
        case _line = "line"
        case _mark = "mark"
        case _point = "point"
        case _rect = "rect"
        case _rule = "rule"
        case _square = "square"
        case _text = "text"
        case _tick = "tick"
        case _trail = "trail"
        public var keyDescription: String? {
            switch self {
            case ._arc: return "Arc-specific Config"
            case ._area: return "Area-Specific Config"
            case ._bar: return "Bar-Specific Config"
            case ._circle: return "Circle-Specific Config"
            case ._geoshape: return "Geoshape-Specific Config"
            case ._groupsubtitle: return "Default style for chart subtitles"
            case ._grouptitle: return "Default style for chart titles"
            case ._guidelabel: return "Default style for axis, legend, and header labels."
            case ._guidetitle: return "Default style for axis, legend, and header titles."
            case ._image: return "Image-specific Config"
            case ._line: return "Line-Specific Config"
            case ._mark: return "Mark Config"
            case ._point: return "Point-Specific Config"
            case ._rect: return "Rect-Specific Config"
            case ._rule: return "Rule-Specific Config"
            case ._square: return "Square-Specific Config"
            case ._text: return "Text-Specific Config"
            case ._tick: return "Tick-Specific Config"
            case ._trail: return "Trail-Specific Config"
             } 
        }

        public typealias CodingOwner = StyleConfigIndex
    }
}

public struct SymbolItem : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: SymbolShape

    public init(rawValue: SymbolShape) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: SymbolShape) {
        self.rawValue = rawValue 
    }
}

public struct SymbolShape : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: String) {
        self.rawValue = rawValue 
    }
}

public struct TextBaseline : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<LiteralAlphabetic>.Or<Baseline>.Or<LiteralLineTop>.Or<LiteralLineBottom>

    public init(rawValue: OneOf<LiteralAlphabetic>.Or<Baseline>.Or<LiteralLineTop>.Or<LiteralLineBottom>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<LiteralAlphabetic>.Or<Baseline>.Or<LiteralLineTop>.Or<LiteralLineBottom>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public enum LiteralAlphabetic : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case alphabetic
    }

    /// Generated by Curio
    public enum LiteralLineBottom : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case lineBottom = "line-bottom"
    }

    /// Generated by Curio
    public enum LiteralLineTop : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case lineTop = "line-top"
    }
}

public struct TextDef : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<FieldOrDatumDefWithConditionStringFieldDefText>.Or<FieldOrDatumDefWithConditionStringDatumDefText>.Or<ValueDefWithConditionStringFieldDefText>

    public init(rawValue: OneOf<FieldOrDatumDefWithConditionStringFieldDefText>.Or<FieldOrDatumDefWithConditionStringDatumDefText>.Or<ValueDefWithConditionStringFieldDefText>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<FieldOrDatumDefWithConditionStringFieldDefText>.Or<FieldOrDatumDefWithConditionStringDatumDefText>.Or<ValueDefWithConditionStringFieldDefText>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct TickConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var align: AlignChoice?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    public var ariaRole: AriaRoleChoice?
    public var ariaRoleDescription: AriaRoleDescriptionChoice?
    public var aspect: AspectChoice?
    /// The width of the ticks.
    /// __Default value:__  3/4 of step (width step for horizontal ticks and height step for vertical ticks).
    public var bandSize: Double?
    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    public var baseline: BaselineChoice?
    public var blend: BlendChoice?
    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    public var color: ColorChoice?
    public var cornerRadius: CornerRadiusChoice?
    public var cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice?
    public var cornerRadiusBottomRight: CornerRadiusBottomRightChoice?
    public var cornerRadiusTopLeft: CornerRadiusTopLeftChoice?
    public var cornerRadiusTopRight: CornerRadiusTopRightChoice?
    public var cursor: CursorChoice?
    public var description: DescriptionChoice?
    public var dir: DirChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var ellipsis: EllipsisChoice?
    public var endAngle: EndAngleChoice?
    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// Whether the mark's color should be used as fill color instead of stroke color.
    /// __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.
    /// __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    public var filled: Bool?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var height: HeightChoice?
    public var href: HrefChoice?
    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    public var innerRadius: InnerRadiusChoice?
    public var interpolate: InterpolateChoice?
    /// Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
    /// - If set to `"filter"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).
    /// - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
    public var invalid: Invalid?
    public var limit: LimitChoice?
    public var lineBreak: LineBreakChoice?
    public var lineHeight: LineHeightChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources.
    public var order: Order?
    /// The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored.
    public var orient: Orientation?
    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    public var outerRadius: OuterRadiusChoice?
    public var padAngle: PadAngleChoice?
    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    public var radius: RadiusChoice?
    /// The secondary (inner) radius in pixels of arc marks.
    public var radius2: Radius2Choice?
    public var shape: SymbolShape?
    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    public var size: SizeChoice?
    public var smooth: SmoothChoice?
    public var startAngle: StartAngleChoice?
    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOffset: StrokeOffsetChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    public var tension: TensionChoice?
    public var text: TextChoice?
    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    public var theta: ThetaChoice?
    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    public var theta2: Theta2Choice?
    /// Thickness of the tick mark.
    /// __Default value:__  `1`
    public var thickness: Double?
    /// Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step.
    public var timeUnitBandPosition: Double?
    /// Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step.
    public var timeUnitBandSize: Double?
    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    public var tooltip: TooltipChoice?
    public var url: UrlChoice?
    public var width: WidthChoice?
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x: XChoice?
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    public var x2: X2Choice?
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y: YChoice?
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    public var y2: Y2Choice?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.aspect as KeyPath, \Self.bandSize as KeyPath, \Self.baseline as KeyPath, \Self.blend as KeyPath, \Self.color as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cursor as KeyPath, \Self.description as KeyPath, \Self.dir as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.ellipsis as KeyPath, \Self.endAngle as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.filled as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.height as KeyPath, \Self.href as KeyPath, \Self.innerRadius as KeyPath, \Self.interpolate as KeyPath, \Self.invalid as KeyPath, \Self.limit as KeyPath, \Self.lineBreak as KeyPath, \Self.lineHeight as KeyPath, \Self.opacity as KeyPath, \Self.order as KeyPath, \Self.orient as KeyPath, \Self.outerRadius as KeyPath, \Self.padAngle as KeyPath, \Self.radius as KeyPath, \Self.radius2 as KeyPath, \Self.shape as KeyPath, \Self.size as KeyPath, \Self.smooth as KeyPath, \Self.startAngle as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOffset as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.tension as KeyPath, \Self.text as KeyPath, \Self.theta as KeyPath, \Self.theta2 as KeyPath, \Self.thickness as KeyPath, \Self.timeUnitBandPosition as KeyPath, \Self.timeUnitBandSize as KeyPath, \Self.tooltip as KeyPath, \Self.url as KeyPath, \Self.width as KeyPath, \Self.x as KeyPath, \Self.x2 as KeyPath, \Self.y as KeyPath, \Self.y2 as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.bandSize as KeyPath : CodingKeys.bandSize, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.blend as KeyPath : CodingKeys.blend, \Self.color as KeyPath : CodingKeys.color, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.description as KeyPath : CodingKeys.description, \Self.dir as KeyPath : CodingKeys.dir, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.endAngle as KeyPath : CodingKeys.endAngle, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.filled as KeyPath : CodingKeys.filled, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.height as KeyPath : CodingKeys.height, \Self.href as KeyPath : CodingKeys.href, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.invalid as KeyPath : CodingKeys.invalid, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineBreak as KeyPath : CodingKeys.lineBreak, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.order as KeyPath : CodingKeys.order, \Self.orient as KeyPath : CodingKeys.orient, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.radius as KeyPath : CodingKeys.radius, \Self.radius2 as KeyPath : CodingKeys.radius2, \Self.shape as KeyPath : CodingKeys.shape, \Self.size as KeyPath : CodingKeys.size, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.startAngle as KeyPath : CodingKeys.startAngle, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.tension as KeyPath : CodingKeys.tension, \Self.text as KeyPath : CodingKeys.text, \Self.theta as KeyPath : CodingKeys.theta, \Self.theta2 as KeyPath : CodingKeys.theta2, \Self.thickness as KeyPath : CodingKeys.thickness, \Self.timeUnitBandPosition as KeyPath : CodingKeys.timeUnitBandPosition, \Self.timeUnitBandSize as KeyPath : CodingKeys.timeUnitBandSize, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.url as KeyPath : CodingKeys.url, \Self.width as KeyPath : CodingKeys.width, \Self.x as KeyPath : CodingKeys.x, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y as KeyPath : CodingKeys.y, \Self.y2 as KeyPath : CodingKeys.y2]

    public init(align: AlignChoice? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, ariaRole: AriaRoleChoice? = nil, ariaRoleDescription: AriaRoleDescriptionChoice? = nil, aspect: AspectChoice? = nil, bandSize: Double? = nil, baseline: BaselineChoice? = nil, blend: BlendChoice? = nil, color: ColorChoice? = nil, cornerRadius: CornerRadiusChoice? = nil, cornerRadiusBottomLeft: CornerRadiusBottomLeftChoice? = nil, cornerRadiusBottomRight: CornerRadiusBottomRightChoice? = nil, cornerRadiusTopLeft: CornerRadiusTopLeftChoice? = nil, cornerRadiusTopRight: CornerRadiusTopRightChoice? = nil, cursor: CursorChoice? = nil, description: DescriptionChoice? = nil, dir: DirChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, ellipsis: EllipsisChoice? = nil, endAngle: EndAngleChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, filled: Bool? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, height: HeightChoice? = nil, href: HrefChoice? = nil, innerRadius: InnerRadiusChoice? = nil, interpolate: InterpolateChoice? = nil, invalid: Invalid? = nil, limit: LimitChoice? = nil, lineBreak: LineBreakChoice? = nil, lineHeight: LineHeightChoice? = nil, opacity: OpacityChoice? = nil, order: Order? = nil, orient: Orientation? = nil, outerRadius: OuterRadiusChoice? = nil, padAngle: PadAngleChoice? = nil, radius: RadiusChoice? = nil, radius2: Radius2Choice? = nil, shape: SymbolShape? = nil, size: SizeChoice? = nil, smooth: SmoothChoice? = nil, startAngle: StartAngleChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOffset: StrokeOffsetChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, tension: TensionChoice? = nil, text: TextChoice? = nil, theta: ThetaChoice? = nil, theta2: Theta2Choice? = nil, thickness: Double? = nil, timeUnitBandPosition: Double? = nil, timeUnitBandSize: Double? = nil, tooltip: TooltipChoice? = nil, url: UrlChoice? = nil, width: WidthChoice? = nil, x: XChoice? = nil, x2: X2Choice? = nil, y: YChoice? = nil, y2: Y2Choice? = nil) {
        self.align = align 
        self.angle = angle 
        self.aria = aria 
        self.ariaRole = ariaRole 
        self.ariaRoleDescription = ariaRoleDescription 
        self.aspect = aspect 
        self.bandSize = bandSize 
        self.baseline = baseline 
        self.blend = blend 
        self.color = color 
        self.cornerRadius = cornerRadius 
        self.cornerRadiusBottomLeft = cornerRadiusBottomLeft 
        self.cornerRadiusBottomRight = cornerRadiusBottomRight 
        self.cornerRadiusTopLeft = cornerRadiusTopLeft 
        self.cornerRadiusTopRight = cornerRadiusTopRight 
        self.cursor = cursor 
        self.description = description 
        self.dir = dir 
        self.dx = dx 
        self.dy = dy 
        self.ellipsis = ellipsis 
        self.endAngle = endAngle 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.filled = filled 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.height = height 
        self.href = href 
        self.innerRadius = innerRadius 
        self.interpolate = interpolate 
        self.invalid = invalid 
        self.limit = limit 
        self.lineBreak = lineBreak 
        self.lineHeight = lineHeight 
        self.opacity = opacity 
        self.order = order 
        self.orient = orient 
        self.outerRadius = outerRadius 
        self.padAngle = padAngle 
        self.radius = radius 
        self.radius2 = radius2 
        self.shape = shape 
        self.size = size 
        self.smooth = smooth 
        self.startAngle = startAngle 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOffset = strokeOffset 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.tension = tension 
        self.text = text 
        self.theta = theta 
        self.theta2 = theta2 
        self.thickness = thickness 
        self.timeUnitBandPosition = timeUnitBandPosition 
        self.timeUnitBandSize = timeUnitBandSize 
        self.tooltip = tooltip 
        self.url = url 
        self.width = width 
        self.x = x 
        self.x2 = x2 
        self.y = y 
        self.y2 = y2 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.ariaRole = try values.decodeOptional(AriaRoleChoice.self, forKey: .ariaRole) 
        self.ariaRoleDescription = try values.decodeOptional(AriaRoleDescriptionChoice.self, forKey: .ariaRoleDescription) 
        self.aspect = try values.decodeOptional(AspectChoice.self, forKey: .aspect) 
        self.bandSize = try values.decodeOptional(Double.self, forKey: .bandSize) 
        self.baseline = try values.decodeOptional(BaselineChoice.self, forKey: .baseline) 
        self.blend = try values.decodeOptional(BlendChoice.self, forKey: .blend) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cornerRadiusBottomLeft = try values.decodeOptional(CornerRadiusBottomLeftChoice.self, forKey: .cornerRadiusBottomLeft) 
        self.cornerRadiusBottomRight = try values.decodeOptional(CornerRadiusBottomRightChoice.self, forKey: .cornerRadiusBottomRight) 
        self.cornerRadiusTopLeft = try values.decodeOptional(CornerRadiusTopLeftChoice.self, forKey: .cornerRadiusTopLeft) 
        self.cornerRadiusTopRight = try values.decodeOptional(CornerRadiusTopRightChoice.self, forKey: .cornerRadiusTopRight) 
        self.cursor = try values.decodeOptional(CursorChoice.self, forKey: .cursor) 
        self.description = try values.decodeOptional(DescriptionChoice.self, forKey: .description) 
        self.dir = try values.decodeOptional(DirChoice.self, forKey: .dir) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.ellipsis = try values.decodeOptional(EllipsisChoice.self, forKey: .ellipsis) 
        self.endAngle = try values.decodeOptional(EndAngleChoice.self, forKey: .endAngle) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.filled = try values.decodeOptional(Bool.self, forKey: .filled) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.href = try values.decodeOptional(HrefChoice.self, forKey: .href) 
        self.innerRadius = try values.decodeOptional(InnerRadiusChoice.self, forKey: .innerRadius) 
        self.interpolate = try values.decodeOptional(InterpolateChoice.self, forKey: .interpolate) 
        self.invalid = try values.decodeOptional(Invalid.self, forKey: .invalid) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.lineBreak = try values.decodeOptional(LineBreakChoice.self, forKey: .lineBreak) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.order = try values.decodeOptional(Order.self, forKey: .order) 
        self.orient = try values.decodeOptional(Orientation.self, forKey: .orient) 
        self.outerRadius = try values.decodeOptional(OuterRadiusChoice.self, forKey: .outerRadius) 
        self.padAngle = try values.decodeOptional(PadAngleChoice.self, forKey: .padAngle) 
        self.radius = try values.decodeOptional(RadiusChoice.self, forKey: .radius) 
        self.radius2 = try values.decodeOptional(Radius2Choice.self, forKey: .radius2) 
        self.shape = try values.decodeOptional(SymbolShape.self, forKey: .shape) 
        self.size = try values.decodeOptional(SizeChoice.self, forKey: .size) 
        self.smooth = try values.decodeOptional(SmoothChoice.self, forKey: .smooth) 
        self.startAngle = try values.decodeOptional(StartAngleChoice.self, forKey: .startAngle) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOffset = try values.decodeOptional(StrokeOffsetChoice.self, forKey: .strokeOffset) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.tension = try values.decodeOptional(TensionChoice.self, forKey: .tension) 
        self.text = try values.decodeOptional(TextChoice.self, forKey: .text) 
        self.theta = try values.decodeOptional(ThetaChoice.self, forKey: .theta) 
        self.theta2 = try values.decodeOptional(Theta2Choice.self, forKey: .theta2) 
        self.thickness = try values.decodeOptional(Double.self, forKey: .thickness) 
        self.timeUnitBandPosition = try values.decodeOptional(Double.self, forKey: .timeUnitBandPosition) 
        self.timeUnitBandSize = try values.decodeOptional(Double.self, forKey: .timeUnitBandSize) 
        self.tooltip = try values.decodeOptional(TooltipChoice.self, forKey: .tooltip) 
        self.url = try values.decodeOptional(UrlChoice.self, forKey: .url) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
        self.x = try values.decodeOptional(XChoice.self, forKey: .x) 
        self.x2 = try values.decodeOptional(X2Choice.self, forKey: .x2) 
        self.y = try values.decodeOptional(YChoice.self, forKey: .y) 
        self.y2 = try values.decodeOptional(Y2Choice.self, forKey: .y2) 
    }

    /// The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `"left"`, `"right"`, `"center"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<Align>.Or<ExprRef>

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaRoleDescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias AspectChoice = OneOf<Bool>.Or<ExprRef>

    /// For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.
    /// For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`, `"bottom"`.
    /// __Note:__ Expression reference is *not* supported for range marks.
    /// Generated by Curio
    public typealias BaselineChoice = OneOf<TextBaseline>.Or<ExprRef>

    /// Generated by Curio
    public typealias BlendChoice = OneOf<Blend>.Or<ExprRef>

    /// Default color.
    /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
    /// __Note:__
    /// - This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
    /// - The `fill` and `stroke` properties have higher precedence than `color` and will override `color`.
    /// Generated by Curio
    public typealias ColorChoice = OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusBottomRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopLeftChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CornerRadiusTopRightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias CursorChoice = OneOf<Cursor>.Or<ExprRef>

    /// Generated by Curio
    public typealias DescriptionChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias DirChoice = OneOf<TextDirection>.Or<ExprRef>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias EllipsisChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias EndAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias HrefChoice = OneOf<URI>.Or<ExprRef>

    /// The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
    /// Generated by Curio
    public typealias InnerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias InterpolateChoice = OneOf<Interpolate>.Or<ExprRef>

    /// Generated by Curio
    public typealias Invalid = Nullable<String>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineBreakChoice = OneOf<String>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias Order = Nullable<Bool>

    /// The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
    /// Generated by Curio
    public typealias OuterRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias PadAngleChoice = OneOf<Double>.Or<ExprRef>

    /// The secondary (inner) radius in pixels of arc marks.
    /// Generated by Curio
    public typealias Radius2Choice = OneOf<Double>.Or<ExprRef>

    /// For arc mark, the primary (outer) radius in pixels.
    /// For text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties.
    /// Generated by Curio
    public typealias RadiusChoice = OneOf<Double>.Or<ExprRef>

    /// Default size for marks.
    /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.
    /// - For `bar`, this represents the band size of the bar, in pixels.
    /// - For `text`, this represents the font size, in pixels.
    /// __Default value:__
    /// - `30` for point, circle, square marks; width/height's `step`
    /// - `2` for bar marks with discrete dimensions;
    /// - `5` for bar marks with continuous dimensions;
    /// - `11` for text marks.
    /// Generated by Curio
    public typealias SizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SmoothChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias StartAngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.
    /// __Default value:__ (None)
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ColorGradient>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TensionChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    /// The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.
    /// Generated by Curio
    public typealias Theta2Choice = OneOf<Double>.Or<ExprRef>

    /// - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)
    /// - For text marks, polar coordinate angle in radians.
    /// Generated by Curio
    public typealias ThetaChoice = OneOf<Double>.Or<ExprRef>

    /// The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.
    /// - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding` will be used.
    /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted data point will be used.
    /// - If set to `null` or `false`, then no tooltip will be used.
    /// See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.
    /// __Default value:__ `null`
    /// Generated by Curio
    public typealias TooltipChoice = Nullable<OneOf<Double>.Or<String>.Or<Bool>.Or<TooltipContent>.Or<ExprRef>>

    /// Generated by Curio
    public typealias UrlChoice = OneOf<URI>.Or<ExprRef>

    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<ExprRef>

    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias X2Choice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified `x2` or `width`.
    /// The `value` of this channel can be a number or a string `"width"` for the width of the plot.
    /// Generated by Curio
    public typealias XChoice = OneOf<Double>.Or<LiteralWidth>.Or<ExprRef>

    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias Y2Choice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified `y2` or `height`.
    /// The `value` of this channel can be a number or a string `"height"` for the height of the plot.
    /// Generated by Curio
    public typealias YChoice = OneOf<Double>.Or<LiteralHeight>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case angle
        case aria
        case ariaRole
        case ariaRoleDescription
        case aspect
        case bandSize
        case baseline
        case blend
        case color
        case cornerRadius
        case cornerRadiusBottomLeft
        case cornerRadiusBottomRight
        case cornerRadiusTopLeft
        case cornerRadiusTopRight
        case cursor
        case description
        case dir
        case dx
        case dy
        case ellipsis
        case endAngle
        case fill
        case fillOpacity
        case filled
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case height
        case href
        case innerRadius
        case interpolate
        case invalid
        case limit
        case lineBreak
        case lineHeight
        case opacity
        case order
        case orient
        case outerRadius
        case padAngle
        case radius
        case radius2
        case shape
        case size
        case smooth
        case startAngle
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOffset
        case strokeOpacity
        case strokeWidth
        case tension
        case text
        case theta
        case theta2
        case thickness
        case timeUnitBandPosition
        case timeUnitBandSize
        case tooltip
        case url
        case width
        case x
        case x2
        case y
        case y2
        public var keyDescription: String? {
            switch self {
            case .align: return "The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One of `\"left\"`, `\"right\"`, `\"center\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .angle: return nil
            case .aria: return nil
            case .ariaRole: return nil
            case .ariaRoleDescription: return nil
            case .aspect: return nil
            case .bandSize: return "The width of the ticks.\n\n__Default value:__  3/4 of step (width step for horizontal ticks and height step for vertical ticks)."
            case .baseline: return "For text marks, the vertical text baseline. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, `\"line-bottom\"`, or an expression reference that provides one of the valid values. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the `lineHeight` rather than `fontSize` alone.\n\nFor range marks, the vertical alignment of the marks. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Note:__ Expression reference is *not* supported for range marks."
            case .blend: return nil
            case .color: return "Default color.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__\n- This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n- The `fill` and `stroke` properties have higher precedence than `color` and will override `color`."
            case .cornerRadius: return nil
            case .cornerRadiusBottomLeft: return nil
            case .cornerRadiusBottomRight: return nil
            case .cornerRadiusTopLeft: return nil
            case .cornerRadiusTopRight: return nil
            case .cursor: return nil
            case .description: return nil
            case .dir: return nil
            case .dx: return nil
            case .dy: return nil
            case .ellipsis: return nil
            case .endAngle: return nil
            case .fill: return "Default fill color. This property has higher precedence than `config.color`. Set to `null` to remove fill.\n\n__Default value:__ (None)"
            case .fillOpacity: return nil
            case .filled: return "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `false` for all `point`, `line`, and `rule` marks as well as `geoshape` marks for [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources; otherwise, `true`.\n\n__Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config)."
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .height: return nil
            case .href: return nil
            case .innerRadius: return "The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`."
            case .interpolate: return nil
            case .invalid: return "Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes."
            case .limit: return nil
            case .lineBreak: return nil
            case .lineHeight: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .order: return "For line and trail marks, this `order` property can be set to `null` or `false` to make the lines use the original order in the data sources."
            case .orient: return "The orientation of a non-stacked bar, tick, area, and line charts. The value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick should be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line and trail marks, this property determines the sort order of the points in the line if `config.sortLineBy` is not specified. For stacked charts, this is always determined by the orientation of the stack; therefore explicitly specified value will be ignored."
            case .outerRadius: return "The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`."
            case .padAngle: return nil
            case .radius: return "For arc mark, the primary (outer) radius in pixels.\n\nFor text marks, polar coordinate radial offset, in pixels, of the text from the origin determined by the `x` and `y` properties."
            case .radius2: return "The secondary (inner) radius in pixels of arc marks."
            case .shape: return nil
            case .size: return "Default size for marks.\n- For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that this value sets the area of the symbol; the side lengths will increase with the square root of this value.\n- For `bar`, this represents the band size of the bar, in pixels.\n- For `text`, this represents the font size, in pixels.\n\n__Default value:__\n- `30` for point, circle, square marks; width/height's `step`\n- `2` for bar marks with discrete dimensions;\n- `5` for bar marks with continuous dimensions;\n- `11` for text marks."
            case .smooth: return nil
            case .startAngle: return nil
            case .stroke: return "Default stroke color. This property has higher precedence than `config.color`. Set to `null` to remove stroke.\n\n__Default value:__ (None)"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOffset: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .tension: return nil
            case .text: return nil
            case .theta: return "- For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n\n- For text marks, polar coordinate angle in radians."
            case .theta2: return "The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise."
            case .thickness: return "Thickness of the tick mark.\n\n__Default value:__  `1`"
            case .timeUnitBandPosition: return "Default relative band position for a time unit. If set to `0`, the marks will be positioned at the beginning of the time unit band step. If set to `0.5`, the marks will be positioned in the middle of the time unit band step."
            case .timeUnitBandSize: return "Default relative band size for a time unit. If set to `1`, the bandwidth of the marks will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be half of the time unit band step."
            case .tooltip: return "The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n\n- If `tooltip` is `true` or `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n- If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n- If set to `null` or `false`, then no tooltip will be used.\n\nSee the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip  in Vega-Lite.\n\n__Default value:__ `null`"
            case .url: return nil
            case .width: return nil
            case .x: return "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .x2: return "X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"width\"` for the width of the plot."
            case .y: return "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
            case .y2: return "Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n\nThe `value` of this channel can be a number or a string `\"height\"` for the height of the plot."
             } 
        }

        public typealias CodingOwner = TickConfig
    }
}

public struct TickCount : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Double>.Or<TemporalUnit>.Or<TimeIntervalStep>

    public init(rawValue: OneOf<Double>.Or<TemporalUnit>.Or<TimeIntervalStep>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Double>.Or<TemporalUnit>.Or<TimeIntervalStep>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct TimeIntervalStep : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var interval: TemporalUnit
    public var step: Double
    public static let codingKeyPaths = (\Self.interval as KeyPath, \Self.step as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.interval as KeyPath : CodingKeys.interval, \Self.step as KeyPath : CodingKeys.step]

    public init(interval: TemporalUnit, step: Double) {
        self.interval = interval 
        self.step = step 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.interval = try values.decode(TemporalUnit.self, forKey: .interval) 
        self.step = try values.decode(Double.self, forKey: .step) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case interval
        case step
        public var keyDescription: String? {
            switch self {
            case .interval: return nil
            case .step: return nil
             } 
        }

        public typealias CodingOwner = TimeIntervalStep
    }
}

/// Locale definition for formatting dates and times.
/// Generated by Curio
public struct TimeLocale : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The date (%x) format specifier (e.g., "%m/%d/%Y").
    public var date: String
    /// The date and time (%c) format specifier (e.g., "%a %b %e %X %Y").
    public var dateTime: String
    /// The full names of the weekdays, starting with Sunday.
    public var days: Vector7String
    /// The full names of the months (starting with January).
    public var months: Vector12String
    /// The A.M. and P.M. equivalents (e.g., ["AM", "PM"]).
    public var periods: Vector2String
    /// The abbreviated names of the weekdays, starting with Sunday.
    public var shortDays: Vector7String
    /// The abbreviated names of the months (starting with January).
    public var shortMonths: Vector12String
    /// The time (%X) format specifier (e.g., "%H:%M:%S").
    public var time: String
    public static let codingKeyPaths = (\Self.date as KeyPath, \Self.dateTime as KeyPath, \Self.days as KeyPath, \Self.months as KeyPath, \Self.periods as KeyPath, \Self.shortDays as KeyPath, \Self.shortMonths as KeyPath, \Self.time as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.date as KeyPath : CodingKeys.date, \Self.dateTime as KeyPath : CodingKeys.dateTime, \Self.days as KeyPath : CodingKeys.days, \Self.months as KeyPath : CodingKeys.months, \Self.periods as KeyPath : CodingKeys.periods, \Self.shortDays as KeyPath : CodingKeys.shortDays, \Self.shortMonths as KeyPath : CodingKeys.shortMonths, \Self.time as KeyPath : CodingKeys.time]

    public init(date: String, dateTime: String, days: Vector7String, months: Vector12String, periods: Vector2String, shortDays: Vector7String, shortMonths: Vector12String, time: String) {
        self.date = date 
        self.dateTime = dateTime 
        self.days = days 
        self.months = months 
        self.periods = periods 
        self.shortDays = shortDays 
        self.shortMonths = shortMonths 
        self.time = time 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.date = try values.decode(String.self, forKey: .date) 
        self.dateTime = try values.decode(String.self, forKey: .dateTime) 
        self.days = try values.decode(Vector7String.self, forKey: .days) 
        self.months = try values.decode(Vector12String.self, forKey: .months) 
        self.periods = try values.decode(Vector2String.self, forKey: .periods) 
        self.shortDays = try values.decode(Vector7String.self, forKey: .shortDays) 
        self.shortMonths = try values.decode(Vector12String.self, forKey: .shortMonths) 
        self.time = try values.decode(String.self, forKey: .time) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case date
        case dateTime
        case days
        case months
        case periods
        case shortDays
        case shortMonths
        case time
        public var keyDescription: String? {
            switch self {
            case .date: return "The date (%x) format specifier (e.g., \"%m/%d/%Y\")."
            case .dateTime: return "The date and time (%c) format specifier (e.g., \"%a %b %e %X %Y\")."
            case .days: return "The full names of the weekdays, starting with Sunday."
            case .months: return "The full names of the months (starting with January)."
            case .periods: return "The A.M. and P.M. equivalents (e.g., [\"AM\", \"PM\"])."
            case .shortDays: return "The abbreviated names of the weekdays, starting with Sunday."
            case .shortMonths: return "The abbreviated names of the months (starting with January)."
            case .time: return "The time (%X) format specifier (e.g., \"%H:%M:%S\")."
             } 
        }

        public typealias CodingOwner = TimeLocale
    }
}

public struct TimeUnit : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<SingleTimeUnit>.Or<MultiTimeUnit>

    public init(rawValue: OneOf<SingleTimeUnit>.Or<MultiTimeUnit>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<SingleTimeUnit>.Or<MultiTimeUnit>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct TimeUnitParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// If no `unit` is specified, maxbins is used to infer time units.
    public var maxbins: Double?
    /// The number of steps between bins, in terms of the least significant unit provided.
    public var step: Double?
    /// Defines how date-time values should be binned.
    public var unit: TimeUnit?
    /// True to use UTC timezone. Equivalent to using a `utc` prefixed `TimeUnit`.
    public var utc: Bool?
    public static let codingKeyPaths = (\Self.maxbins as KeyPath, \Self.step as KeyPath, \Self.unit as KeyPath, \Self.utc as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.maxbins as KeyPath : CodingKeys.maxbins, \Self.step as KeyPath : CodingKeys.step, \Self.unit as KeyPath : CodingKeys.unit, \Self.utc as KeyPath : CodingKeys.utc]

    public init(maxbins: Double? = nil, step: Double? = nil, unit: TimeUnit? = nil, utc: Bool? = nil) {
        self.maxbins = maxbins 
        self.step = step 
        self.unit = unit 
        self.utc = utc 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.maxbins = try values.decodeOptional(Double.self, forKey: .maxbins) 
        self.step = try values.decodeOptional(Double.self, forKey: .step) 
        self.unit = try values.decodeOptional(TimeUnit.self, forKey: .unit) 
        self.utc = try values.decodeOptional(Bool.self, forKey: .utc) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case maxbins
        case step
        case unit
        case utc
        public var keyDescription: String? {
            switch self {
            case .maxbins: return "If no `unit` is specified, maxbins is used to infer time units."
            case .step: return "The number of steps between bins, in terms of the least significant unit provided."
            case .unit: return "Defines how date-time values should be binned."
            case .utc: return "True to use UTC timezone. Equivalent to using a `utc` prefixed `TimeUnit`."
             } 
        }

        public typealias CodingOwner = TimeUnitParams
    }
}

/// Generated by Curio
public struct TimeUnitTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// The output field to write the timeUnit value.
    public var `as`: FieldName
    /// The data field to apply time unit.
    public var field: FieldName
    /// The timeUnit.
    public var timeUnit: TimeUnitChoice
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.`as` as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.`as` as KeyPath : CodingKeys.`as`, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit]

    public init(id: TransformId? = nil, `as`: FieldName, field: FieldName, timeUnit: TimeUnitChoice) {
        self.id = id 
        self.`as` = `as` 
        self.field = field 
        self.timeUnit = timeUnit 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.`as` = try values.decode(FieldName.self, forKey: .`as`) 
        self.field = try values.decode(FieldName.self, forKey: .field) 
        self.timeUnit = try values.decode(TimeUnitChoice.self, forKey: .timeUnit) 
    }

    /// The timeUnit.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case `as`
        case field
        case timeUnit
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .`as`: return "The output field to write the timeUnit value."
            case .field: return "The data field to apply time unit."
            case .timeUnit: return "The timeUnit."
             } 
        }

        public typealias CodingOwner = TimeUnitTransform
    }
}

/// Generated by Curio
public struct TitleParams : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Horizontal text alignment for title text. One of `"left"`, `"center"`, or `"right"`.
    public var align: Align?
    /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.
    /// __Default value:__ `"middle"` for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views. `"start"` for other composite views.
    /// __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views. For other composite views, `anchor` is always `"start"`.
    public var anchor: TitleAnchor?
    public var angle: AngleChoice?
    public var aria: AriaChoice?
    /// Vertical text baseline for title and subtitle text. One of `"alphabetic"` (default), `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated relative to the *lineHeight* rather than *fontSize* alone.
    public var baseline: TextBaseline?
    public var color: ColorChoice?
    public var dx: DxChoice?
    public var dy: DyChoice?
    public var font: FontName?
    public var fontSize: FontSizeChoice?
    public var fontStyle: FontStyleChoice?
    public var fontWeight: FontWeightChoice?
    public var frame: FrameChoice?
    public var limit: LimitChoice?
    public var lineHeight: LineHeightChoice?
    public var offset: OffsetChoice?
    public var orient: OrientChoice?
    /// A [mark style property](https://vega.github.io/vega-lite/docs/config.html#style) to apply to the title text mark.
    /// __Default value:__ `"group-title"`.
    public var style: StyleChoice?
    /// The subtitle Text.
    public var subtitle: StringList?
    public var subtitleColor: SubtitleColorChoice?
    public var subtitleFont: FontName?
    public var subtitleFontSize: SubtitleFontSizeChoice?
    public var subtitleFontStyle: SubtitleFontStyleChoice?
    public var subtitleFontWeight: SubtitleFontWeightChoice?
    public var subtitleLineHeight: SubtitleLineHeightChoice?
    public var subtitlePadding: SubtitlePaddingChoice?
    /// The title text.
    public var text: TextChoice
    /// The integer z-index indicating the layering of the title group relative to other axis, mark and legend groups.
    /// __Default value:__ `0`.
    public var zindex: Double?
    public static let codingKeyPaths = (\Self.align as KeyPath, \Self.anchor as KeyPath, \Self.angle as KeyPath, \Self.aria as KeyPath, \Self.baseline as KeyPath, \Self.color as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.frame as KeyPath, \Self.limit as KeyPath, \Self.lineHeight as KeyPath, \Self.offset as KeyPath, \Self.orient as KeyPath, \Self.style as KeyPath, \Self.subtitle as KeyPath, \Self.subtitleColor as KeyPath, \Self.subtitleFont as KeyPath, \Self.subtitleFontSize as KeyPath, \Self.subtitleFontStyle as KeyPath, \Self.subtitleFontWeight as KeyPath, \Self.subtitleLineHeight as KeyPath, \Self.subtitlePadding as KeyPath, \Self.text as KeyPath, \Self.zindex as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.align as KeyPath : CodingKeys.align, \Self.anchor as KeyPath : CodingKeys.anchor, \Self.angle as KeyPath : CodingKeys.angle, \Self.aria as KeyPath : CodingKeys.aria, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.color as KeyPath : CodingKeys.color, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.frame as KeyPath : CodingKeys.frame, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.offset as KeyPath : CodingKeys.offset, \Self.orient as KeyPath : CodingKeys.orient, \Self.style as KeyPath : CodingKeys.style, \Self.subtitle as KeyPath : CodingKeys.subtitle, \Self.subtitleColor as KeyPath : CodingKeys.subtitleColor, \Self.subtitleFont as KeyPath : CodingKeys.subtitleFont, \Self.subtitleFontSize as KeyPath : CodingKeys.subtitleFontSize, \Self.subtitleFontStyle as KeyPath : CodingKeys.subtitleFontStyle, \Self.subtitleFontWeight as KeyPath : CodingKeys.subtitleFontWeight, \Self.subtitleLineHeight as KeyPath : CodingKeys.subtitleLineHeight, \Self.subtitlePadding as KeyPath : CodingKeys.subtitlePadding, \Self.text as KeyPath : CodingKeys.text, \Self.zindex as KeyPath : CodingKeys.zindex]

    public init(align: Align? = nil, anchor: TitleAnchor? = nil, angle: AngleChoice? = nil, aria: AriaChoice? = nil, baseline: TextBaseline? = nil, color: ColorChoice? = nil, dx: DxChoice? = nil, dy: DyChoice? = nil, font: FontName? = nil, fontSize: FontSizeChoice? = nil, fontStyle: FontStyleChoice? = nil, fontWeight: FontWeightChoice? = nil, frame: FrameChoice? = nil, limit: LimitChoice? = nil, lineHeight: LineHeightChoice? = nil, offset: OffsetChoice? = nil, orient: OrientChoice? = nil, style: StyleChoice? = nil, subtitle: StringList? = nil, subtitleColor: SubtitleColorChoice? = nil, subtitleFont: FontName? = nil, subtitleFontSize: SubtitleFontSizeChoice? = nil, subtitleFontStyle: SubtitleFontStyleChoice? = nil, subtitleFontWeight: SubtitleFontWeightChoice? = nil, subtitleLineHeight: SubtitleLineHeightChoice? = nil, subtitlePadding: SubtitlePaddingChoice? = nil, text: TextChoice, zindex: Double? = nil) {
        self.align = align 
        self.anchor = anchor 
        self.angle = angle 
        self.aria = aria 
        self.baseline = baseline 
        self.color = color 
        self.dx = dx 
        self.dy = dy 
        self.font = font 
        self.fontSize = fontSize 
        self.fontStyle = fontStyle 
        self.fontWeight = fontWeight 
        self.frame = frame 
        self.limit = limit 
        self.lineHeight = lineHeight 
        self.offset = offset 
        self.orient = orient 
        self.style = style 
        self.subtitle = subtitle 
        self.subtitleColor = subtitleColor 
        self.subtitleFont = subtitleFont 
        self.subtitleFontSize = subtitleFontSize 
        self.subtitleFontStyle = subtitleFontStyle 
        self.subtitleFontWeight = subtitleFontWeight 
        self.subtitleLineHeight = subtitleLineHeight 
        self.subtitlePadding = subtitlePadding 
        self.text = text 
        self.zindex = zindex 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.align = try values.decodeOptional(Align.self, forKey: .align) 
        self.anchor = try values.decodeOptional(TitleAnchor.self, forKey: .anchor) 
        self.angle = try values.decodeOptional(AngleChoice.self, forKey: .angle) 
        self.aria = try values.decodeOptional(AriaChoice.self, forKey: .aria) 
        self.baseline = try values.decodeOptional(TextBaseline.self, forKey: .baseline) 
        self.color = try values.decodeOptional(ColorChoice.self, forKey: .color) 
        self.dx = try values.decodeOptional(DxChoice.self, forKey: .dx) 
        self.dy = try values.decodeOptional(DyChoice.self, forKey: .dy) 
        self.font = try values.decodeOptional(FontName.self, forKey: .font) 
        self.fontSize = try values.decodeOptional(FontSizeChoice.self, forKey: .fontSize) 
        self.fontStyle = try values.decodeOptional(FontStyleChoice.self, forKey: .fontStyle) 
        self.fontWeight = try values.decodeOptional(FontWeightChoice.self, forKey: .fontWeight) 
        self.frame = try values.decodeOptional(FrameChoice.self, forKey: .frame) 
        self.limit = try values.decodeOptional(LimitChoice.self, forKey: .limit) 
        self.lineHeight = try values.decodeOptional(LineHeightChoice.self, forKey: .lineHeight) 
        self.offset = try values.decodeOptional(OffsetChoice.self, forKey: .offset) 
        self.orient = try values.decodeOptional(OrientChoice.self, forKey: .orient) 
        self.style = try values.decodeOptional(StyleChoice.self, forKey: .style) 
        self.subtitle = try values.decodeOptional(StringList.self, forKey: .subtitle) 
        self.subtitleColor = try values.decodeOptional(SubtitleColorChoice.self, forKey: .subtitleColor) 
        self.subtitleFont = try values.decodeOptional(FontName.self, forKey: .subtitleFont) 
        self.subtitleFontSize = try values.decodeOptional(SubtitleFontSizeChoice.self, forKey: .subtitleFontSize) 
        self.subtitleFontStyle = try values.decodeOptional(SubtitleFontStyleChoice.self, forKey: .subtitleFontStyle) 
        self.subtitleFontWeight = try values.decodeOptional(SubtitleFontWeightChoice.self, forKey: .subtitleFontWeight) 
        self.subtitleLineHeight = try values.decodeOptional(SubtitleLineHeightChoice.self, forKey: .subtitleLineHeight) 
        self.subtitlePadding = try values.decodeOptional(SubtitlePaddingChoice.self, forKey: .subtitlePadding) 
        self.text = try values.decode(TextChoice.self, forKey: .text) 
        self.zindex = try values.decodeOptional(Double.self, forKey: .zindex) 
    }

    /// Generated by Curio
    public typealias AngleChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias AriaChoice = OneOf<Bool>.Or<ExprRef>

    /// Generated by Curio
    public typealias ColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias DxChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias DyChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias FontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias FrameChoice = OneOf<OneOf<TitleFrame>.Or<String>>.Or<ExprRef>

    /// Generated by Curio
    public typealias LimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias LineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias OffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias OrientChoice = OneOf<TitleOrient>.Or<ExprRef>

    /// A [mark style property](https://vega.github.io/vega-lite/docs/config.html#style) to apply to the title text mark.
    /// __Default value:__ `"group-title"`.
    /// Generated by Curio
    public typealias StyleChoice = OneOrMany<String>

    /// Generated by Curio
    public typealias SubtitleColorChoice = OneOf<Nullable<ColorLiteral>>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleFontSizeChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleFontStyleChoice = OneOf<FontStyle>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleFontWeightChoice = OneOf<FontWeight>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitleLineHeightChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias SubtitlePaddingChoice = OneOf<Double>.Or<ExprRef>

    /// The title text.
    /// Generated by Curio
    public typealias TextChoice = OneOf<StringList>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case align
        case anchor
        case angle
        case aria
        case baseline
        case color
        case dx
        case dy
        case font
        case fontSize
        case fontStyle
        case fontWeight
        case frame
        case limit
        case lineHeight
        case offset
        case orient
        case style
        case subtitle
        case subtitleColor
        case subtitleFont
        case subtitleFontSize
        case subtitleFontStyle
        case subtitleFontWeight
        case subtitleLineHeight
        case subtitlePadding
        case text
        case zindex
        public var keyDescription: String? {
            switch self {
            case .align: return "Horizontal text alignment for title text. One of `\"left\"`, `\"center\"`, or `\"right\"`."
            case .anchor: return "The anchor position for placing the title. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.\n\n__Default value:__ `\"middle\"` for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views. `\"start\"` for other composite views.\n\n__Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views. For other composite views, `anchor` is always `\"start\"`."
            case .angle: return nil
            case .aria: return nil
            case .baseline: return "Vertical text baseline for title and subtitle text. One of `\"alphabetic\"` (default), `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"line-top\"`, or `\"line-bottom\"`. The `\"line-top\"` and `\"line-bottom\"` values operate similarly to `\"top\"` and `\"bottom\"`, but are calculated relative to the *lineHeight* rather than *fontSize* alone."
            case .color: return nil
            case .dx: return nil
            case .dy: return nil
            case .font: return nil
            case .fontSize: return nil
            case .fontStyle: return nil
            case .fontWeight: return nil
            case .frame: return nil
            case .limit: return nil
            case .lineHeight: return nil
            case .offset: return nil
            case .orient: return nil
            case .style: return "A [mark style property](https://vega.github.io/vega-lite/docs/config.html#style) to apply to the title text mark.\n\n__Default value:__ `\"group-title\"`."
            case .subtitle: return "The subtitle Text."
            case .subtitleColor: return nil
            case .subtitleFont: return nil
            case .subtitleFontSize: return nil
            case .subtitleFontStyle: return nil
            case .subtitleFontWeight: return nil
            case .subtitleLineHeight: return nil
            case .subtitlePadding: return nil
            case .text: return "The title text."
            case .zindex: return "The integer z-index indicating the layering of the title group relative to other axis, mark and legend groups.\n\n__Default value:__ `0`."
             } 
        }

        public typealias CodingOwner = TitleParams
    }
}

/// Generated by Curio
public struct TooltipContent : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var content: LiteralEncodingOrData
    public static let codingKeyPaths = (\Self.content as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.content as KeyPath : CodingKeys.content]

    public init(content: LiteralEncodingOrData) {
        self.content = content 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.content = try values.decode(LiteralEncodingOrData.self, forKey: .content) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case content
        public var keyDescription: String? {
            switch self {
            case .content: return nil
             } 
        }

        public typealias CodingOwner = TooltipContent
    }

    /// Generated by Curio
    public enum LiteralEncodingOrData : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case encoding
        case data
    }
}

/// Generated by Curio
public struct TopLevelConcatSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
    public var schema: String?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    public var autosize: AutosizeChoice?
    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    public var background: BackgroundChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// The number of columns to include in the view composition layout.
    /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
    /// __Note__:
    /// 1) This property is only for:
    /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
    /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
    /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
    public var columns: Double?
    /// A list of views to be concatenated.
    public var concat: [NonNormalizedSpec]
    /// Vega-Lite configuration object. This property can only be defined at the top-level of a specification.
    public var config: ConfigTheme?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.
    public var datasets: Datasets?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// Name of the visualization for later reference.
    public var name: String?
    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    public var padding: PaddingChoice?
    /// Dynamic variables or selections that parameterize a visualization.
    public var params: [ParamsItemChoice]?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.
    public var usermeta: Dict?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.schema as KeyPath, \Self.align as KeyPath, \Self.autosize as KeyPath, \Self.background as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.concat as KeyPath, \Self.config as KeyPath, \Self.data as KeyPath, \Self.datasets as KeyPath, \Self.description as KeyPath, \Self.name as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.usermeta as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.schema as KeyPath : CodingKeys.schema, \Self.align as KeyPath : CodingKeys.align, \Self.autosize as KeyPath : CodingKeys.autosize, \Self.background as KeyPath : CodingKeys.background, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.concat as KeyPath : CodingKeys.concat, \Self.config as KeyPath : CodingKeys.config, \Self.data as KeyPath : CodingKeys.data, \Self.datasets as KeyPath : CodingKeys.datasets, \Self.description as KeyPath : CodingKeys.description, \Self.name as KeyPath : CodingKeys.name, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.usermeta as KeyPath : CodingKeys.usermeta]

    public init(id: LayerId? = nil, schema: String? = nil, align: AlignChoice? = nil, autosize: AutosizeChoice? = nil, background: BackgroundChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, concat: [NonNormalizedSpec] = [], config: ConfigTheme? = nil, data: DataChoice? = nil, datasets: Datasets? = nil, description: String? = nil, name: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, usermeta: Dict? = nil) {
        self.id = id 
        self.schema = schema 
        self.align = align 
        self.autosize = autosize 
        self.background = background 
        self.bounds = bounds 
        self.center = center 
        self.columns = columns 
        self.concat = concat 
        self.config = config 
        self.data = data 
        self.datasets = datasets 
        self.description = description 
        self.name = name 
        self.padding = padding 
        self.params = params 
        self.resolve = resolve 
        self.spacing = spacing 
        self.title = title 
        self.transform = transform 
        self.usermeta = usermeta 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.schema = try values.decodeOptional(String.self, forKey: .schema) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
        self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
        self.concat = try values.decode([NonNormalizedSpec].self, forKey: .concat) 
        self.config = try values.decodeOptional(ConfigTheme.self, forKey: .config) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.datasets = try values.decodeOptional(Datasets.self, forKey: .datasets) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.usermeta = try values.decodeOptional(Dict.self, forKey: .usermeta) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    /// Generated by Curio
    public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    /// Generated by Curio
    public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<TopLevelSelectionParameter>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case schema = "$schema"
        case align
        case autosize
        case background
        case bounds
        case center
        case columns
        case concat
        case config
        case data
        case datasets
        case description
        case name
        case padding
        case params
        case resolve
        case spacing
        case title
        case transform
        case usermeta
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .schema: return "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema."
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
            case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
            case .concat: return "A list of views to be concatenated."
            case .config: return "Vega-Lite configuration object. This property can only be defined at the top-level of a specification."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .datasets: return "A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property."
            case .description: return "Description of this mark for commenting purpose."
            case .name: return "Name of the visualization for later reference."
            case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
            case .params: return "Dynamic variables or selections that parameterize a visualization."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .usermeta: return "Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata."
             } 
        }

        public typealias CodingOwner = TopLevelConcatSpec
    }
}

/// Generated by Curio
public struct TopLevelFacetSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
    public var schema: String?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    public var autosize: AutosizeChoice?
    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    public var background: BackgroundChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// The number of columns to include in the view composition layout.
    /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
    /// __Note__:
    /// 1) This property is only for:
    /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
    /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
    /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
    public var columns: Double?
    /// Vega-Lite configuration object. This property can only be defined at the top-level of a specification.
    public var config: ConfigTheme?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice
    /// A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.
    public var datasets: Datasets?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// Definition for how to facet the data. One of: 1) [a field definition for faceting the plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An object that maps `row` and `column` channels to their field definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
    public var facet: FacetChoice
    /// Name of the visualization for later reference.
    public var name: String?
    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    public var padding: PaddingChoice?
    /// Dynamic variables or selections that parameterize a visualization.
    public var params: [ParamsItemChoice]?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// A specification of the view that gets faceted.
    public var spec: SpecChoice
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.
    public var usermeta: Dict?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.schema as KeyPath, \Self.align as KeyPath, \Self.autosize as KeyPath, \Self.background as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.config as KeyPath, \Self.data as KeyPath, \Self.datasets as KeyPath, \Self.description as KeyPath, \Self.facet as KeyPath, \Self.name as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.spec as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.usermeta as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.schema as KeyPath : CodingKeys.schema, \Self.align as KeyPath : CodingKeys.align, \Self.autosize as KeyPath : CodingKeys.autosize, \Self.background as KeyPath : CodingKeys.background, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.config as KeyPath : CodingKeys.config, \Self.data as KeyPath : CodingKeys.data, \Self.datasets as KeyPath : CodingKeys.datasets, \Self.description as KeyPath : CodingKeys.description, \Self.facet as KeyPath : CodingKeys.facet, \Self.name as KeyPath : CodingKeys.name, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.spec as KeyPath : CodingKeys.spec, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.usermeta as KeyPath : CodingKeys.usermeta]

    public init(id: LayerId? = nil, schema: String? = nil, align: AlignChoice? = nil, autosize: AutosizeChoice? = nil, background: BackgroundChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, config: ConfigTheme? = nil, data: DataChoice, datasets: Datasets? = nil, description: String? = nil, facet: FacetChoice, name: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, spec: SpecChoice, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, usermeta: Dict? = nil) {
        self.id = id 
        self.schema = schema 
        self.align = align 
        self.autosize = autosize 
        self.background = background 
        self.bounds = bounds 
        self.center = center 
        self.columns = columns 
        self.config = config 
        self.data = data 
        self.datasets = datasets 
        self.description = description 
        self.facet = facet 
        self.name = name 
        self.padding = padding 
        self.params = params 
        self.resolve = resolve 
        self.spacing = spacing 
        self.spec = spec 
        self.title = title 
        self.transform = transform 
        self.usermeta = usermeta 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.schema = try values.decodeOptional(String.self, forKey: .schema) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
        self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
        self.config = try values.decodeOptional(ConfigTheme.self, forKey: .config) 
        self.data = try values.decode(DataChoice.self, forKey: .data) 
        self.datasets = try values.decodeOptional(Datasets.self, forKey: .datasets) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.facet = try values.decode(FacetChoice.self, forKey: .facet) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.spec = try values.decode(SpecChoice.self, forKey: .spec) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.usermeta = try values.decodeOptional(Dict.self, forKey: .usermeta) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    /// Generated by Curio
    public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    /// Generated by Curio
    public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// Definition for how to facet the data. One of: 1) [a field definition for faceting the plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An object that maps `row` and `column` channels to their field definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
    /// Generated by Curio
    public typealias FacetChoice = OneOf<FacetFieldDef>.Or<FacetMapping>

    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<TopLevelSelectionParameter>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// A specification of the view that gets faceted.
    /// Generated by Curio
    public typealias SpecChoice = OneOf<LayerSpec>.Or<UnitSpecWithFrame>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case schema = "$schema"
        case align
        case autosize
        case background
        case bounds
        case center
        case columns
        case config
        case data
        case datasets
        case description
        case facet
        case name
        case padding
        case params
        case resolve
        case spacing
        case spec
        case title
        case transform
        case usermeta
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .schema: return "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema."
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
            case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
            case .config: return "Vega-Lite configuration object. This property can only be defined at the top-level of a specification."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .datasets: return "A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property."
            case .description: return "Description of this mark for commenting purpose."
            case .facet: return "Definition for how to facet the data. One of: 1) [a field definition for faceting the plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An object that maps `row` and `column` channels to their field definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)"
            case .name: return "Name of the visualization for later reference."
            case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
            case .params: return "Dynamic variables or selections that parameterize a visualization."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .spec: return "A specification of the view that gets faceted."
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .usermeta: return "Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata."
             } 
        }

        public typealias CodingOwner = TopLevelFacetSpec
    }
}

/// Generated by Curio
public struct TopLevelHConcatSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
    public var schema: String?
    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    public var autosize: AutosizeChoice?
    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    public var background: BackgroundChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// __Default value:__ `false`
    public var center: Bool?
    /// Vega-Lite configuration object. This property can only be defined at the top-level of a specification.
    public var config: ConfigTheme?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.
    public var datasets: Datasets?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// A list of views to be concatenated and put into a row.
    public var hconcat: [NonNormalizedSpec]
    /// Name of the visualization for later reference.
    public var name: String?
    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    public var padding: PaddingChoice?
    /// Dynamic variables or selections that parameterize a visualization.
    public var params: [ParamsItemChoice]?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the concat operator.
    /// __Default value__: `10`
    public var spacing: Double?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.
    public var usermeta: Dict?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.schema as KeyPath, \Self.autosize as KeyPath, \Self.background as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.config as KeyPath, \Self.data as KeyPath, \Self.datasets as KeyPath, \Self.description as KeyPath, \Self.hconcat as KeyPath, \Self.name as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.usermeta as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.schema as KeyPath : CodingKeys.schema, \Self.autosize as KeyPath : CodingKeys.autosize, \Self.background as KeyPath : CodingKeys.background, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.config as KeyPath : CodingKeys.config, \Self.data as KeyPath : CodingKeys.data, \Self.datasets as KeyPath : CodingKeys.datasets, \Self.description as KeyPath : CodingKeys.description, \Self.hconcat as KeyPath : CodingKeys.hconcat, \Self.name as KeyPath : CodingKeys.name, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.usermeta as KeyPath : CodingKeys.usermeta]

    public init(id: LayerId? = nil, schema: String? = nil, autosize: AutosizeChoice? = nil, background: BackgroundChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: Bool? = nil, config: ConfigTheme? = nil, data: DataChoice? = nil, datasets: Datasets? = nil, description: String? = nil, hconcat: [NonNormalizedSpec] = [], name: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, resolve: Resolve? = nil, spacing: Double? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, usermeta: Dict? = nil) {
        self.id = id 
        self.schema = schema 
        self.autosize = autosize 
        self.background = background 
        self.bounds = bounds 
        self.center = center 
        self.config = config 
        self.data = data 
        self.datasets = datasets 
        self.description = description 
        self.hconcat = hconcat 
        self.name = name 
        self.padding = padding 
        self.params = params 
        self.resolve = resolve 
        self.spacing = spacing 
        self.title = title 
        self.transform = transform 
        self.usermeta = usermeta 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.schema = try values.decodeOptional(String.self, forKey: .schema) 
        self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
        self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(Bool.self, forKey: .center) 
        self.config = try values.decodeOptional(ConfigTheme.self, forKey: .config) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.datasets = try values.decodeOptional(Datasets.self, forKey: .datasets) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.hconcat = try values.decode([NonNormalizedSpec].self, forKey: .hconcat) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(Double.self, forKey: .spacing) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.usermeta = try values.decodeOptional(Dict.self, forKey: .usermeta) 
    }

    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    /// Generated by Curio
    public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    /// Generated by Curio
    public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<TopLevelSelectionParameter>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case schema = "$schema"
        case autosize
        case background
        case bounds
        case center
        case config
        case data
        case datasets
        case description
        case hconcat
        case name
        case padding
        case params
        case resolve
        case spacing
        case title
        case transform
        case usermeta
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .schema: return "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema."
            case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
            case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\n__Default value:__ `false`"
            case .config: return "Vega-Lite configuration object. This property can only be defined at the top-level of a specification."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .datasets: return "A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property."
            case .description: return "Description of this mark for commenting purpose."
            case .hconcat: return "A list of views to be concatenated and put into a row."
            case .name: return "Name of the visualization for later reference."
            case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
            case .params: return "Dynamic variables or selections that parameterize a visualization."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the concat operator.\n\n__Default value__: `10`"
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .usermeta: return "Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata."
             } 
        }

        public typealias CodingOwner = TopLevelHConcatSpec
    }
}

/// Generated by Curio
public struct TopLevelLayerSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
    public var schema: String?
    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    public var autosize: AutosizeChoice?
    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    public var background: BackgroundChoice?
    /// Vega-Lite configuration object. This property can only be defined at the top-level of a specification.
    public var config: ConfigTheme?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.
    public var datasets: Datasets?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// A shared key-value mapping between encoding channels and definition of fields in the underlying layers.
    public var encoding: SharedEncoding?
    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var height: HeightChoice?
    /// Layer or single view specifications to be layered.
    /// __Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed. Instead, use the [facet operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a facet.
    public var layer: [LayerItemChoice]
    /// Name of the visualization for later reference.
    public var name: String?
    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    public var padding: PaddingChoice?
    /// Dynamic variables or selections that parameterize a visualization.
    public var params: [ParamsItemChoice]?
    /// An object defining properties of the geographic projection shared by underlying layers.
    public var projection: Projection?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.
    public var usermeta: Dict?
    /// An object defining the view background's fill and stroke.
    /// __Default value:__ none (transparent)
    public var view: ViewBackground?
    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var width: WidthChoice?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.schema as KeyPath, \Self.autosize as KeyPath, \Self.background as KeyPath, \Self.config as KeyPath, \Self.data as KeyPath, \Self.datasets as KeyPath, \Self.description as KeyPath, \Self.encoding as KeyPath, \Self.height as KeyPath, \Self.layer as KeyPath, \Self.name as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self.projection as KeyPath, \Self.resolve as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.usermeta as KeyPath, \Self.view as KeyPath, \Self.width as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.schema as KeyPath : CodingKeys.schema, \Self.autosize as KeyPath : CodingKeys.autosize, \Self.background as KeyPath : CodingKeys.background, \Self.config as KeyPath : CodingKeys.config, \Self.data as KeyPath : CodingKeys.data, \Self.datasets as KeyPath : CodingKeys.datasets, \Self.description as KeyPath : CodingKeys.description, \Self.encoding as KeyPath : CodingKeys.encoding, \Self.height as KeyPath : CodingKeys.height, \Self.layer as KeyPath : CodingKeys.layer, \Self.name as KeyPath : CodingKeys.name, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self.projection as KeyPath : CodingKeys.projection, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.usermeta as KeyPath : CodingKeys.usermeta, \Self.view as KeyPath : CodingKeys.view, \Self.width as KeyPath : CodingKeys.width]

    public init(id: LayerId? = nil, schema: String? = nil, autosize: AutosizeChoice? = nil, background: BackgroundChoice? = nil, config: ConfigTheme? = nil, data: DataChoice? = nil, datasets: Datasets? = nil, description: String? = nil, encoding: SharedEncoding? = nil, height: HeightChoice? = nil, layer: [LayerItemChoice] = [], name: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, projection: Projection? = nil, resolve: Resolve? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, usermeta: Dict? = nil, view: ViewBackground? = nil, width: WidthChoice? = nil) {
        self.id = id 
        self.schema = schema 
        self.autosize = autosize 
        self.background = background 
        self.config = config 
        self.data = data 
        self.datasets = datasets 
        self.description = description 
        self.encoding = encoding 
        self.height = height 
        self.layer = layer 
        self.name = name 
        self.padding = padding 
        self.params = params 
        self.projection = projection 
        self.resolve = resolve 
        self.title = title 
        self.transform = transform 
        self.usermeta = usermeta 
        self.view = view 
        self.width = width 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.schema = try values.decodeOptional(String.self, forKey: .schema) 
        self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
        self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
        self.config = try values.decodeOptional(ConfigTheme.self, forKey: .config) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.datasets = try values.decodeOptional(Datasets.self, forKey: .datasets) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.encoding = try values.decodeOptional(SharedEncoding.self, forKey: .encoding) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.layer = try values.decode([LayerItemChoice].self, forKey: .layer) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.projection = try values.decodeOptional(Projection.self, forKey: .projection) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.usermeta = try values.decodeOptional(Dict.self, forKey: .usermeta) 
        self.view = try values.decodeOptional(ViewBackground.self, forKey: .view) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
    }

    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    /// Generated by Curio
    public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    /// Generated by Curio
    public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    /// Generated by Curio
    public typealias LayerItemChoice = OneOf<LayerSpec>.Or<UnitSpec>

    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<TopLevelSelectionParameter>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case schema = "$schema"
        case autosize
        case background
        case config
        case data
        case datasets
        case description
        case encoding
        case height
        case layer
        case name
        case padding
        case params
        case projection
        case resolve
        case title
        case transform
        case usermeta
        case view
        case width
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .schema: return "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema."
            case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
            case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
            case .config: return "Vega-Lite configuration object. This property can only be defined at the top-level of a specification."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .datasets: return "A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property."
            case .description: return "Description of this mark for commenting purpose."
            case .encoding: return "A shared key-value mapping between encoding channels and definition of fields in the underlying layers."
            case .height: return "The height of a visualization.\n\n- For a plot with a continuous y-field, height should be a number.\n- For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)\n- To enable responsive sizing on height, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation."
            case .layer: return "Layer or single view specifications to be layered.\n\n__Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed. Instead, use the [facet operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a facet."
            case .name: return "Name of the visualization for later reference."
            case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
            case .params: return "Dynamic variables or selections that parameterize a visualization."
            case .projection: return "An object defining properties of the geographic projection shared by underlying layers."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .usermeta: return "Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata."
            case .view: return "An object defining the view background's fill and stroke.\n\n__Default value:__ none (transparent)"
            case .width: return "The width of a visualization.\n\n- For a plot with a continuous x-field, width should be a number.\n- For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)\n- To enable responsive sizing on width, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation."
             } 
        }

        public typealias CodingOwner = TopLevelLayerSpec
    }
}

public struct TopLevelRepeatSpec : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<Type1>.Or<Type2>

    public init(rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<Type1>.Or<Type2>) {
        self.rawValue = rawValue 
    }

    /// Generated by Curio
    public struct Type1 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
        public var schema: String?
        /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
        /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
        /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
        /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
        /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
        /// __Default value:__ `"all"`.
        public var align: AlignChoice?
        /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
        /// __Default value__: `pad`
        public var autosize: AutosizeChoice?
        /// CSS color property to use as the background of the entire view.
        /// __Default value:__ `"white"`
        public var background: BackgroundChoice?
        /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
        /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
        /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
        /// __Default value:__ `"full"`
        public var bounds: LiteralFullOrFlush?
        /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
        /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
        /// __Default value:__ `false`
        public var center: CenterChoice?
        /// The number of columns to include in the view composition layout.
        /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
        /// __Note__:
        /// 1) This property is only for:
        /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
        /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
        /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
        public var columns: Double?
        /// Vega-Lite configuration object. This property can only be defined at the top-level of a specification.
        public var config: ConfigTheme?
        /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
        public var data: DataChoice?
        /// A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.
        public var datasets: Datasets?
        /// Description of this mark for commenting purpose.
        public var description: String?
        /// Name of the visualization for later reference.
        public var name: String?
        /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
        /// __Default value__: `5`
        public var padding: PaddingChoice?
        /// Dynamic variables or selections that parameterize a visualization.
        public var params: [ParamsItemChoice]?
        /// Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed fields to be repeated along the particular orientations. The objects `{"repeat": "row"}` and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
        public var `repeat`: RepeatChoice
        /// Scale, axis, and legend resolutions for view composition specifications.
        public var resolve: Resolve?
        /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
        /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
        public var spacing: SpacingChoice?
        /// A specification of the view that gets repeated.
        public var spec: NonNormalizedSpec
        /// Title for the plot.
        public var title: TitleChoice?
        /// An array of data transformations such as filter and new field calculation.
        public var transform: [DataTransformation]?
        /// Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.
        public var usermeta: Dict?
        public static let codingKeyPaths = (\Self.schema as KeyPath, \Self.align as KeyPath, \Self.autosize as KeyPath, \Self.background as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.config as KeyPath, \Self.data as KeyPath, \Self.datasets as KeyPath, \Self.description as KeyPath, \Self.name as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self.`repeat` as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.spec as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.usermeta as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.schema as KeyPath : CodingKeys.schema, \Self.align as KeyPath : CodingKeys.align, \Self.autosize as KeyPath : CodingKeys.autosize, \Self.background as KeyPath : CodingKeys.background, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.config as KeyPath : CodingKeys.config, \Self.data as KeyPath : CodingKeys.data, \Self.datasets as KeyPath : CodingKeys.datasets, \Self.description as KeyPath : CodingKeys.description, \Self.name as KeyPath : CodingKeys.name, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self.`repeat` as KeyPath : CodingKeys.`repeat`, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.spec as KeyPath : CodingKeys.spec, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.usermeta as KeyPath : CodingKeys.usermeta]

        public init(schema: String? = nil, align: AlignChoice? = nil, autosize: AutosizeChoice? = nil, background: BackgroundChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, config: ConfigTheme? = nil, data: DataChoice? = nil, datasets: Datasets? = nil, description: String? = nil, name: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, `repeat`: RepeatChoice, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, spec: NonNormalizedSpec, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, usermeta: Dict? = nil) {
            self.schema = schema 
            self.align = align 
            self.autosize = autosize 
            self.background = background 
            self.bounds = bounds 
            self.center = center 
            self.columns = columns 
            self.config = config 
            self.data = data 
            self.datasets = datasets 
            self.description = description 
            self.name = name 
            self.padding = padding 
            self.params = params 
            self.`repeat` = `repeat` 
            self.resolve = resolve 
            self.spacing = spacing 
            self.spec = spec 
            self.title = title 
            self.transform = transform 
            self.usermeta = usermeta 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.schema = try values.decodeOptional(String.self, forKey: .schema) 
            self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
            self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
            self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
            self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
            self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
            self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
            self.config = try values.decodeOptional(ConfigTheme.self, forKey: .config) 
            self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
            self.datasets = try values.decodeOptional(Datasets.self, forKey: .datasets) 
            self.description = try values.decodeOptional(String.self, forKey: .description) 
            self.name = try values.decodeOptional(String.self, forKey: .name) 
            self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
            self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
            self.`repeat` = try values.decode(RepeatChoice.self, forKey: .`repeat`) 
            self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
            self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
            self.spec = try values.decode(NonNormalizedSpec.self, forKey: .spec) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
            self.usermeta = try values.decodeOptional(Dict.self, forKey: .usermeta) 
        }

        /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
        /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
        /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
        /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
        /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
        /// __Default value:__ `"all"`.
        /// Generated by Curio
        public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

        /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
        /// __Default value__: `pad`
        /// Generated by Curio
        public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

        /// CSS color property to use as the background of the entire view.
        /// __Default value:__ `"white"`
        /// Generated by Curio
        public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

        /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
        /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
        /// __Default value:__ `false`
        /// Generated by Curio
        public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

        /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
        /// Generated by Curio
        public typealias DataChoice = Nullable<DataProvider>

        /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
        /// __Default value__: `5`
        /// Generated by Curio
        public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

        /// Generated by Curio
        public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<TopLevelSelectionParameter>

        /// Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed fields to be repeated along the particular orientations. The objects `{"repeat": "row"}` and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
        /// Generated by Curio
        public typealias RepeatChoice = OneOf<[String]>.Or<RepeatMapping>

        /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
        /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
        /// Generated by Curio
        public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

        /// Title for the plot.
        /// Generated by Curio
        public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case schema = "$schema"
            case align
            case autosize
            case background
            case bounds
            case center
            case columns
            case config
            case data
            case datasets
            case description
            case name
            case padding
            case params
            case `repeat`
            case resolve
            case spacing
            case spec
            case title
            case transform
            case usermeta
            public var keyDescription: String? {
                switch self {
                case .schema: return "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema."
                case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
                case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
                case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
                case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
                case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
                case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
                case .config: return "Vega-Lite configuration object. This property can only be defined at the top-level of a specification."
                case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
                case .datasets: return "A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property."
                case .description: return "Description of this mark for commenting purpose."
                case .name: return "Name of the visualization for later reference."
                case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
                case .params: return "Dynamic variables or selections that parameterize a visualization."
                case .`repeat`: return "Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `\"repeat\"` is an array, the field can be referred to as `{\"repeat\": \"repeat\"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `\"row\"` and/or `\"column\"` to the listed fields to be repeated along the particular orientations. The objects `{\"repeat\": \"row\"}` and `{\"repeat\": \"column\"}` can be used to refer to the repeated field respectively."
                case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
                case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
                case .spec: return "A specification of the view that gets repeated."
                case .title: return "Title for the plot."
                case .transform: return "An array of data transformations such as filter and new field calculation."
                case .usermeta: return "Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata."
                 } 
            }

            public typealias CodingOwner = Type1
        }
    }

    /// Generated by Curio
    public struct Type2 : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
        /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
        public var schema: String?
        /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
        /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
        /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
        /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
        /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
        /// __Default value:__ `"all"`.
        public var align: AlignChoice?
        /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
        /// __Default value__: `pad`
        public var autosize: AutosizeChoice?
        /// CSS color property to use as the background of the entire view.
        /// __Default value:__ `"white"`
        public var background: BackgroundChoice?
        /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
        /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
        /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
        /// __Default value:__ `"full"`
        public var bounds: LiteralFullOrFlush?
        /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
        /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
        /// __Default value:__ `false`
        public var center: CenterChoice?
        /// The number of columns to include in the view composition layout.
        /// __Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).
        /// __Note__:
        /// 1) This property is only for:
        /// - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
        /// - the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)
        /// 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`).
        public var columns: Double?
        /// Vega-Lite configuration object. This property can only be defined at the top-level of a specification.
        public var config: ConfigTheme?
        /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
        public var data: DataChoice?
        /// A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.
        public var datasets: Datasets?
        /// Description of this mark for commenting purpose.
        public var description: String?
        /// Name of the visualization for later reference.
        public var name: String?
        /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
        /// __Default value__: `5`
        public var padding: PaddingChoice?
        /// Dynamic variables or selections that parameterize a visualization.
        public var params: [ParamsItemChoice]?
        /// Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed fields to be repeated along the particular orientations. The objects `{"repeat": "row"}` and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
        public var `repeat`: LayerRepeatMapping
        /// Scale, axis, and legend resolutions for view composition specifications.
        public var resolve: Resolve?
        /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
        /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
        public var spacing: SpacingChoice?
        /// A specification of the view that gets repeated.
        public var spec: SpecChoice
        /// Title for the plot.
        public var title: TitleChoice?
        /// An array of data transformations such as filter and new field calculation.
        public var transform: [DataTransformation]?
        /// Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.
        public var usermeta: Dict?
        public static let codingKeyPaths = (\Self.schema as KeyPath, \Self.align as KeyPath, \Self.autosize as KeyPath, \Self.background as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.columns as KeyPath, \Self.config as KeyPath, \Self.data as KeyPath, \Self.datasets as KeyPath, \Self.description as KeyPath, \Self.name as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self.`repeat` as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.spec as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.usermeta as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.schema as KeyPath : CodingKeys.schema, \Self.align as KeyPath : CodingKeys.align, \Self.autosize as KeyPath : CodingKeys.autosize, \Self.background as KeyPath : CodingKeys.background, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.columns as KeyPath : CodingKeys.columns, \Self.config as KeyPath : CodingKeys.config, \Self.data as KeyPath : CodingKeys.data, \Self.datasets as KeyPath : CodingKeys.datasets, \Self.description as KeyPath : CodingKeys.description, \Self.name as KeyPath : CodingKeys.name, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self.`repeat` as KeyPath : CodingKeys.`repeat`, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.spec as KeyPath : CodingKeys.spec, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.usermeta as KeyPath : CodingKeys.usermeta]

        public init(schema: String? = nil, align: AlignChoice? = nil, autosize: AutosizeChoice? = nil, background: BackgroundChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, columns: Double? = nil, config: ConfigTheme? = nil, data: DataChoice? = nil, datasets: Datasets? = nil, description: String? = nil, name: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, `repeat`: LayerRepeatMapping, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, spec: SpecChoice, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, usermeta: Dict? = nil) {
            self.schema = schema 
            self.align = align 
            self.autosize = autosize 
            self.background = background 
            self.bounds = bounds 
            self.center = center 
            self.columns = columns 
            self.config = config 
            self.data = data 
            self.datasets = datasets 
            self.description = description 
            self.name = name 
            self.padding = padding 
            self.params = params 
            self.`repeat` = `repeat` 
            self.resolve = resolve 
            self.spacing = spacing 
            self.spec = spec 
            self.title = title 
            self.transform = transform 
            self.usermeta = usermeta 
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
            let values = try decoder.container(keyedBy: CodingKeys.self) 
            self.schema = try values.decodeOptional(String.self, forKey: .schema) 
            self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
            self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
            self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
            self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
            self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
            self.columns = try values.decodeOptional(Double.self, forKey: .columns) 
            self.config = try values.decodeOptional(ConfigTheme.self, forKey: .config) 
            self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
            self.datasets = try values.decodeOptional(Datasets.self, forKey: .datasets) 
            self.description = try values.decodeOptional(String.self, forKey: .description) 
            self.name = try values.decodeOptional(String.self, forKey: .name) 
            self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
            self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
            self.`repeat` = try values.decode(LayerRepeatMapping.self, forKey: .`repeat`) 
            self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
            self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
            self.spec = try values.decode(SpecChoice.self, forKey: .spec) 
            self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
            self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
            self.usermeta = try values.decodeOptional(Dict.self, forKey: .usermeta) 
        }

        /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
        /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
        /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
        /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
        /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
        /// __Default value:__ `"all"`.
        /// Generated by Curio
        public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

        /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
        /// __Default value__: `pad`
        /// Generated by Curio
        public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

        /// CSS color property to use as the background of the entire view.
        /// __Default value:__ `"white"`
        /// Generated by Curio
        public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

        /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
        /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
        /// __Default value:__ `false`
        /// Generated by Curio
        public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

        /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
        /// Generated by Curio
        public typealias DataChoice = Nullable<DataProvider>

        /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
        /// __Default value__: `5`
        /// Generated by Curio
        public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

        /// Generated by Curio
        public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<TopLevelSelectionParameter>

        /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
        /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
        /// Generated by Curio
        public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

        /// A specification of the view that gets repeated.
        /// Generated by Curio
        public typealias SpecChoice = OneOf<LayerSpec>.Or<UnitSpec>

        /// Title for the plot.
        /// Generated by Curio
        public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case schema = "$schema"
            case align
            case autosize
            case background
            case bounds
            case center
            case columns
            case config
            case data
            case datasets
            case description
            case name
            case padding
            case params
            case `repeat`
            case resolve
            case spacing
            case spec
            case title
            case transform
            case usermeta
            public var keyDescription: String? {
                switch self {
                case .schema: return "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema."
                case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
                case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
                case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
                case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
                case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
                case .columns: return "The number of columns to include in the view composition layout.\n\n__Default value__: `undefined` -- An infinite number of columns (a single row) will be assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel (for `facet` and `repeat`).\n\n__Note__:\n\n1) This property is only for:\n- the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)\n- the `facet` and `repeat` operator with one field/repetition definition (without row/column nesting)\n\n2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using the `row` channel (for `facet` and `repeat`)."
                case .config: return "Vega-Lite configuration object. This property can only be defined at the top-level of a specification."
                case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
                case .datasets: return "A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property."
                case .description: return "Description of this mark for commenting purpose."
                case .name: return "Name of the visualization for later reference."
                case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
                case .params: return "Dynamic variables or selections that parameterize a visualization."
                case .`repeat`: return "Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If `\"repeat\"` is an array, the field can be referred to as `{\"repeat\": \"repeat\"}`. The repeated views are laid out in a wrapped row. You can set the number of columns to control the wrapping. 2) An object that maps `\"row\"` and/or `\"column\"` to the listed fields to be repeated along the particular orientations. The objects `{\"repeat\": \"row\"}` and `{\"repeat\": \"column\"}` can be used to refer to the repeated field respectively."
                case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
                case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
                case .spec: return "A specification of the view that gets repeated."
                case .title: return "Title for the plot."
                case .transform: return "An array of data transformations such as filter and new field calculation."
                case .usermeta: return "Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata."
                 } 
            }

            public typealias CodingOwner = Type2
        }
    }
}

/// Generated by Curio
public struct TopLevelSelectionParameter : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: ParameterId?
    /// When set, a selection is populated by input elements (also known as dynamic query widgets) or by interacting with the corresponding legend. Direct manipulation interaction is disabled by default; to re-enable it, set the selection's [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties) property.
    /// Legend bindings are restricted to selections that only specify a single field or encoding.
    /// Query widget binding takes the form of Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between projected field/encodings and binding definitions.
    /// __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
    public var bind: BindChoice?
    /// Required. A unique name for the selection parameter. Selection names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or "$", or "_") and may not start with a digit. Reserved keywords that may not be used as parameter names are "datum", "event", "item", and "parent".
    public var name: ParameterName
    /// Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:
    /// - `"point"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.
    /// - `"interval"` -- to select a continuous range of data values on `drag`.
    public var select: SelectChoice
    /// Initialize the selection with a mapping between [projected channels or field names](https://vega.github.io/vega-lite/docs/selection.html#project) and initial values.
    /// __See also:__ [`init`](https://vega.github.io/vega-lite/docs/value.html) documentation.
    public var value: ValueChoice?
    /// By default, top-level selections are applied to every view in the visualization. If this property is specified, selections will only be applied to views with the given names.
    public var views: [ViewsItemChoice]?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.bind as KeyPath, \Self.name as KeyPath, \Self.select as KeyPath, \Self.value as KeyPath, \Self.views as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.bind as KeyPath : CodingKeys.bind, \Self.name as KeyPath : CodingKeys.name, \Self.select as KeyPath : CodingKeys.select, \Self.value as KeyPath : CodingKeys.value, \Self.views as KeyPath : CodingKeys.views]

    public init(id: ParameterId? = nil, bind: BindChoice? = nil, name: ParameterName, select: SelectChoice, value: ValueChoice? = nil, views: [ViewsItemChoice]? = nil) {
        self.id = id 
        self.bind = bind 
        self.name = name 
        self.select = select 
        self.value = value 
        self.views = views 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(ParameterId.self, forKey: .id) 
        self.bind = try values.decodeOptional(BindChoice.self, forKey: .bind) 
        self.name = try values.decode(ParameterName.self, forKey: .name) 
        self.select = try values.decode(SelectChoice.self, forKey: .select) 
        self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
        self.views = try values.decodeOptional([ViewsItemChoice].self, forKey: .views) 
    }

    /// When set, a selection is populated by input elements (also known as dynamic query widgets) or by interacting with the corresponding legend. Direct manipulation interaction is disabled by default; to re-enable it, set the selection's [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties) property.
    /// Legend bindings are restricted to selections that only specify a single field or encoding.
    /// Query widget binding takes the form of Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between projected field/encodings and binding definitions.
    /// __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
    /// Generated by Curio
    public typealias BindChoice = BindTypes.Choice
    public enum BindTypes {

        public typealias Choice = OneOf<BindControl>.Or<Type1>.Or<LegendBinding>.Or<LiteralScales>

        public typealias Type1 = Dictionary<String, Type1Value>
        public typealias Type1Value = BindControl

        /// When set, a selection is populated by input elements (also known as dynamic query widgets) or by interacting with the corresponding legend. Direct manipulation interaction is disabled by default; to re-enable it, set the selection's [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties) property.
        /// Legend bindings are restricted to selections that only specify a single field or encoding.
        /// Query widget binding takes the form of Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between projected field/encodings and binding definitions.
        /// __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
        /// Generated by Curio
        public enum LiteralScales : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
            case scales
        }
    }

    /// Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:
    /// - `"point"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.
    /// - `"interval"` -- to select a continuous range of data values on `drag`.
    /// Generated by Curio
    public typealias SelectChoice = OneOf<SelectionType>.Or<PointSelectionConfig>.Or<IntervalSelectionConfig>

    /// Initialize the selection with a mapping between [projected channels or field names](https://vega.github.io/vega-lite/docs/selection.html#project) and initial values.
    /// __See also:__ [`init`](https://vega.github.io/vega-lite/docs/value.html) documentation.
    /// Generated by Curio
    public typealias ValueChoice = OneOf<SelectionInit>.Or<[SelectionInitMapping]>.Or<SelectionInitIntervalMapping>

    /// Generated by Curio
    public typealias ViewsItemChoice = OneOrMany<String>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case bind
        case name
        case select
        case value
        case views
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .bind: return "When set, a selection is populated by input elements (also known as dynamic query widgets) or by interacting with the corresponding legend. Direct manipulation interaction is disabled by default; to re-enable it, set the selection's [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties) property.\n\nLegend bindings are restricted to selections that only specify a single field or encoding.\n\nQuery widget binding takes the form of Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between projected field/encodings and binding definitions.\n\n__See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation."
            case .name: return "Required. A unique name for the selection parameter. Selection names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or \"$\", or \"_\") and may not start with a digit. Reserved keywords that may not be used as parameter names are \"datum\", \"event\", \"item\", and \"parent\"."
            case .select: return "Determines the default event processing and data query for the selection. Vega-Lite currently supports two selection types:\n\n- `\"point\"` -- to select multiple discrete data values; the first value is selected on `click` and additional values toggled on shift-click.\n- `\"interval\"` -- to select a continuous range of data values on `drag`."
            case .value: return "Initialize the selection with a mapping between [projected channels or field names](https://vega.github.io/vega-lite/docs/selection.html#project) and initial values.\n\n__See also:__ [`init`](https://vega.github.io/vega-lite/docs/value.html) documentation."
            case .views: return "By default, top-level selections are applied to every view in the visualization. If this property is specified, selections will only be applied to views with the given names."
             } 
        }

        public typealias CodingOwner = TopLevelSelectionParameter
    }
}

public struct TopLevelSpec : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<TopLevelUnitSpec>.Or<TopLevelFacetSpec>.Or<TopLevelLayerSpec>.Or<TopLevelRepeatSpec>.Or<TopLevelConcatSpec>.Or<TopLevelVConcatSpec>.Or<TopLevelHConcatSpec>

    public init(rawValue: OneOf<TopLevelUnitSpec>.Or<TopLevelFacetSpec>.Or<TopLevelLayerSpec>.Or<TopLevelRepeatSpec>.Or<TopLevelConcatSpec>.Or<TopLevelVConcatSpec>.Or<TopLevelHConcatSpec>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<TopLevelUnitSpec>.Or<TopLevelFacetSpec>.Or<TopLevelLayerSpec>.Or<TopLevelRepeatSpec>.Or<TopLevelConcatSpec>.Or<TopLevelVConcatSpec>.Or<TopLevelHConcatSpec>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct TopLevelUnitSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
    public var schema: String?
    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    public var align: AlignChoice?
    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    public var autosize: AutosizeChoice?
    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    public var background: BackgroundChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    public var center: CenterChoice?
    /// Vega-Lite configuration object. This property can only be defined at the top-level of a specification.
    public var config: ConfigTheme?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice
    /// A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.
    public var datasets: Datasets?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// A key-value mapping between encoding channels and definition of fields.
    public var encoding: EncodingChannelMap?
    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var height: HeightChoice?
    /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    public var mark: AnyMark
    /// Name of the visualization for later reference.
    public var name: String?
    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    public var padding: PaddingChoice?
    /// An array of parameters that may either be simple variables, or more complex selections that map user input to data queries.
    public var params: [ParamsItemChoice]?
    /// An object defining properties of geographic projection, which will be applied to `shape` path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other marks.
    public var projection: Projection?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    public var spacing: SpacingChoice?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.
    public var usermeta: Dict?
    /// An object defining the view background's fill and stroke.
    /// __Default value:__ none (transparent)
    public var view: ViewBackground?
    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var width: WidthChoice?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.schema as KeyPath, \Self.align as KeyPath, \Self.autosize as KeyPath, \Self.background as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.config as KeyPath, \Self.data as KeyPath, \Self.datasets as KeyPath, \Self.description as KeyPath, \Self.encoding as KeyPath, \Self.height as KeyPath, \Self.mark as KeyPath, \Self.name as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self.projection as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.usermeta as KeyPath, \Self.view as KeyPath, \Self.width as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.schema as KeyPath : CodingKeys.schema, \Self.align as KeyPath : CodingKeys.align, \Self.autosize as KeyPath : CodingKeys.autosize, \Self.background as KeyPath : CodingKeys.background, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.config as KeyPath : CodingKeys.config, \Self.data as KeyPath : CodingKeys.data, \Self.datasets as KeyPath : CodingKeys.datasets, \Self.description as KeyPath : CodingKeys.description, \Self.encoding as KeyPath : CodingKeys.encoding, \Self.height as KeyPath : CodingKeys.height, \Self.mark as KeyPath : CodingKeys.mark, \Self.name as KeyPath : CodingKeys.name, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self.projection as KeyPath : CodingKeys.projection, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.usermeta as KeyPath : CodingKeys.usermeta, \Self.view as KeyPath : CodingKeys.view, \Self.width as KeyPath : CodingKeys.width]

    public init(id: LayerId? = nil, schema: String? = nil, align: AlignChoice? = nil, autosize: AutosizeChoice? = nil, background: BackgroundChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: CenterChoice? = nil, config: ConfigTheme? = nil, data: DataChoice, datasets: Datasets? = nil, description: String? = nil, encoding: EncodingChannelMap? = nil, height: HeightChoice? = nil, mark: AnyMark, name: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, projection: Projection? = nil, resolve: Resolve? = nil, spacing: SpacingChoice? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, usermeta: Dict? = nil, view: ViewBackground? = nil, width: WidthChoice? = nil) {
        self.id = id 
        self.schema = schema 
        self.align = align 
        self.autosize = autosize 
        self.background = background 
        self.bounds = bounds 
        self.center = center 
        self.config = config 
        self.data = data 
        self.datasets = datasets 
        self.description = description 
        self.encoding = encoding 
        self.height = height 
        self.mark = mark 
        self.name = name 
        self.padding = padding 
        self.params = params 
        self.projection = projection 
        self.resolve = resolve 
        self.spacing = spacing 
        self.title = title 
        self.transform = transform 
        self.usermeta = usermeta 
        self.view = view 
        self.width = width 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.schema = try values.decodeOptional(String.self, forKey: .schema) 
        self.align = try values.decodeOptional(AlignChoice.self, forKey: .align) 
        self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
        self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(CenterChoice.self, forKey: .center) 
        self.config = try values.decodeOptional(ConfigTheme.self, forKey: .config) 
        self.data = try values.decode(DataChoice.self, forKey: .data) 
        self.datasets = try values.decodeOptional(Datasets.self, forKey: .datasets) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.encoding = try values.decodeOptional(EncodingChannelMap.self, forKey: .encoding) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.mark = try values.decode(AnyMark.self, forKey: .mark) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.projection = try values.decodeOptional(Projection.self, forKey: .projection) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(SpacingChoice.self, forKey: .spacing) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.usermeta = try values.decodeOptional(Dict.self, forKey: .usermeta) 
        self.view = try values.decodeOptional(ViewBackground.self, forKey: .view) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
    }

    /// The alignment to apply to grid rows and columns. The supported string values are `"all"`, `"each"`, and `"none"`.
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be used to supply different alignments for rows and columns.
    /// __Default value:__ `"all"`.
    /// Generated by Curio
    public typealias AlignChoice = OneOf<LayoutAlign>.Or<RowColLayoutAlign>

    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    /// Generated by Curio
    public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    /// Generated by Curio
    public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply different centering values for rows and columns.
    /// __Default value:__ `false`
    /// Generated by Curio
    public typealias CenterChoice = OneOf<Bool>.Or<RowColBoolean>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<SelectionParameter>

    /// The spacing in pixels between sub-views of the composition operator. An object of the form `{"row": number, "column": number}` can be used to set different spacing values for rows and columns.
    /// __Default value__: Depends on `"spacing"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)
    /// Generated by Curio
    public typealias SpacingChoice = OneOf<Double>.Or<RowColNumber>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case schema = "$schema"
        case align
        case autosize
        case background
        case bounds
        case center
        case config
        case data
        case datasets
        case description
        case encoding
        case height
        case mark
        case name
        case padding
        case params
        case projection
        case resolve
        case spacing
        case title
        case transform
        case usermeta
        case view
        case width
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .schema: return "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema."
            case .align: return "The alignment to apply to grid rows and columns. The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n\n- For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n- For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n- For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n\nAlternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n\n__Default value:__ `\"all\"`."
            case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
            case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\nAn object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n\n__Default value:__ `false`"
            case .config: return "Vega-Lite configuration object. This property can only be defined at the top-level of a specification."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .datasets: return "A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property."
            case .description: return "Description of this mark for commenting purpose."
            case .encoding: return "A key-value mapping between encoding channels and definition of fields."
            case .height: return "The height of a visualization.\n\n- For a plot with a continuous y-field, height should be a number.\n- For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)\n- To enable responsive sizing on height, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation."
            case .mark: return "A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`, `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def)."
            case .name: return "Name of the visualization for later reference."
            case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
            case .params: return "An array of parameters that may either be simple variables, or more complex selections that map user input to data queries."
            case .projection: return "An object defining properties of geographic projection, which will be applied to `shape` path for `\"geoshape\"` marks and to `latitude` and `\"longitude\"` channels for other marks."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the composition operator. An object of the form `{\"row\": number, \"column\": number}` can be used to set different spacing values for rows and columns.\n\n__Default value__: Depends on `\"spacing\"` property of [the view composition configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by default)"
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .usermeta: return "Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata."
            case .view: return "An object defining the view background's fill and stroke.\n\n__Default value:__ none (transparent)"
            case .width: return "The width of a visualization.\n\n- For a plot with a continuous x-field, width should be a number.\n- For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)\n- To enable responsive sizing on width, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation."
             } 
        }

        public typealias CodingOwner = TopLevelUnitSpec
    }
}

/// Generated by Curio
public struct TopLevelVConcatSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
    public var schema: String?
    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    public var autosize: AutosizeChoice?
    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    public var background: BackgroundChoice?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// __Default value:__ `false`
    public var center: Bool?
    /// Vega-Lite configuration object. This property can only be defined at the top-level of a specification.
    public var config: ConfigTheme?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.
    public var datasets: Datasets?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// Name of the visualization for later reference.
    public var name: String?
    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    public var padding: PaddingChoice?
    /// Dynamic variables or selections that parameterize a visualization.
    public var params: [ParamsItemChoice]?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the concat operator.
    /// __Default value__: `10`
    public var spacing: Double?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.
    public var usermeta: Dict?
    /// A list of views to be concatenated and put into a column.
    public var vconcat: [NonNormalizedSpec]
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.schema as KeyPath, \Self.autosize as KeyPath, \Self.background as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.config as KeyPath, \Self.data as KeyPath, \Self.datasets as KeyPath, \Self.description as KeyPath, \Self.name as KeyPath, \Self.padding as KeyPath, \Self.params as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.usermeta as KeyPath, \Self.vconcat as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.schema as KeyPath : CodingKeys.schema, \Self.autosize as KeyPath : CodingKeys.autosize, \Self.background as KeyPath : CodingKeys.background, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.config as KeyPath : CodingKeys.config, \Self.data as KeyPath : CodingKeys.data, \Self.datasets as KeyPath : CodingKeys.datasets, \Self.description as KeyPath : CodingKeys.description, \Self.name as KeyPath : CodingKeys.name, \Self.padding as KeyPath : CodingKeys.padding, \Self.params as KeyPath : CodingKeys.params, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.usermeta as KeyPath : CodingKeys.usermeta, \Self.vconcat as KeyPath : CodingKeys.vconcat]

    public init(id: LayerId? = nil, schema: String? = nil, autosize: AutosizeChoice? = nil, background: BackgroundChoice? = nil, bounds: LiteralFullOrFlush? = nil, center: Bool? = nil, config: ConfigTheme? = nil, data: DataChoice? = nil, datasets: Datasets? = nil, description: String? = nil, name: String? = nil, padding: PaddingChoice? = nil, params: [ParamsItemChoice]? = nil, resolve: Resolve? = nil, spacing: Double? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, usermeta: Dict? = nil, vconcat: [NonNormalizedSpec] = []) {
        self.id = id 
        self.schema = schema 
        self.autosize = autosize 
        self.background = background 
        self.bounds = bounds 
        self.center = center 
        self.config = config 
        self.data = data 
        self.datasets = datasets 
        self.description = description 
        self.name = name 
        self.padding = padding 
        self.params = params 
        self.resolve = resolve 
        self.spacing = spacing 
        self.title = title 
        self.transform = transform 
        self.usermeta = usermeta 
        self.vconcat = vconcat 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.schema = try values.decodeOptional(String.self, forKey: .schema) 
        self.autosize = try values.decodeOptional(AutosizeChoice.self, forKey: .autosize) 
        self.background = try values.decodeOptional(BackgroundChoice.self, forKey: .background) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(Bool.self, forKey: .center) 
        self.config = try values.decodeOptional(ConfigTheme.self, forKey: .config) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.datasets = try values.decodeOptional(Datasets.self, forKey: .datasets) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.padding = try values.decodeOptional(PaddingChoice.self, forKey: .padding) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(Double.self, forKey: .spacing) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.usermeta = try values.decodeOptional(Dict.self, forKey: .usermeta) 
        self.vconcat = try values.decode([NonNormalizedSpec].self, forKey: .vconcat) 
    }

    /// How the visualization size should be determined. If a string, should be one of `"pad"`, `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing and automatic resizing.
    /// __Default value__: `pad`
    /// Generated by Curio
    public typealias AutosizeChoice = OneOf<AutosizeType>.Or<AutoSizeParams>

    /// CSS color property to use as the background of the entire view.
    /// __Default value:__ `"white"`
    /// Generated by Curio
    public typealias BackgroundChoice = OneOf<ColorLiteral>.Or<ExprRef>

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
    /// __Default value__: `5`
    /// Generated by Curio
    public typealias PaddingChoice = OneOf<Padding>.Or<ExprRef>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<TopLevelSelectionParameter>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case schema = "$schema"
        case autosize
        case background
        case bounds
        case center
        case config
        case data
        case datasets
        case description
        case name
        case padding
        case params
        case resolve
        case spacing
        case title
        case transform
        case usermeta
        case vconcat
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .schema: return "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema."
            case .autosize: return "How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`. Object values can additionally specify parameters for content sizing and automatic resizing.\n\n__Default value__: `pad`"
            case .background: return "CSS color property to use as the background of the entire view.\n\n__Default value:__ `\"white\"`"
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\n__Default value:__ `false`"
            case .config: return "Vega-Lite configuration object. This property can only be defined at the top-level of a specification."
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .datasets: return "A global data store for named datasets. This is a mapping from names to inline datasets. This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property."
            case .description: return "Description of this mark for commenting purpose."
            case .name: return "Name of the visualization for later reference."
            case .padding: return "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides. If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
            case .params: return "Dynamic variables or selections that parameterize a visualization."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the concat operator.\n\n__Default value__: `10`"
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .usermeta: return "Optional metadata that will be passed to Vega. This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata."
            case .vconcat: return "A list of views to be concatenated and put into a column."
             } 
        }

        public typealias CodingOwner = TopLevelVConcatSpec
    }
}

/// Generated by Curio
public struct TopoDataFormat : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The name of the TopoJSON object set to convert to a GeoJSON feature collection. For example, in a map of the world, there may be an object set named `"countries"`. Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.
    public var feature: String?
    /// The name of the TopoJSON object set to convert to mesh. Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features. Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.
    public var mesh: String?
    /// If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
    /// For `"date"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
    public var parse: ParseChoice?
    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// __Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `"json"` will be used by default.
    public var type: LiteralTopojson?
    public static let codingKeyPaths = (\Self.feature as KeyPath, \Self.mesh as KeyPath, \Self.parse as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.feature as KeyPath : CodingKeys.feature, \Self.mesh as KeyPath : CodingKeys.mesh, \Self.parse as KeyPath : CodingKeys.parse, \Self.type as KeyPath : CodingKeys.type]

    public init(feature: String? = nil, mesh: String? = nil, parse: ParseChoice? = nil, type: LiteralTopojson? = nil) {
        self.feature = feature 
        self.mesh = mesh 
        self.parse = parse 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.feature = try values.decodeOptional(String.self, forKey: .feature) 
        self.mesh = try values.decodeOptional(String.self, forKey: .mesh) 
        self.parse = try values.decodeOptional(ParseChoice.self, forKey: .parse) 
        self.type = try values.decodeOptional(LiteralTopojson.self, forKey: .type) 
    }

    /// If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
    /// For `"date"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
    /// Generated by Curio
    public typealias ParseChoice = Nullable<Parse>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case feature
        case mesh
        case parse
        case type
        public var keyDescription: String? {
            switch self {
            case .feature: return "The name of the TopoJSON object set to convert to a GeoJSON feature collection. For example, in a map of the world, there may be an object set named `\"countries\"`. Using the feature property, we can extract this set and generate a GeoJSON feature object for each country."
            case .mesh: return "The name of the TopoJSON object set to convert to mesh. Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features. Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties."
            case .parse: return "If set to `null`, disable type inference based on the spec and only use type inference based on the data. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"`, `\"date\"`, or null (do not parse the field)). For example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n\nFor `\"date\"`, we parse data based using JavaScript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). For Specific date formats can be provided (e.g., `{foo: \"date:'%m%d%Y'\"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: \"utc:'%m%d%Y'\"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)"
            case .type: return "Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n\n__Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `\"json\"` will be used by default."
             } 
        }

        public typealias CodingOwner = TopoDataFormat
    }

    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// __Default value:__  The default format type is determined by the extension of the file URL. If no extension is detected, `"json"` will be used by default.
    /// Generated by Curio
    public enum LiteralTopojson : String, Pure, Equatable, Hashable, Codable, GGType, CaseIterable {
        case topojson
    }
}

public struct TransformId : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: UUID

    public init(rawValue: UUID) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: UUID) {
        self.rawValue = rawValue 
    }
}

/// Definition object for a data field, its type and transformation of an encoding channel.
/// Generated by Curio
public struct TypedFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`, `"max"`, `"count"`).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation.
    public var aggregate: Aggregate?
    /// Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`.
    public var bandPosition: Double?
    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    public var bin: BinChoice?
    /// __Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
    /// __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
    /// __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`.
    public var field: SourceColumnRef?
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    public var timeUnit: TimeUnitChoice?
    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    public var title: TitleChoice?
    /// The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for the encoded field or constant value (`datum`). It can also be a `"geojson"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    /// Vega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.
    /// __Default value:__
    /// 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:
    /// - `"quantitative"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale
    /// - `ordinal""` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.
    /// 2) For a constant value in data domain (`datum`):
    /// - `"quantitative"` if the datum is a number
    /// - `"nominal"` if the datum is a string
    /// - `"temporal"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)
    /// __Note:__
    /// - Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.
    /// - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g., `1552199579097`).
    /// - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `"temporal"` (default, for using a temporal scale) or [`"ordinal"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
    /// - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `"cat"` using `{"aggregate": "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
    /// - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).
    /// __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
    public var type: StandardMeasureType?
    public static let codingKeyPaths = (\Self.aggregate as KeyPath, \Self.bandPosition as KeyPath, \Self.bin as KeyPath, \Self.field as KeyPath, \Self.timeUnit as KeyPath, \Self.title as KeyPath, \Self.type as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.aggregate as KeyPath : CodingKeys.aggregate, \Self.bandPosition as KeyPath : CodingKeys.bandPosition, \Self.bin as KeyPath : CodingKeys.bin, \Self.field as KeyPath : CodingKeys.field, \Self.timeUnit as KeyPath : CodingKeys.timeUnit, \Self.title as KeyPath : CodingKeys.title, \Self.type as KeyPath : CodingKeys.type]

    public init(aggregate: Aggregate? = nil, bandPosition: Double? = nil, bin: BinChoice? = nil, field: SourceColumnRef? = nil, timeUnit: TimeUnitChoice? = nil, title: TitleChoice? = nil, type: StandardMeasureType? = nil) {
        self.aggregate = aggregate 
        self.bandPosition = bandPosition 
        self.bin = bin 
        self.field = field 
        self.timeUnit = timeUnit 
        self.title = title 
        self.type = type 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.aggregate = try values.decodeOptional(Aggregate.self, forKey: .aggregate) 
        self.bandPosition = try values.decodeOptional(Double.self, forKey: .bandPosition) 
        self.bin = try values.decodeOptional(BinChoice.self, forKey: .bin) 
        self.field = try values.decodeOptional(SourceColumnRef.self, forKey: .field) 
        self.timeUnit = try values.decodeOptional(TimeUnitChoice.self, forKey: .timeUnit) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.type = try values.decodeOptional(StandardMeasureType.self, forKey: .type) 
    }

    /// A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`"binned"`).
    /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.
    /// - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
    /// __Default value:__ `false`
    /// __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
    /// Generated by Curio
    public typealias BinChoice = Nullable<OneOf<Bool>.Or<BinParams>.Or<LiteralBinned>>

    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    /// __Default value:__ `undefined` (None)
    /// __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation.
    /// Generated by Curio
    public typealias TimeUnitChoice = OneOf<TimeUnit>.Or<TimeUnitParams>

    /// A title for the field. If `null`, the title will be removed.
    /// __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field name.
    /// __Notes__:
    /// 1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
    /// 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.
    /// Generated by Curio
    public typealias TitleChoice = Nullable<StringList>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case aggregate
        case bandPosition
        case bin
        case field
        case timeUnit
        case title
        case type
        public var keyDescription: String? {
            switch self {
            case .aggregate: return "Aggregation function for the field (e.g., `\"mean\"`, `\"sum\"`, `\"median\"`, `\"min\"`, `\"max\"`, `\"count\"`).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html) documentation."
            case .bandPosition: return "Relative position on a band of a stacked, binned, time unit, or band scale. For example, the marks will be positioned at the beginning of the band if set to `0`, and at the middle of the band if set to `0.5`."
            case .bin: return "A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n\n- If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n\n- If `\"binned\"`, this indicates that the data for the `x` (or `y`) channel are already binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n\n__Default value:__ `false`\n\n__See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation."
            case .field: return "__Required.__ A string defining the name of the field from which to pull a data value or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n\n__See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.\n\n__Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`). If field names contain dots or brackets but are not nested, you can use `\\` to escape dots and brackets (e.g., `\"a\\.b\"` and `\"a\\[0\\]\"`). See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not required if `aggregate` is `count`."
            case .timeUnit: return "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n\n__Default value:__ `undefined` (None)\n\n__See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html) documentation."
            case .title: return "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`). Otherwise, the title is simply the field name.\n\n__Notes__:\n\n1) You can customize the default field title format by providing the [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config) property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/usage/compile.html#field-title).\n\n2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used."
            case .type: return "The type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`) for the encoded field or constant value (`datum`). It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n\nVega-Lite automatically infers data types in many cases as discussed below. However, type is required for a field if: (1) the field is not nominal and the field encoding has no specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort` order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin` or `timeUnit`.\n\n__Default value:__\n\n1) For a data `field`, `\"nominal\"` is the default data type unless the field encoding has `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the following criteria:\n- `\"quantitative\"` is the default type if (1) the encoded field contains `bin` or `aggregate` except `\"argmin\"` and `\"argmax\"`, (2) the encoding channel is `latitude` or `longitude` channel or (3) if the specified scale type is [a quantitative scale](https://vega.github.io/vega-lite/docs/scale.html#type).\n- `\"temporal\"` is the default type if (1) the encoded field contains `timeUnit` or (2) the specified scale type is a time or utc scale\n- `ordinal\"\"` is the default type if (1) the encoded field contains a [custom `sort` order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2) the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is `order`.\n\n2) For a constant value in data domain (`datum`):\n- `\"quantitative\"` if the datum is a number\n- `\"nominal\"` if the datum is a string\n- `\"temporal\"` if the datum is [a date time object](https://vega.github.io/vega-lite/docs/datetime.html)\n\n__Note:__\n- Data `type` describes the semantics of the data rather than the primitive data types (number, string, etc.). The same primitive data type can have different types of measurement. For example, numeric data can represent quantitative, ordinal, or nominal data.\n- Data values for a temporal field can be either a date-time string (e.g., `\"2015-03-07 12:32:17\"`, `\"17:01\"`, `\"2015-03-16\"`. `\"2015\"`) or a timestamp number (e.g., `1552199579097`).\n- When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type` property can be either `\"quantitative\"` (for using a linear bin scale) or [`\"ordinal\"` (for using an ordinal bin scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the `type` property can be either `\"temporal\"` (default, for using a temporal scale) or [`\"ordinal\"` (for using an ordinal scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).\n- When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html), the `type` property refers to the post-aggregation data type. For example, we can calculate count `distinct` of a categorical field `\"cat\"` using `{\"aggregate\": \"distinct\", \"field\": \"cat\"}`. The `\"type\"` of the aggregate output is `\"quantitative\"`.\n- Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they must have exactly the same type as their primary channels (e.g., `x`, `y`).\n\n__See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation."
             } 
        }

        public typealias CodingOwner = TypedFieldDef
    }
}

/// Generated by Curio
public struct UnitSpecWithFrame : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// A key-value mapping between encoding channels and definition of fields.
    public var encoding: Encoding?
    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var height: HeightChoice?
    /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    public var mark: AnyMark
    /// Name of the visualization for later reference.
    public var name: String?
    /// An array of parameters that may either be simple variables, or more complex selections that map user input to data queries.
    public var params: [ParamsItemChoice]?
    /// An object defining properties of geographic projection, which will be applied to `shape` path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other marks.
    public var projection: Projection?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// An object defining the view background's fill and stroke.
    /// __Default value:__ none (transparent)
    public var view: ViewBackground?
    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    public var width: WidthChoice?
    public static let codingKeyPaths = (\Self.data as KeyPath, \Self.description as KeyPath, \Self.encoding as KeyPath, \Self.height as KeyPath, \Self.mark as KeyPath, \Self.name as KeyPath, \Self.params as KeyPath, \Self.projection as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.view as KeyPath, \Self.width as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.encoding as KeyPath : CodingKeys.encoding, \Self.height as KeyPath : CodingKeys.height, \Self.mark as KeyPath : CodingKeys.mark, \Self.name as KeyPath : CodingKeys.name, \Self.params as KeyPath : CodingKeys.params, \Self.projection as KeyPath : CodingKeys.projection, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.view as KeyPath : CodingKeys.view, \Self.width as KeyPath : CodingKeys.width]

    public init(data: DataChoice? = nil, description: String? = nil, encoding: Encoding? = nil, height: HeightChoice? = nil, mark: AnyMark, name: String? = nil, params: [ParamsItemChoice]? = nil, projection: Projection? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, view: ViewBackground? = nil, width: WidthChoice? = nil) {
        self.data = data 
        self.description = description 
        self.encoding = encoding 
        self.height = height 
        self.mark = mark 
        self.name = name 
        self.params = params 
        self.projection = projection 
        self.title = title 
        self.transform = transform 
        self.view = view 
        self.width = width 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.encoding = try values.decodeOptional(Encoding.self, forKey: .encoding) 
        self.height = try values.decodeOptional(HeightChoice.self, forKey: .height) 
        self.mark = try values.decode(AnyMark.self, forKey: .mark) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.params = try values.decodeOptional([ParamsItemChoice].self, forKey: .params) 
        self.projection = try values.decodeOptional(Projection.self, forKey: .projection) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.view = try values.decodeOptional(ViewBackground.self, forKey: .view) 
        self.width = try values.decodeOptional(WidthChoice.self, forKey: .width) 
    }

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// The height of a visualization.
    /// - For a plot with a continuous y-field, height should be a number.
    /// - For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on height, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias HeightChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    /// Generated by Curio
    public typealias ParamsItemChoice = OneOf<VariableParameter>.Or<SelectionParameter>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    /// The width of a visualization.
    /// - For a plot with a continuous x-field, width should be a number.
    /// - For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)
    /// - To enable responsive sizing on width, it should be set to `"container"`.
    /// __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.
    /// __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `"container"` option cannot be used.
    /// __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
    /// Generated by Curio
    public typealias WidthChoice = OneOf<Double>.Or<LiteralContainer>.Or<Step>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case data
        case description
        case encoding
        case height
        case mark
        case name
        case params
        case projection
        case title
        case transform
        case view
        case width
        public var keyDescription: String? {
            switch self {
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .encoding: return "A key-value mapping between encoding channels and definition of fields."
            case .height: return "The height of a visualization.\n\n- For a plot with a continuous y-field, height should be a number.\n- For a plot with either a discrete y-field or no y-field, height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step. (No y-field is equivalent to having one discrete step.)\n- To enable responsive sizing on height, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous y-field and `config.view.discreteHeight` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation."
            case .mark: return "A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`, `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def)."
            case .name: return "Name of the visualization for later reference."
            case .params: return "An array of parameters that may either be simple variables, or more complex selections that map user input to data queries."
            case .projection: return "An object defining properties of geographic projection, which will be applied to `shape` path for `\"geoshape\"` marks and to `latitude` and `\"longitude\"` channels for other marks."
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .view: return "An object defining the view background's fill and stroke.\n\n__Default value:__ none (transparent)"
            case .width: return "The width of a visualization.\n\n- For a plot with a continuous x-field, width should be a number.\n- For a plot with either a discrete x-field or no x-field, width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step. (No x-field is equivalent to having one discrete step.)\n- To enable responsive sizing on width, it should be set to `\"container\"`.\n\n__Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous x-field and `config.view.discreteWidth` otherwise.\n\n__Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view and the `\"container\"` option cannot be used.\n\n__See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation."
             } 
        }

        public typealias CodingOwner = UnitSpecWithFrame
    }
}

/// Generated by Curio
public struct UrlData : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// An object that specifies the format for parsing the data.
    public var format: DataFormat?
    /// Provide a placeholder name and bind data at runtime.
    public var name: String?
    /// An URL from which to load the data set. Use the `format.type` property to ensure the loaded data is correctly parsed.
    public var url: String
    public static let codingKeyPaths = (\Self.format as KeyPath, \Self.name as KeyPath, \Self.url as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.format as KeyPath : CodingKeys.format, \Self.name as KeyPath : CodingKeys.name, \Self.url as KeyPath : CodingKeys.url]

    public init(format: DataFormat? = nil, name: String? = nil, url: String) {
        self.format = format 
        self.name = name 
        self.url = url 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.format = try values.decodeOptional(DataFormat.self, forKey: .format) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.url = try values.decode(String.self, forKey: .url) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case format
        case name
        case url
        public var keyDescription: String? {
            switch self {
            case .format: return "An object that specifies the format for parsing the data."
            case .name: return "Provide a placeholder name and bind data at runtime."
            case .url: return "An URL from which to load the data set. Use the `format.type` property to ensure the loaded data is correctly parsed."
             } 
        }

        public typealias CodingOwner = UrlData
    }
}

/// Base interface for a vertical concatenation specification.
/// Generated by Curio
public struct VConcatSpecGenericSpec : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: LayerId?
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    /// __Default value:__ `"full"`
    public var bounds: LiteralFullOrFlush?
    /// Boolean flag indicating if subviews should be centered relative to their respective rows or columns.
    /// __Default value:__ `false`
    public var center: Bool?
    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    public var data: DataChoice?
    /// Description of this mark for commenting purpose.
    public var description: String?
    /// Name of the visualization for later reference.
    public var name: String?
    /// Scale, axis, and legend resolutions for view composition specifications.
    public var resolve: Resolve?
    /// The spacing in pixels between sub-views of the concat operator.
    /// __Default value__: `10`
    public var spacing: Double?
    /// Title for the plot.
    public var title: TitleChoice?
    /// An array of data transformations such as filter and new field calculation.
    public var transform: [DataTransformation]?
    /// A list of views to be concatenated and put into a column.
    public var vconcat: [Spec]
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.bounds as KeyPath, \Self.center as KeyPath, \Self.data as KeyPath, \Self.description as KeyPath, \Self.name as KeyPath, \Self.resolve as KeyPath, \Self.spacing as KeyPath, \Self.title as KeyPath, \Self.transform as KeyPath, \Self.vconcat as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.bounds as KeyPath : CodingKeys.bounds, \Self.center as KeyPath : CodingKeys.center, \Self.data as KeyPath : CodingKeys.data, \Self.description as KeyPath : CodingKeys.description, \Self.name as KeyPath : CodingKeys.name, \Self.resolve as KeyPath : CodingKeys.resolve, \Self.spacing as KeyPath : CodingKeys.spacing, \Self.title as KeyPath : CodingKeys.title, \Self.transform as KeyPath : CodingKeys.transform, \Self.vconcat as KeyPath : CodingKeys.vconcat]

    public init(id: LayerId? = nil, bounds: LiteralFullOrFlush? = nil, center: Bool? = nil, data: DataChoice? = nil, description: String? = nil, name: String? = nil, resolve: Resolve? = nil, spacing: Double? = nil, title: TitleChoice? = nil, transform: [DataTransformation]? = nil, vconcat: [Spec] = []) {
        self.id = id 
        self.bounds = bounds 
        self.center = center 
        self.data = data 
        self.description = description 
        self.name = name 
        self.resolve = resolve 
        self.spacing = spacing 
        self.title = title 
        self.transform = transform 
        self.vconcat = vconcat 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(LayerId.self, forKey: .id) 
        self.bounds = try values.decodeOptional(LiteralFullOrFlush.self, forKey: .bounds) 
        self.center = try values.decodeOptional(Bool.self, forKey: .center) 
        self.data = try values.decodeOptional(DataChoice.self, forKey: .data) 
        self.description = try values.decodeOptional(String.self, forKey: .description) 
        self.name = try values.decodeOptional(String.self, forKey: .name) 
        self.resolve = try values.decodeOptional(Resolve.self, forKey: .resolve) 
        self.spacing = try values.decodeOptional(Double.self, forKey: .spacing) 
        self.title = try values.decodeOptional(TitleChoice.self, forKey: .title) 
        self.transform = try values.decodeOptional([DataTransformation].self, forKey: .transform) 
        self.vconcat = try values.decode([Spec].self, forKey: .vconcat) 
    }

    /// An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent.
    /// Generated by Curio
    public typealias DataChoice = Nullable<DataProvider>

    /// Title for the plot.
    /// Generated by Curio
    public typealias TitleChoice = OneOf<StringList>.Or<TitleParams>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case bounds
        case center
        case data
        case description
        case name
        case resolve
        case spacing
        case title
        case transform
        case vconcat
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .bounds: return "The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n\n- If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n- If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n\n__Default value:__ `\"full\"`"
            case .center: return "Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n\n__Default value:__ `false`"
            case .data: return "An object describing the data source. Set to `null` to ignore the parent's data source. If no data is set, it is derived from the parent."
            case .description: return "Description of this mark for commenting purpose."
            case .name: return "Name of the visualization for later reference."
            case .resolve: return "Scale, axis, and legend resolutions for view composition specifications."
            case .spacing: return "The spacing in pixels between sub-views of the concat operator.\n\n__Default value__: `10`"
            case .title: return "Title for the plot."
            case .transform: return "An array of data transformations such as filter and new field calculation."
            case .vconcat: return "A list of views to be concatenated and put into a column."
             } 
        }

        public typealias CodingOwner = VConcatSpecGenericSpec
    }
}

/// Definition object for a constant value (primitive value or gradient definition) of an encoding channel.
/// Generated by Curio
public struct ValueDefNumber : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: Double
    public static let codingKeyPaths = (\Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.value as KeyPath : CodingKeys.value]

    public init(value: Double) {
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.value = try values.decode(Double.self, forKey: .value) 
    }

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case value
        public var keyDescription: String? {
            switch self {
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ValueDefNumber
    }
}

/// Definition object for a constant value (primitive value or gradient definition) of an encoding channel.
/// Generated by Curio
public struct ValueDefNumberWidthHeightExprRef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice
    public static let codingKeyPaths = (\Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.value as KeyPath : CodingKeys.value]

    public init(value: ValueChoice) {
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.value = try values.decode(ValueChoice.self, forKey: .value) 
    }

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<Double>.Or<LiteralWidth>.Or<LiteralHeight>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case value
        public var keyDescription: String? {
            switch self {
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ValueDefNumberWidthHeightExprRef
    }
}

/// Generated by Curio
public struct ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A field definition or one or more value definition(s) with a parameter predicate.
    public var condition: ConditionChoice?
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice?
    public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

    public init(condition: ConditionChoice? = nil, value: ValueChoice? = nil) {
        self.condition = condition 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
    }

    /// A field definition or one or more value definition(s) with a parameter predicate.
    /// Generated by Curio
    public typealias ConditionChoice = OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefGradientStringNullExprRef>>

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = Nullable<OneOf<ColorGradient>.Or<String>.Or<ExprRef>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case condition
        case value
        public var keyDescription: String? {
            switch self {
            case .condition: return "A field definition or one or more value definition(s) with a parameter predicate."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull
    }
}

/// Generated by Curio
public struct ValueDefWithConditionMarkPropFieldOrDatumDefNumber : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A field definition or one or more value definition(s) with a parameter predicate.
    public var condition: ConditionChoice?
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice?
    public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

    public init(condition: ConditionChoice? = nil, value: ValueChoice? = nil) {
        self.condition = condition 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
    }

    /// A field definition or one or more value definition(s) with a parameter predicate.
    /// Generated by Curio
    public typealias ConditionChoice = OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberExprRef>>

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case condition
        case value
        public var keyDescription: String? {
            switch self {
            case .condition: return "A field definition or one or more value definition(s) with a parameter predicate."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ValueDefWithConditionMarkPropFieldOrDatumDefNumber
    }
}

/// Generated by Curio
public struct ValueDefWithConditionMarkPropFieldOrDatumDefNumberArray : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A field definition or one or more value definition(s) with a parameter predicate.
    public var condition: ConditionChoice?
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice?
    public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

    public init(condition: ConditionChoice? = nil, value: ValueChoice? = nil) {
        self.condition = condition 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
    }

    /// A field definition or one or more value definition(s) with a parameter predicate.
    /// Generated by Curio
    public typealias ConditionChoice = OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefNumberArrayExprRef>>

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<[Double]>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case condition
        case value
        public var keyDescription: String? {
            switch self {
            case .condition: return "A field definition or one or more value definition(s) with a parameter predicate."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ValueDefWithConditionMarkPropFieldOrDatumDefNumberArray
    }
}

/// Generated by Curio
public struct ValueDefWithConditionMarkPropFieldOrDatumDefStringNull : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A field definition or one or more value definition(s) with a parameter predicate.
    public var condition: ConditionChoice?
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice?
    public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

    public init(condition: ConditionChoice? = nil, value: ValueChoice? = nil) {
        self.condition = condition 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
    }

    /// A field definition or one or more value definition(s) with a parameter predicate.
    /// Generated by Curio
    public typealias ConditionChoice = OneOf<ConditionalMarkPropFieldOrDatumDef>.Or<OneOrMany<ConditionalValueDefStringNullExprRef>>

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = Nullable<OneOf<String>.Or<ExprRef>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case condition
        case value
        public var keyDescription: String? {
            switch self {
            case .condition: return "A field definition or one or more value definition(s) with a parameter predicate."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ValueDefWithConditionMarkPropFieldOrDatumDefStringNull
    }
}

/// Generated by Curio
public struct ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A field definition or one or more value definition(s) with a parameter predicate.
    public var condition: ConditionChoice?
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: Nullable<SymbolShape>?
    public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

    public init(condition: ConditionChoice? = nil, value: Nullable<SymbolShape>? = nil) {
        self.condition = condition 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.value = try values.decodeOptional(Nullable<SymbolShape>.self, forKey: .value) 
    }

    /// A field definition or one or more value definition(s) with a parameter predicate.
    /// Generated by Curio
    public typealias ConditionChoice = OneOf<ConditionalMarkPropFieldOrDatumDefTypeForShape>.Or<OneOrMany<ConditionalValueDefStringNullExprRef>>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case condition
        case value
        public var keyDescription: String? {
            switch self {
            case .condition: return "A field definition or one or more value definition(s) with a parameter predicate."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull
    }
}

/// Generated by Curio
public struct ValueDefWithConditionStringFieldDefText : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// A field definition or one or more value definition(s) with a parameter predicate.
    public var condition: ConditionChoice?
    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    public var value: ValueChoice?
    public static let codingKeyPaths = (\Self.condition as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.condition as KeyPath : CodingKeys.condition, \Self.value as KeyPath : CodingKeys.value]

    public init(condition: ConditionChoice? = nil, value: ValueChoice? = nil) {
        self.condition = condition 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.condition = try values.decodeOptional(ConditionChoice.self, forKey: .condition) 
        self.value = try values.decodeOptional(ValueChoice.self, forKey: .value) 
    }

    /// A field definition or one or more value definition(s) with a parameter predicate.
    /// Generated by Curio
    public typealias ConditionChoice = OneOf<ConditionalStringFieldDef>.Or<OneOrMany<ConditionalValueDefTextExprRef>>

    /// A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity).
    /// Generated by Curio
    public typealias ValueChoice = OneOf<StringList>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case condition
        case value
        public var keyDescription: String? {
            switch self {
            case .condition: return "A field definition or one or more value definition(s) with a parameter predicate."
            case .value: return "A constant value in visual domain (e.g., `\"red\"` / `\"#0099ff\"` / [gradient definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values between `0` to `1` for opacity)."
             } 
        }

        public typealias CodingOwner = ValueDefWithConditionStringFieldDefText
    }
}

/// Generated by Curio
public struct VariableParameter : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: ParameterId?
    /// Binds the parameter to an external input element such as a slider, selection list or radio button group.
    public var bind: BindControl?
    /// An expression for the value of the parameter. This expression may include other parameters, in which case the parameter will automatically update in response to upstream parameter changes.
    public var expr: Expr?
    /// A unique name for the variable parameter. Parameter names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or "$", or "_") and may not start with a digit. Reserved keywords that may not be used as parameter names are "datum", "event", "item", and "parent".
    public var name: ParameterName
    /// The [initial value](http://vega.github.io/vega-lite/docs/value.html) of the parameter.
    /// __Default value:__ `undefined`
    public var value: Value?
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.bind as KeyPath, \Self.expr as KeyPath, \Self.name as KeyPath, \Self.value as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.bind as KeyPath : CodingKeys.bind, \Self.expr as KeyPath : CodingKeys.expr, \Self.name as KeyPath : CodingKeys.name, \Self.value as KeyPath : CodingKeys.value]

    public init(id: ParameterId? = nil, bind: BindControl? = nil, expr: Expr? = nil, name: ParameterName, value: Value? = nil) {
        self.id = id 
        self.bind = bind 
        self.expr = expr 
        self.name = name 
        self.value = value 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(ParameterId.self, forKey: .id) 
        self.bind = try values.decodeOptional(BindControl.self, forKey: .bind) 
        self.expr = try values.decodeOptional(Expr.self, forKey: .expr) 
        self.name = try values.decode(ParameterName.self, forKey: .name) 
        self.value = try values.decodeOptional(Value.self, forKey: .value) 
    }

    public typealias Value = Bric

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case bind
        case expr
        case name
        case value
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .bind: return "Binds the parameter to an external input element such as a slider, selection list or radio button group."
            case .expr: return "An expression for the value of the parameter. This expression may include other parameters, in which case the parameter will automatically update in response to upstream parameter changes."
            case .name: return "A unique name for the variable parameter. Parameter names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or \"$\", or \"_\") and may not start with a digit. Reserved keywords that may not be used as parameter names are \"datum\", \"event\", \"item\", and \"parent\"."
            case .value: return "The [initial value](http://vega.github.io/vega-lite/docs/value.html) of the parameter.\n\n__Default value:__ `undefined`"
             } 
        }

        public typealias CodingOwner = VariableParameter
    }
}

/// Generated by Curio
public struct ViewBackground : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    public var cornerRadius: CornerRadiusChoice?
    /// The mouse cursor used over the view. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
    public var cursor: Cursor?
    /// The fill color.
    /// __Default value:__ `undefined`
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// The stroke color.
    /// __Default value:__ `"#ddd"`
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    /// A string or array of strings indicating the name of custom styles to apply to the view background. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.
    /// __Default value:__ `"cell"` __Note:__ Any specified view background properties will augment the default style.
    public var style: StyleChoice?
    public static let codingKeyPaths = (\Self.cornerRadius as KeyPath, \Self.cursor as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.opacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.style as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.style as KeyPath : CodingKeys.style]

    public init(cornerRadius: CornerRadiusChoice? = nil, cursor: Cursor? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, opacity: OpacityChoice? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil, style: StyleChoice? = nil) {
        self.cornerRadius = cornerRadius 
        self.cursor = cursor 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.opacity = opacity 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
        self.style = style 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cursor = try values.decodeOptional(Cursor.self, forKey: .cursor) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
        self.style = try values.decodeOptional(StyleChoice.self, forKey: .style) 
    }

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// The fill color.
    /// __Default value:__ `undefined`
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// The stroke color.
    /// __Default value:__ `"#ddd"`
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    /// A string or array of strings indicating the name of custom styles to apply to the view background. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.
    /// __Default value:__ `"cell"` __Note:__ Any specified view background properties will augment the default style.
    /// Generated by Curio
    public typealias StyleChoice = OneOrMany<String>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case cornerRadius
        case cursor
        case fill
        case fillOpacity
        case opacity
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOpacity
        case strokeWidth
        case style
        public var keyDescription: String? {
            switch self {
            case .cornerRadius: return nil
            case .cursor: return "The mouse cursor used over the view. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used."
            case .fill: return "The fill color.\n\n__Default value:__ `undefined`"
            case .fillOpacity: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .stroke: return "The stroke color.\n\n__Default value:__ `\"#ddd\"`"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
            case .style: return "A string or array of strings indicating the name of custom styles to apply to the view background. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles.\n\n__Default value:__ `\"cell\"` __Note:__ Any specified view background properties will augment the default style."
             } 
        }

        public typealias CodingOwner = ViewBackground
    }
}

/// Generated by Curio
public struct ViewConfig : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// Whether the view should be clipped.
    public var clip: Bool?
    /// The default height when the plot has a continuous y-field for x or latitude, or has arc marks.
    /// __Default value:__ `200`
    public var continuousHeight: Double?
    /// The default width when the plot has a continuous field for x or longitude, or has arc marks.
    /// __Default value:__ `200`
    public var continuousWidth: Double?
    public var cornerRadius: CornerRadiusChoice?
    /// The mouse cursor used over the view. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
    public var cursor: Cursor?
    /// The default height when the plot has non arc marks and either a discrete y-field or no y-field. The height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step.
    /// __Default value:__ a step size based on `config.view.step`.
    public var discreteHeight: DiscreteHeightChoice?
    /// The default width when the plot has non-arc marks and either a discrete x-field or no x-field. The width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step.
    /// __Default value:__ a step size based on `config.view.step`.
    public var discreteWidth: DiscreteWidthChoice?
    /// The fill color.
    /// __Default value:__ `undefined`
    public var fill: FillChoice?
    public var fillOpacity: FillOpacityChoice?
    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    public var opacity: OpacityChoice?
    /// Default step size for x-/y- discrete fields.
    public var step: Double?
    /// The stroke color.
    /// __Default value:__ `"#ddd"`
    public var stroke: StrokeChoice?
    public var strokeCap: StrokeCapChoice?
    public var strokeDash: StrokeDashChoice?
    public var strokeDashOffset: StrokeDashOffsetChoice?
    public var strokeJoin: StrokeJoinChoice?
    public var strokeMiterLimit: StrokeMiterLimitChoice?
    public var strokeOpacity: StrokeOpacityChoice?
    public var strokeWidth: StrokeWidthChoice?
    public static let codingKeyPaths = (\Self.clip as KeyPath, \Self.continuousHeight as KeyPath, \Self.continuousWidth as KeyPath, \Self.cornerRadius as KeyPath, \Self.cursor as KeyPath, \Self.discreteHeight as KeyPath, \Self.discreteWidth as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.opacity as KeyPath, \Self.step as KeyPath, \Self.stroke as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.clip as KeyPath : CodingKeys.clip, \Self.continuousHeight as KeyPath : CodingKeys.continuousHeight, \Self.continuousWidth as KeyPath : CodingKeys.continuousWidth, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.discreteHeight as KeyPath : CodingKeys.discreteHeight, \Self.discreteWidth as KeyPath : CodingKeys.discreteWidth, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.step as KeyPath : CodingKeys.step, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth]

    public init(clip: Bool? = nil, continuousHeight: Double? = nil, continuousWidth: Double? = nil, cornerRadius: CornerRadiusChoice? = nil, cursor: Cursor? = nil, discreteHeight: DiscreteHeightChoice? = nil, discreteWidth: DiscreteWidthChoice? = nil, fill: FillChoice? = nil, fillOpacity: FillOpacityChoice? = nil, opacity: OpacityChoice? = nil, step: Double? = nil, stroke: StrokeChoice? = nil, strokeCap: StrokeCapChoice? = nil, strokeDash: StrokeDashChoice? = nil, strokeDashOffset: StrokeDashOffsetChoice? = nil, strokeJoin: StrokeJoinChoice? = nil, strokeMiterLimit: StrokeMiterLimitChoice? = nil, strokeOpacity: StrokeOpacityChoice? = nil, strokeWidth: StrokeWidthChoice? = nil) {
        self.clip = clip 
        self.continuousHeight = continuousHeight 
        self.continuousWidth = continuousWidth 
        self.cornerRadius = cornerRadius 
        self.cursor = cursor 
        self.discreteHeight = discreteHeight 
        self.discreteWidth = discreteWidth 
        self.fill = fill 
        self.fillOpacity = fillOpacity 
        self.opacity = opacity 
        self.step = step 
        self.stroke = stroke 
        self.strokeCap = strokeCap 
        self.strokeDash = strokeDash 
        self.strokeDashOffset = strokeDashOffset 
        self.strokeJoin = strokeJoin 
        self.strokeMiterLimit = strokeMiterLimit 
        self.strokeOpacity = strokeOpacity 
        self.strokeWidth = strokeWidth 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.clip = try values.decodeOptional(Bool.self, forKey: .clip) 
        self.continuousHeight = try values.decodeOptional(Double.self, forKey: .continuousHeight) 
        self.continuousWidth = try values.decodeOptional(Double.self, forKey: .continuousWidth) 
        self.cornerRadius = try values.decodeOptional(CornerRadiusChoice.self, forKey: .cornerRadius) 
        self.cursor = try values.decodeOptional(Cursor.self, forKey: .cursor) 
        self.discreteHeight = try values.decodeOptional(DiscreteHeightChoice.self, forKey: .discreteHeight) 
        self.discreteWidth = try values.decodeOptional(DiscreteWidthChoice.self, forKey: .discreteWidth) 
        self.fill = try values.decodeOptional(FillChoice.self, forKey: .fill) 
        self.fillOpacity = try values.decodeOptional(FillOpacityChoice.self, forKey: .fillOpacity) 
        self.opacity = try values.decodeOptional(OpacityChoice.self, forKey: .opacity) 
        self.step = try values.decodeOptional(Double.self, forKey: .step) 
        self.stroke = try values.decodeOptional(StrokeChoice.self, forKey: .stroke) 
        self.strokeCap = try values.decodeOptional(StrokeCapChoice.self, forKey: .strokeCap) 
        self.strokeDash = try values.decodeOptional(StrokeDashChoice.self, forKey: .strokeDash) 
        self.strokeDashOffset = try values.decodeOptional(StrokeDashOffsetChoice.self, forKey: .strokeDashOffset) 
        self.strokeJoin = try values.decodeOptional(StrokeJoinChoice.self, forKey: .strokeJoin) 
        self.strokeMiterLimit = try values.decodeOptional(StrokeMiterLimitChoice.self, forKey: .strokeMiterLimit) 
        self.strokeOpacity = try values.decodeOptional(StrokeOpacityChoice.self, forKey: .strokeOpacity) 
        self.strokeWidth = try values.decodeOptional(StrokeWidthChoice.self, forKey: .strokeWidth) 
    }

    /// Generated by Curio
    public typealias CornerRadiusChoice = OneOf<Double>.Or<ExprRef>

    /// The default height when the plot has non arc marks and either a discrete y-field or no y-field. The height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step.
    /// __Default value:__ a step size based on `config.view.step`.
    /// Generated by Curio
    public typealias DiscreteHeightChoice = DiscreteHeightTypes.Choice
    public enum DiscreteHeightTypes {

        public typealias Choice = OneOf<Double>.Or<StepType>

        /// Generated by Curio
        public struct StepType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
            public var step: Double
            public static let codingKeyPaths = (\Self.step as KeyPath)
            public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.step as KeyPath : CodingKeys.step]

            public init(step: Double) {
                self.step = step 
            }

            public init(from decoder: Decoder) throws {
                try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
                let values = try decoder.container(keyedBy: CodingKeys.self) 
                self.step = try values.decode(Double.self, forKey: .step) 
            }

            public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
                case step
                public var keyDescription: String? {
                    switch self {
                    case .step: return nil
                     } 
                }

                public typealias CodingOwner = StepType
            }
        }
    }

    /// The default width when the plot has non-arc marks and either a discrete x-field or no x-field. The width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step.
    /// __Default value:__ a step size based on `config.view.step`.
    /// Generated by Curio
    public typealias DiscreteWidthChoice = DiscreteWidthTypes.Choice
    public enum DiscreteWidthTypes {

        public typealias Choice = OneOf<Double>.Or<StepType>

        /// Generated by Curio
        public struct StepType : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
            public var step: Double
            public static let codingKeyPaths = (\Self.step as KeyPath)
            public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.step as KeyPath : CodingKeys.step]

            public init(step: Double) {
                self.step = step 
            }

            public init(from decoder: Decoder) throws {
                try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
                let values = try decoder.container(keyedBy: CodingKeys.self) 
                self.step = try values.decode(Double.self, forKey: .step) 
            }

            public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
                case step
                public var keyDescription: String? {
                    switch self {
                    case .step: return nil
                     } 
                }

                public typealias CodingOwner = StepType
            }
        }
    }

    /// The fill color.
    /// __Default value:__ `undefined`
    /// Generated by Curio
    public typealias FillChoice = Nullable<OneOf<ColorLiteral>.Or<ExprRef>>

    /// Generated by Curio
    public typealias FillOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// The overall opacity (value between [0,1]).
    /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
    /// Generated by Curio
    public typealias OpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeCapChoice = OneOf<StrokeCap>.Or<ExprRef>

    /// The stroke color.
    /// __Default value:__ `"#ddd"`
    /// Generated by Curio
    public typealias StrokeChoice = Nullable<OneOf<ColorLiteral>.Or<ExprRef>>

    /// Generated by Curio
    public typealias StrokeDashChoice = OneOf<[Double]>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeDashOffsetChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeJoinChoice = OneOf<StrokeJoin>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeMiterLimitChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeOpacityChoice = OneOf<Double>.Or<ExprRef>

    /// Generated by Curio
    public typealias StrokeWidthChoice = OneOf<Double>.Or<ExprRef>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case clip
        case continuousHeight
        case continuousWidth
        case cornerRadius
        case cursor
        case discreteHeight
        case discreteWidth
        case fill
        case fillOpacity
        case opacity
        case step
        case stroke
        case strokeCap
        case strokeDash
        case strokeDashOffset
        case strokeJoin
        case strokeMiterLimit
        case strokeOpacity
        case strokeWidth
        public var keyDescription: String? {
            switch self {
            case .clip: return "Whether the view should be clipped."
            case .continuousHeight: return "The default height when the plot has a continuous y-field for x or latitude, or has arc marks.\n\n__Default value:__ `200`"
            case .continuousWidth: return "The default width when the plot has a continuous field for x or longitude, or has arc marks.\n\n__Default value:__ `200`"
            case .cornerRadius: return nil
            case .cursor: return "The mouse cursor used over the view. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used."
            case .discreteHeight: return "The default height when the plot has non arc marks and either a discrete y-field or no y-field. The height can be either a number indicating a fixed height or an object in the form of `{step: number}` defining the height per discrete step.\n\n__Default value:__ a step size based on `config.view.step`."
            case .discreteWidth: return "The default width when the plot has non-arc marks and either a discrete x-field or no x-field. The width can be either a number indicating a fixed width or an object in the form of `{step: number}` defining the width per discrete step.\n\n__Default value:__ a step size based on `config.view.step`."
            case .fill: return "The fill color.\n\n__Default value:__ `undefined`"
            case .fillOpacity: return nil
            case .opacity: return "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise."
            case .step: return "Default step size for x-/y- discrete fields."
            case .stroke: return "The stroke color.\n\n__Default value:__ `\"#ddd\"`"
            case .strokeCap: return nil
            case .strokeDash: return nil
            case .strokeDashOffset: return nil
            case .strokeJoin: return nil
            case .strokeMiterLimit: return nil
            case .strokeOpacity: return nil
            case .strokeWidth: return nil
             } 
        }

        public typealias CodingOwner = ViewConfig
    }
}

public struct WindowEventType : Pure, Equatable, Hashable, Codable, GGType, RawCodable {
    public var rawValue: OneOf<EventType>.Or<String>

    public init(rawValue: OneOf<EventType>.Or<String>) {
        self.rawValue = rawValue 
    }

    public init(_ rawValue: OneOf<EventType>.Or<String>) {
        self.rawValue = rawValue 
    }
}

/// Generated by Curio
public struct WindowFieldDef : Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The output name for the window operation.
    public var `as`: FieldName
    /// The data field for which to compute the aggregate or window function. This can be omitted for window functions that do not operate over a field such as `"count"`, `"rank"`, `"dense_rank"`.
    public var field: FieldName?
    /// The window or aggregation operation to apply within a window (e.g., `"rank"`, `"lead"`, `"sum"`, `"average"` or `"count"`). See the list of all supported operations [here](https://vega.github.io/vega-lite/docs/window.html#ops).
    public var op: OpChoice
    /// Parameter values for the window functions. Parameter values can be omitted for operations that do not accept a parameter.
    /// See the list of all supported operations and their parameters [here](https://vega.github.io/vega-lite/docs/transforms/window.html).
    public var param: Double?
    public static let codingKeyPaths = (\Self.`as` as KeyPath, \Self.field as KeyPath, \Self.op as KeyPath, \Self.param as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.`as` as KeyPath : CodingKeys.`as`, \Self.field as KeyPath : CodingKeys.field, \Self.op as KeyPath : CodingKeys.op, \Self.param as KeyPath : CodingKeys.param]

    public init(`as`: FieldName, field: FieldName? = nil, op: OpChoice, param: Double? = nil) {
        self.`as` = `as` 
        self.field = field 
        self.op = op 
        self.param = param 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.`as` = try values.decode(FieldName.self, forKey: .`as`) 
        self.field = try values.decodeOptional(FieldName.self, forKey: .field) 
        self.op = try values.decode(OpChoice.self, forKey: .op) 
        self.param = try values.decodeOptional(Double.self, forKey: .param) 
    }

    /// The window or aggregation operation to apply within a window (e.g., `"rank"`, `"lead"`, `"sum"`, `"average"` or `"count"`). See the list of all supported operations [here](https://vega.github.io/vega-lite/docs/window.html#ops).
    /// Generated by Curio
    public typealias OpChoice = OneOf<AggregateOp>.Or<WindowOnlyOp>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case `as`
        case field
        case op
        case param
        public var keyDescription: String? {
            switch self {
            case .`as`: return "The output name for the window operation."
            case .field: return "The data field for which to compute the aggregate or window function. This can be omitted for window functions that do not operate over a field such as `\"count\"`, `\"rank\"`, `\"dense_rank\"`."
            case .op: return "The window or aggregation operation to apply within a window (e.g., `\"rank\"`, `\"lead\"`, `\"sum\"`, `\"average\"` or `\"count\"`). See the list of all supported operations [here](https://vega.github.io/vega-lite/docs/window.html#ops)."
            case .param: return "Parameter values for the window functions. Parameter values can be omitted for operations that do not accept a parameter.\n\nSee the list of all supported operations and their parameters [here](https://vega.github.io/vega-lite/docs/transforms/window.html)."
             } 
        }

        public typealias CodingOwner = WindowFieldDef
    }
}

/// Generated by Curio
public struct WindowTransform : Identifiable, Pure, Equatable, Hashable, Codable, GGType, KeyedCodable {
    /// The unique identifier
    public var id: TransformId?
    /// A frame specification as a two-element array indicating how the sliding window should proceed. The array entries should either be a number indicating the offset from the current data object, or null to indicate unbounded rows preceding or following the current data object. The default value is `[null, 0]`, indicating that the sliding window includes the current object and all preceding objects. The value `[-5, 5]` indicates that the window should include five objects preceding and five objects following the current object. Finally, `[null, null]` indicates that the window frame should always include all data objects. If you this frame and want to assign the same value to add objects, you can use the simpler [join aggregate transform](https://vega.github.io/vega-lite/docs/joinaggregate.html). The only operators affected are the aggregation operations and the `first_value`, `last_value`, and `nth_value` window operations. The other window operations are not affected by this.
    /// __Default value:__:  `[null, 0]` (includes the current object and all preceding objects)
    public var frame: [FrameItemChoice]?
    /// The data fields for partitioning the data objects into separate windows. If unspecified, all data points will be in a single window.
    public var groupby: [FieldName]?
    /// Indicates if the sliding window frame should ignore peer values (data that are considered identical by the sort criteria). The default is false, causing the window frame to expand to include all peer values. If set to true, the window frame will be defined by offset values only. This setting only affects those operations that depend on the window frame, namely aggregation operations and the first_value, last_value, and nth_value window operations.
    /// __Default value:__ `false`
    public var ignorePeers: Bool?
    /// A sort field definition for sorting data objects within a window. If two data objects are considered equal by the comparator, they are considered "peer" values of equal rank. If sort is not specified, the order is undefined: data objects are processed in the order they are observed and none are considered peers (the ignorePeers parameter is ignored and treated as if set to `true`).
    public var sort: [SortField]?
    /// The definition of the fields in the window, and what calculations to use.
    public var window: [WindowFieldDef]
    public static let codingKeyPaths = (\Self.id as KeyPath, \Self.frame as KeyPath, \Self.groupby as KeyPath, \Self.ignorePeers as KeyPath, \Self.sort as KeyPath, \Self.window as KeyPath)
    public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.id as KeyPath : CodingKeys.id, \Self.frame as KeyPath : CodingKeys.frame, \Self.groupby as KeyPath : CodingKeys.groupby, \Self.ignorePeers as KeyPath : CodingKeys.ignorePeers, \Self.sort as KeyPath : CodingKeys.sort, \Self.window as KeyPath : CodingKeys.window]

    public init(id: TransformId? = nil, frame: [FrameItemChoice]? = nil, groupby: [FieldName]? = nil, ignorePeers: Bool? = nil, sort: [SortField]? = nil, window: [WindowFieldDef] = []) {
        self.id = id 
        self.frame = frame 
        self.groupby = groupby 
        self.ignorePeers = ignorePeers 
        self.sort = sort 
        self.window = window 
    }

    public init(from decoder: Decoder) throws {
        try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases) 
        let values = try decoder.container(keyedBy: CodingKeys.self) 
        self.id = try values.decodeOptional(TransformId.self, forKey: .id) 
        self.frame = try values.decodeOptional([FrameItemChoice].self, forKey: .frame) 
        self.groupby = try values.decodeOptional([FieldName].self, forKey: .groupby) 
        self.ignorePeers = try values.decodeOptional(Bool.self, forKey: .ignorePeers) 
        self.sort = try values.decodeOptional([SortField].self, forKey: .sort) 
        self.window = try values.decode([WindowFieldDef].self, forKey: .window) 
    }

    /// Generated by Curio
    public typealias FrameItemChoice = Nullable<Double>

    public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
        case id
        case frame
        case groupby
        case ignorePeers
        case sort
        case window
        public var keyDescription: String? {
            switch self {
            case .id: return nil
            case .frame: return "A frame specification as a two-element array indicating how the sliding window should proceed. The array entries should either be a number indicating the offset from the current data object, or null to indicate unbounded rows preceding or following the current data object. The default value is `[null, 0]`, indicating that the sliding window includes the current object and all preceding objects. The value `[-5, 5]` indicates that the window should include five objects preceding and five objects following the current object. Finally, `[null, null]` indicates that the window frame should always include all data objects. If you this frame and want to assign the same value to add objects, you can use the simpler [join aggregate transform](https://vega.github.io/vega-lite/docs/joinaggregate.html). The only operators affected are the aggregation operations and the `first_value`, `last_value`, and `nth_value` window operations. The other window operations are not affected by this.\n\n__Default value:__:  `[null, 0]` (includes the current object and all preceding objects)"
            case .groupby: return "The data fields for partitioning the data objects into separate windows. If unspecified, all data points will be in a single window."
            case .ignorePeers: return "Indicates if the sliding window frame should ignore peer values (data that are considered identical by the sort criteria). The default is false, causing the window frame to expand to include all peer values. If set to true, the window frame will be defined by offset values only. This setting only affects those operations that depend on the window frame, namely aggregation operations and the first_value, last_value, and nth_value window operations.\n\n__Default value:__ `false`"
            case .sort: return "A sort field definition for sorting data objects within a window. If two data objects are considered equal by the comparator, they are considered \"peer\" values of equal rank. If sort is not specified, the order is undefined: data objects are processed in the order they are observed and none are considered peers (the ignorePeers parameter is ignored and treated as if set to `true`)."
            case .window: return "The definition of the fields in the window, and what calculations to use."
             } 
        }

        public typealias CodingOwner = WindowTransform
    }
}
}
